---
output: pdf_document
---
```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
suppressMessages(expr =  {
  if ("patchwork" %in% row.names(installed.packages()) == FALSE) {
    install.packages("patchwork")
  }
  if ("bayesplay" %in% row.names(installed.packages()) == FALSE) {
    install.packages("bayesplay")
  }
  if ("polspline" %in% row.names(installed.packages()) == FALSE) {
    install.packages("polspline")
  }

  if ("IRdisplay" %in% row.names(installed.packages()) == TRUE) {
    display_markdown <<- \(x) IRdisplay::display_markdown(as.character(x))
    display_html <<- \(x) IRdisplay::display_html(as.character(x))
  } else {
    display_markdown <<- knitr::asis_output
    display_html <<- knitr::asis_output
  }

  library(tidyverse)
  library(polspline)
  library(patchwork)
  library(magrittr)
  library(bayesplay)
})

table_format <- "html"

```
# An alternative to *p* values
<a href="data:text/x-markdown;base64,LS0tCnRpdGxlOiAiTGlrZWxpaG9vZHMiCm91dHB1dDogaHRtbF9kb2N1bWVudAotLS0KCmBgYHtyIHNldHVwLCBlY2hvPUZBTFNFfQprbml0cjo6b3B0c19jaHVuayRzZXQoZWNobyA9IEZBTFNFKQpzdXBwcmVzc01lc3NhZ2VzKGV4cHIgPSAgewogIGlmICgicGF0Y2h3b3JrIiAlaW4lIHJvdy5uYW1lcyhpbnN0YWxsZWQucGFja2FnZXMoKSkgPT0gRkFMU0UpIHsKICAgIGluc3RhbGwucGFja2FnZXMoInBhdGNod29yayIpCiAgfQogIGlmICgiYmF5ZXNwbGF5IiAlaW4lIHJvdy5uYW1lcyhpbnN0YWxsZWQucGFja2FnZXMoKSkgPT0gRkFMU0UpIHsKICAgIGluc3RhbGwucGFja2FnZXMoImJheWVzcGxheSIpCiAgfQogIGlmICgicG9sc3BsaW5lIiAlaW4lIHJvdy5uYW1lcyhpbnN0YWxsZWQucGFja2FnZXMoKSkgPT0gRkFMU0UpIHsKICAgIGluc3RhbGwucGFja2FnZXMoInBvbHNwbGluZSIpCiAgfQoKICBpZiAoIklSZGlzcGxheSIgJWluJSByb3cubmFtZXMoaW5zdGFsbGVkLnBhY2thZ2VzKCkpID09IFRSVUUpIHsKICAgIGRpc3BsYXlfbWFya2Rvd24gPDwtIFwoeCkgSVJkaXNwbGF5OjpkaXNwbGF5X21hcmtkb3duKGFzLmNoYXJhY3Rlcih4KSkKICAgIGRpc3BsYXlfaHRtbCA8PC0gXCh4KSBJUmRpc3BsYXk6OmRpc3BsYXlfaHRtbChhcy5jaGFyYWN0ZXIoeCkpCiAgfSBlbHNlIHsKICAgIGRpc3BsYXlfbWFya2Rvd24gPDwtIGtuaXRyOjphc2lzX291dHB1dAogICAgZGlzcGxheV9odG1sIDw8LSBrbml0cjo6YXNpc19vdXRwdXQKICB9CgogIGxpYnJhcnkodGlkeXZlcnNlKQogIGxpYnJhcnkocG9sc3BsaW5lKQogIGxpYnJhcnkocGF0Y2h3b3JrKQogIGxpYnJhcnkobWFncml0dHIpCiAgbGlicmFyeShiYXllc3BsYXkpCn0pCgp0YWJsZV9mb3JtYXQgPC0gImh0bWwiCgpgYGAKIyBBbiBhbHRlcm5hdGl2ZSB0byAqcCogdmFsdWVzCgpDb21pbmcgdXAgd2l0aCBhbiBhbHRlcm5hdGl2ZSB0byAqcCogdmFsdWVzIHJlcXVpcmVzIHVzIHRvIHJlYXJyYW5nZSBvdXIKdGhpbmtpbmcgYSBiaXQuIFNvIGxldCdzIGZpcnN0IGdldCBzdHJhaWdodCB3aGF0IHdlJ3JlIGRvaW5nIHdpdGggZnJlcXVlbnRpc3QKaW5mZXJlbmNlLiBJbiBmcmVxdWVudGlzdCBpbmZlcmVuY2Ugd2Ugc2V0IHNvbWUgcGFyYW1ldGVyIHRvIGEgY2VydGFpbiB2YWx1ZQooJFx0aGV0YSQpLCB3ZSB0aGVuIGdlbmVyYXRlIGRhdGEgZnJvbSBpbWFnaW5hcnkgZXhwZXJpbWVudHMgdXNpbmcgdGhhdApwYXJhbWV0ZXIgc2V0dGluZywgYW5kIHdlIHRoZW4gY29tcGFyZSBvdXIgZGF0YSB0byB0aGUgZGF0YSBmcm9tIHRob3NlCmV4cGVyaW1lbnRzLiBXZSB0aGVuIGFzayB0aGUgcXVlc3Rpb246ICJHaXZlbiB0aGF0IHBhcmFtZXRlciB2YWx1ZSwgaG93CnN1cnByaXNpbmcgaXMgb3VyIGRhdGE/IiBBdCBubyBwb2ludCBhcmUgd2UgbWFraW5nIGluZmVyZW5jZXMgKmFib3V0IHRoZSB2YWx1ZSoKb2YgJFx0aGV0YSQuIFdlICoqc2V0KiogdGhlIHZhbHVlLCBhbmQgd2UgYXNrIGEgcXVlc3Rpb24gYWJvdXQgb3VyIGRhdGEgaW4KcmVsYXRpb24gdG8gKiphbGwgdGhlIHBvc3NpYmxlIGRhdGEqKiB0aGF0IG1pZ2h0IGJlIGdlbmVyYXRlZC4KClRvIHRoaW5rIGFib3V0IHdoYXQgYW4gYWx0ZXJuYXRpdmUgbWlnaHQgbG9vayBsaWtlLCBsZXQgdXMgdGhpbmsgYmFjayB0byBvdXIKZWFybGllciBleGFtcGxlIG9uIHRoZSBkaWZmZXJlbnQgbWVhbmluZ3Mgb2YgcHJvYmFiaWxpdHkuIFdpdGggKnAqLXZhbHVlcyB3ZQp0aG91Z2h0IGFib3V0IHByb2JhYmlsaXR5IGluIHRlcm1zIG9mIHJlbGF0aXZlIGZyZXF1ZW5jeS4gV2Ugd2VyZSBhc2tpbmcgImhvdwpvZnRlbj8iIHF1ZXN0aW9ucy4gQnV0IEkgYWxzbyBtZW50aW9uZWQgYW5vdGhlciBleGFtcGxlLiBUaGUgZXhhbXBsZSBvZiBiZWluZwo5MCUgc3VyZSB0aGF0IHRoZSBhY2N1c2VkIGNvbW1pdHRlZCBhIGNyaW1lLiBJZiB3ZSB3YW50IHRvIGJlIHJhdGlvbmFsIGh1bWFucywKd2hlbiB3ZSBtYWtlIGNsYWltcyBsaWtlIHRoaXMgd2hhdCB3ZSB1c3VhbGx5IGRvIGlzIGV4YW1pbmUgdGhlIGV2aWRlbmNlLiBXZQoqKmNvbXBhcmUqKiB3aGV0aGVyIHRoZXJlIGlzIG1vcmUgZXZpZGVuY2UgZm9yIHRoZSBhY2N1c2VkJ3MgZ3VpbHQgb3IgdGhlCmFjY3VzZWQncyBpbm5vY2VuY2UuIFRoYXQgaXMsIHdlIHRha2UgdGhlIGNvdXJ0cm9vbSBldmlkZW5jZSBhbmQgZXhhbWluZQp3aGV0aGVyIGl0IHN1cHBvcnRzIGh5cG90aGVzaXMgMSAodGhlIGFjY3VzZWQgaXMgZ3VpbHR5KSBvciBoeXBvdGhlc2lzIDIgKHRoZQphY2N1c2VkIGlzIGlubm9jZW50KS4gVG8gZG8gdGhpcyB3ZSBiYWxhbmNlIG9mIHByb2JhYmlsaXRpZXMuIElzIGlzIG1vcmUKcHJvYmFibGUgdGhhdCB3ZSdkIHNlZSB0aGlzIGV2aWRlbmNlIGlmIGh5cG90aGVzaXMgMSB3YXMgdHJ1ZSwgb3IgaXMgaXQgbW9yZQpwcm9iYWJsZSB0aGF0IHdlJ2Qgc2VlIHRoaXMgZXZpZGVuY2UgaWYgaHlwb3RoZXNpcyAyIHdhcyB0cnVlPyAoSW4gYSBjaXZpbAp0cmlhbCB3ZSdkIGp1c3Qgd2VpZ2ggdXAgdGhlIHByb2JhYmlsaXRpZXMsIGJ1dCBpbiBhIGNyaW1pbmFsIHRyaWFsIHdlJ2QgaGF2ZQp0byBhbHNvIGV4YW1pbmUgd2hldGhlciB0aGlzIGRpZmZlcmVuY2UgaW4gcHJvYmFiaWxpdGllcyBleGNlZWRzIHNvbWUKdGhyZXNob2xkLiBXZSdsbCBsZWF2ZSB0aGlzIGlzc3VlIG9mIHRocmVzaG9sZHMgZm9yIG5vdykuIE1pZ2h0IHdlIGJlIGFibGUgdG8KYXBwbHkgdGhlIHNhbWUga2luZCBvZiB0aGlua2luZyB0byBzdGF0aXN0aWNhbCBldmlkZW5jZT8KClRvIHVuZGVyc3RhbmQgdGhlIGNvbmNlcHQgb2Ygc3RhdGlzdGljYWwgZXZpZGVuY2UsIGxldCdzIGdvIGJhY2sgdG8gb3VyIGNvaW4KZmxpcHBpbmcgZXhhbXBsZS4gSW4gb3VyIGNvaW4gZmxpcHBpbmcgZXhhbXBsZSwgd2UgY29sbGVjdGVkIDEwIGZsaXBzIGFuZCBmb3VuZAo4IGhlYWRzIGFuZCAyIHRhaWxzLiBPdXIgZnJlcXVlbnRpc3QgYW5hbHlzaXMgYXNrZWQgc29tZXRoaW5nIGxpa2UsICJpcyB0aGlzCmRhdGEgc3VycHJpc2luZz8iLiBCdXQgd2UgY291bGQgYXNrIGFub3RoZXIgcXVlc3Rpb24uIFRoYXQgcXVlc3Rpb24gbWlnaHQgZ28Kc29tZXRoaW5nIGxpa2UgdGhpczogIklzIGl0IG1vcmUgbGlrZWx5IHRoYXQgdGhlICoqYmlhcyBpcyAwLjYqKiBvciB0aGF0IHRoZQoqKmJpYXMgaXMgMC44KiogZ2l2ZW4gdGhhdCB3ZSdkIG9idGFpbmVkIDggaGVhZHMgaW4gMTAgZmxpcHM/IgoKVG8gdHJ5IGFuZCBhbnN3ZXIgdGhpcyBxdWVzdGlvbiwgd2UnbGwgYWdhaW4gY3JlYXRlIHNvbWUgc2ltdWxhdGlvbnMuIFdlJ2xsCnN0YXJ0IGJ5IGNyZWF0aW5nIHR3byAqKnNhbXBsaW5nIGRpc3RyaWJ1dGlvbnMqKi4gRm9yIG5vdyB3ZSdsbCBrZWVwIHRoaW5ncwpzaW1wbGUgYW5kIHdlJ2xsIGNyZWF0ZSB0aGVzZSBzYW1wbGluZyBkaXN0cmlidXRpb25zIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgSQppbnRlbmRlZCB0byBmbGlwIHRoZSBjb2luIDEwIHRpbWVzLiBUbyBjcmVhdGUgb3VyIHNhbXBsaW5nIGRpc3RyaWJ1dGlvbnMgd2UnbGwKZmlyc3Qgc2V0ICRcdGhldGEkIHRvIDAuNiBhbmQgcnVuIHRoZSBzaW11bGF0aW9ucywgYW5kIHRoZW4gd2UnbGwgc2V0ICRcdGhldGEkCnRvIDAuOCBhbmQgcnVuIHRoZSBzaW11bGF0aW9ucy4gSSBrbm93IHRoZSBkaXN0cmlidXRpb24gdGhleSdsbCBmb2xsb3csIHNvIEknbGwKanVzdCBjb21wdXRlIHRoZSBkaXN0cmlidXRpb25zIGRpcmVjdGx5IHJhdGhlciB0aGFuIGFjdHVhbGx5IHJ1bm5pbmcgdGhlCnNpbXVsYXRpb25zLgoKYGBge3J9CiMgZmxpcCB0aGUgY29pbiBuIHRpbWVzIGFuZCB0aGVuIGNvdW50IHVwIHRoZSBoZWFkcy4KIyB0aHJlZSBwYXJhbWV0ZXJzIG5lZWQgdG8gYmUgc2V0CiMgMS4gdGhlIG51bWJlciBvZiBmbGlwcyAobl9mbGlwcykKIyAyLiB0aGUgcHJvYmFiaWxpdHkgb2YgaGVhZHMgKHByX2hlYWRzKQojIDMuIHRoZSBudW1iZXIgb2YgaGVhZHMgaW4gb3VyIG9ic2VydmF0aW9uIChvYnNfaGVhZHMpCgpjb2luX2ZsaXBfdjEgPC0gZnVuY3Rpb24obl9mbGlwcywgcHJfaGVhZHMsIG9ic19oZWFkcykgewogIHBtYXBfZGYoCiAgICB0aWJibGUoaGVhZHMgPSAwOm5fZmxpcHMsIGZsaXBzID0gbl9mbGlwcywgcHJfaGVhZHMgPSBwcl9oZWFkcyksCiAgICBmdW5jdGlvbihoZWFkcywgZmxpcHMsIHByX2hlYWRzKSB7CiAgICAgIHRpYmJsZSgKICAgICAgICBmbGlwcyA9IGZsaXBzLCBoZWFkcyA9IGhlYWRzLAogICAgICAgIGZyZXEgPSBkYmlub20oaGVhZHMsIGZsaXBzLCBwcl9oZWFkcykKICAgICAgKQogICAgfQogICkgJT4lICMgZ2V0IHRoZSBmcmVxdWVuY3kKICAgIG11dGF0ZShvdXJfb2IgPSBjYXNlX3doZW4oCiAgICAgIGZsaXBzID09IG5fZmxpcHMgJiBoZWFkcyA9PSBvYnNfaGVhZHMgfiBUUlVFLAogICAgICBUUlVFIH4gRkFMU0UKICAgICkpICMgbWFyayBvdXIgb2JzZXJ2YXRpb24KfQpgYGAKCldlIGNhbiBkcmF3IHRoZSBkaXN0cmlidXRpb25zIG9mIHRoZSBwb3NzaWJsZSBkYXRhIHRoYXQgd291bGQgb2NjdXIgZm9yCmRpZmZlcmVudCB2YWx1ZXMgb2YgUChoZWFkcykgPSAkXHRoZXRhJC4gSW4gZWFjaCBvZiB0aGUgcGxvdHMsIG91cgphY3R1YWwgb2JzZXJ2YXRpb24gd2lsbCBiZSBoaWdobGlnaHRlZC4gQWx0aG91Z2ggd2UncmUgInNpbXVsYXRpbmciIGFsbApwb3NzaWJsZSBvYnNlcnZhdGlvbnMsIHlvdSdsbCBzZWUgdGhhdCB3ZSdyZSBvbmx5IGdvaW5nIHRvIGNhcmUgYWJvdXQgb3VyCioqYWN0dWFsKiogb2JzZXJ2YXRpb24uIFdlIHdpbGwgd2FudCB0byBrbm93IHRoZSByZWxhdGl2ZSBmcmVxdWVuY3kgd2l0aCB3aGljaAoqKnRoYXQqKiByZXN1bHQgb2NjdXJzLCBub3QgdGhlIGZyZXF1ZW5jeSBvZiByZXN1bHRzIHRoYXQgZGlkbid0IGJ1dCBtaWdodCd2ZQpvY2N1cnJlZC4gSSdtIGdvaW5nIHRvIGRyYXcgc2V2ZXJhbCBkaXN0cmlidXRpb25zIG5vdCBqdXN0IHR3byB0aGF0IGNvcnJlc3BvbmQKdG8gdGhlIHZhbHVlcyBvZiAkXHRoZXRhJCB0aGF0IHdlJ3JlIGludGVyZXN0ZWQgaW4uCgpgYGB7cn0KIyBkcmF3IGRpc3RyaWJ1dGlvbnMgb2YgdGhlIGRhdGEgZm9yIHZhcmlvdXMgdmFsdWVzIG9mIHByX2hlYWRzIGZvciB2ZXJzaW9uIDEKIyAoZmxpcCBuIHRpbWVzKQoKbl9mbGlwcyA8LSAxMAoKcHJfaGVhZHNfdmFsdWVzIDwtIGMoMC4yLCAwLjQsIDAuNiwgMC44KSAjIHNldCBvdXIgcHJfaGVhZHMgdmFsdWVzCgpvYnNfaGVhZHMgPC0gOAoKIyBtYWtlIHRoZSBwbG90cwpjb2luX2ZsaXBfdjFfcGxvdHMgPC0gcG1hcCgKICB0aWJibGUobl9mbGlwcyA9IG5fZmxpcHMsIHByX2hlYWRzID0gcHJfaGVhZHNfdmFsdWVzLCBvYnNfaGVhZHMgPSBvYnNfaGVhZHMpLAogIGZ1bmN0aW9uKG5fZmxpcHMsIHByX2hlYWRzLCBvYnNfaGVhZHMpIHsKICAgIGNvaW5fZmxpcF92MShuX2ZsaXBzLCBwcl9oZWFkcywgb2JzX2hlYWRzKSAlPiUKICAgICAgZ2dwbG90KGFlcyh4ID0gaGVhZHMsIHkgPSBmcmVxKSkgKwogICAgICBnZW9tX2xpbmUoYWxwaGEgPSAuMjUpICsKICAgICAgZ2VvbV9wb2ludChhZXMoY29sb3VyID0gb3VyX29iKSwgc2l6ZSA9IDMpICsKICAgICAgc2NhbGVfY29sb3VyX21hbnVhbCgKICAgICAgICBndWlkZSA9ICJub25lIiwKICAgICAgICB2YWx1ZXMgPSBjKCJUUlVFIiA9ICJibGFjayIsICJGQUxTRSIgPSAiZ3JleSIpCiAgICAgICkgKwogICAgICBsYWJzKAogICAgICAgIHggPSBnbHVlOjpnbHVlKCJudW1iZXIgb2YgaGVhZHMgaW4ge25fZmxpcHN9IGZsaXBzIiksCiAgICAgICAgeSA9ICJyZWxhdGl2ZSBmcmVxdWVuY3kiLAogICAgICAgIHRpdGxlID0gZ2x1ZTo6Z2x1ZSgiUChoZWFkcykgPSB7cHJfaGVhZHN9IikKICAgICAgKSArCiAgICAgIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBjKHNlcSgwLCBuX2ZsaXBzLCAxKSkpICsKICAgICAgc2NhbGVfeV9jb250aW51b3VzKGxpbWl0cyA9IGMoMCwgLjUpKSArCiAgICAgIHRoZW1lX21pbmltYWwoKSArCiAgICAgIE5VTEwKICB9CikKCiMgbWFrZSB0aGUgcGxvdHMgcHJldHR5IGFuZCBhcnJhbmdlIHRoZW0KCihwYXRjaHdvcms6OndyYXBfcGxvdHMoY29pbl9mbGlwX3YxX3Bsb3RzLCBucm93ID0gMikgKwogIHBsb3RfYW5ub3RhdGlvbih0YWdfbGV2ZWxzID0gIkEiKSkKYGBgCgpMZXQncyB0YWtlIHRoZXNlIHBsb3RzIGFuZCBjcmVhdGUgYSBuZXcgb25lIG91dCBvZiB0aGVtLiBTaW5jZSB3ZSdyZSBqdXN0CmludGVyZXN0ZWQgaW4gKipvdXIgc3BlY2lmaWMgb2JzZXJ2YXRpb24qKiB3ZSdsbCB0YWtlIGFsbCB0aGUgbWFya2VkIHBvaW50cyBhbmQKcHV0IHRoZW0gb24gYSBwbG90IG9mIHRoZWlyIG93bi4gTm93IHdlJ2xsIHN0aWxsIGhhdmUgcmVsYXRpdmUgZnJlcXVlbmN5IG9uIHRoZQp5LWF4aXMsIGJ1dCBvbiB0aGUgeC1heGlzIHdlIHdvbid0IGhhdmUgdGhlIG9ic2VydmF0aW9uIGFueW1vcmUgKGJlY2F1c2Ugd2UncmUKb25seSBmb2N1c2VkIG9uIG9uZSBzcGVjaWZpYyBvdXRjb21lKS4gSW5zdGVhZCwgd2UnbGwgaGF2ZSAkXHRoZXRhJCBvbiB0aGUKeC1heGlzLgoKYGBge3J9CiMgZmlyc3Qgc2V0IG91ciBvYnNlcnZhdGlvbiBhZ2FpbgpudW1iZXJfb2ZfaGVhZHMgPC0gOApudW1iZXJfb2ZfZmxpcHMgPC0gMTAKCiMgYW5kIHNldCB0aGUgcmFuZ2Ugb2YgYmlhcyB0byBjb25zaWRlcgpwcl9oZWFkc19yYW5nZSA8LSBzZXEoMCwgMSwgLjEpICMgMC8xMCwgMS8xMCAuLi4gOS8xMCwgMTAvMTAKCiMgdHJhbnNsYXRlIG91ciBvYnNlcnZhdGlvbiBpbnRvIHRoZSBwYXJhbWV0ZXJzIG5lZWRlZCBmb3IgdmVyc2lvbiAxCiMgZ2VuZXJhdGUgdGhlIGRhdGEgYW5kIHB1bGwgb3V0IHRoZSByZWxhdGl2ZSBmcmVxdWVuY3kgb2Ygb3VyIHNwZWNpZmljCiMgb2JzZXJ2YXRpb24KCm5fZmxpcHMgPC0gbnVtYmVyX29mX2ZsaXBzCm9ic19oZWFkcyA8LSBudW1iZXJfb2ZfaGVhZHMKbGlrZWxpaG9vZF92MSA8LSBtYXBfZGYocHJfaGVhZHNfcmFuZ2UsIGZ1bmN0aW9uKHgpIHsKICBjb2luX2ZsaXBfdjEobl9mbGlwcywgeCwgb2JzX2hlYWRzKSAlPiUKICAgIGZpbHRlcihvdXJfb2IgPT0gVFJVRSkgJT4lCiAgICBzZWxlY3QoZnJlcSkgJT4lCiAgICBtdXRhdGUocHJfaGVhZHMgPSB4KQp9KQpgYGAKCmBgYHtyfQojIG5vdyBhY3R1YWxseSBkcmF3IHRoZSBwbG90CgpsaWtlbGlob29kX3YxICU+JQogIGdncGxvdChhZXMoeCA9IHByX2hlYWRzLCB5ID0gZnJlcSkpICsKICBnZW9tX3BvaW50KCkgKwogIGdlb21fbGluZSgpICsKICB0aGVtZV9taW5pbWFsKDEyKSArCiAgc2NhbGVfeF9jb250aW51b3VzKG5hbWUgPSAiUChoZWFkcykiLCBicmVha3MgPSBzZXEoMCwgMSwgLjIpKSArCiAgc2NhbGVfeV9jb250aW51b3VzKGxpbWl0cyA9IGMoMCwgLjQpLCBuYW1lID0gInJlbGF0aXZlIGZyZXF1ZW5jeSIpICsKICBsYWJzKAogICAgdGl0bGUgPSBnbHVlOjpnbHVlKAogICAgICAibGlrZWxpaG9vZCBmdW5jdGlvbiBmb3Ige251bWJlcl9vZl9oZWFkc30iLAogICAgICAiIGhlYWRzIGluIHtudW1iZXJfb2ZfZmxpcHN9IGZsaXBzIgogICAgKSwKICAgIHN1YnRpdGxlID0gZ2x1ZTo6Z2x1ZSgic3RvcHBpbmcgYWZ0ZXIge251bWJlcl9vZl9mbGlwc30iKQogICkKYGBgCgpUaGlzIG5ldyBwbG90IHRoYXQgd2UncmUgY3JlYXRlZCBpbGx1c3RyYXRlcyB3aGF0J3Mga25vdyBhcyB0aGUgKipsaWtlbGlob29kKioKZnVuY3Rpb24uIFRoZSBsaWtlbGlob29kIGZ1bmN0aW9uIGRlc2NyaWJlcyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gdmFsdWVzIG9mCnRoZSBwYXJhbWV0ZXIgYW5kICoqb3VyIGRhdGEqKi4gSXQncyBtYWRlIHVwIG9mIHNsaWNlcyBvZiB0aGUgc2FtcGxpbmcKZGlzdHJpYnV0aW9uLXRoZSBzbGljZXMgdGhhdCBjb3JyZXNwb25kIHRvIG91ciBhY3R1YWwgb2JzZXJ2YXRpb24uIFJlbWVtYmVyCnRoYXQgd2hlbiB3ZSB3ZXJlIGRvaW5nIGluZmVyZW5jZSB3aXRoIHRoZSBzYW1wbGluZyBkaXN0cmlidXRpb24gd2Ugd2VyZQpsb29raW5nIGF0IHRoZSBleHRyZW1lIHRhaWxzIG9mIHRoZSBzYW1wbGluZyBkaXN0cmlidXRpb24uIFRoYXQgaXMsIHdlIHdlcmUKaW50ZXJlc3RlZCBpbiB0aGUgZW50aXJlIHNoYXBlIG9mIHRoZSBzYW1wbGluZyBkaXN0cmlidXRpb24uIE5vdyB3ZSdyZSBpbnN0ZWFkCm9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgdGhpbiBzbGljZSB0aGF0IGNvcnJlc3BvbmRzIHRvIG91ciBvYnNlcnZhdGlvbi4KCiMjIERvaW5nIGluZmVyZW5jZSB3aXRoIGxpa2VsaWhvb2RzCgpUaGUgbGlrZWxpaG9vZCBwbGF5cyBhIGtleSByb2xlIGluIEJheWVzaWFuIGluZmVyZW5jZS4gSW5mZXJlbmNlcyBvbiB0aGUgYmFzaXMKb2YgbGlrZWxpaG9vZHMgYXJlIGRlcml2ZWQgZnJvbSB3aGF0IGlzIGtub3duIGF0IHRoZSAqbGF3IG9mIGxpa2VsaWhvb2QqLgpTaW1wbHkgc3RhdGVkLCB0aGUgKmxhdyBvZiBsaWtlbGlob29kKiBzYXlzIHRoYXQgZm9yIGEgZ2l2ZW4gcGFpciBvZgpoeXBvdGhlc2VzLS0tZm9yIGV4YW1wbGUsICRcbWF0aGNhbHtIfV8xJCB0aGF0IHRoZSBjb2luIGJpYXMgaXMgUChoZWFkcyk9MC42CmFuZCAkXG1hdGhjYWx7SH1fMiQgdGhhdCB0aGUgY29pbiBiaWFzIGlzIFAoaGVhZHMpPTAuOC0tLXRoZW4gZGF0YSBzdXBwb3J0CiRcbWF0aGNhbHtIfV8xJCBvdmVyICRcbWF0aGNhbHtIfV8yJCBpZiB0aGUgbGlrZWxpaG9vZCBvZiAkXG1hdGhjYWx7SH1fMSQKZXhjZWVkcyB0aGF0IG9mICRcbWF0aGNhbHtIfV8yJC4gT3IsIHB1dCBhbm90aGVyIHdheSwgaWYgb3VyIGRhdGEgd291bGQgYmUKcHJvZHVjZWQgbW9yZSBvZnRlbiBpZiAkXG1hdGhjYWx7SH1fMSQgd2VyZSB0cnVlIHRoYW4gaWYgJFxtYXRoY2Fse0h9XzIkIHdlcmUKdHJ1ZSwgdGhlbiB0aGUgZGF0YSBwcm92aWRlIHN1cHBvcnQgZm9yICRcbWF0aGNhbHtIfV8xJCBvdmVyICRcbWF0aGNhbHtIfV8yJAooU2VlIFtIYWNraW5nLAoxOTY1XShodHRwczovL3d3dy5nb29nbGUuY28udWsvYm9va3MvZWRpdGlvbi9Mb2dpY19vZl9TdGF0aXN0aWNhbF9JbmZlcmVuY2UvY0VKZkRBQUFRQkFKP2hsPWVuJmdicHY9MCkgQ2hhcHRlciA1LCBmb3IgYm90aCBmb3JtdWxhdGlvbnMpLgoKVGhpcyBkZWZpbml0aW9uIG1pZ2h0IHNlZW0gYSBsaXR0bGUgb3BhcXVlLCBidXQgd2UgY2FuIHJlYWQgdGhlc2UgbGlrZWxpaG9vZAp2YWx1ZXMgc3RyYWlnaHQgb2ZmIG91ciBsaWtlbGlob29kIHBsb3QuIFRoZSBoZWlnaHQgb2YgdGhlIGxpa2VsaWhvb2QgcGxvdCwgYXQKZWFjaCB2YWx1ZSBvZiAkXHRoZXRhJCwgdGVsbHMgeW91IHRoZSBwcm9iYWJpbGl0eSBvZiBvYnRhaW5pbmcgeW91ciBkYXRhIGdpdmVuCnRoYXQgdmFsdWUgb2YgJFx0aGV0YSQuIElmIHRoZSBsaWtlbGlob29kIGZ1bmN0aW9uIGlzIGhpZ2hlciBhdCAkXHRoZXRhPTAuOCQKdGhhbiAkXHRoZXRhPTAuNiQgdGhlbiB0aGUgcHJvYmFiaWxpdHkgb2Ygb2J0YWluaW5nIG91ciBkYXRhIHdvdWxkIGJlIGhpZ2hlciBpZgokXHRoZXRhJCB3YXMgMC44IHRoYW4gaXQgd291bGQgYmUgaWYgJFx0aGV0YSQgd2FzIDAuNi4gQ29uc2VxdWVudGx5LCBvdXIgZGF0YQpzdXBwb3J0IHRoZSBoeXBvdGhlc2lzIHRoYXQgJFx0aGV0YT0wLjgkICpvdmVyKiB0aGUgaHlwb3RoZXNpcyAkXHRoZXRhPTAuNiQuIEEKa2V5IHBvaW50IGhlcmUsIHRoYXQncyB3b3J0aCBzdHJlc3NpbmcsIGlzIHRoYXQgdGhpcyBpcyBhIGNvbXBhcmlzb24gYmV0d2Vlbgp0d28gc3BlY2lmaWMgaHlwb3RoZXNpcy4gRG9lcyB0aGlzIGRhdGEgc3VwcG9ydCB0aGlzIG9uZSBzcGVjaWZpYyBoeXBvdGhlc2lzCm92ZXIgdGhpcyBvdGhlciBzcGVjaWZpYyBoeXBvdGhlc2lzLiBXaGF0IHlvdSdyZSBkb2luZyBoZXJlIGlzICp3ZWlnaGluZyB1cApwcm9iYWJpbGl0aWVzKiBqdXN0IGxpa2UgeW91IHdvdWxkIGRvIGluIGEgY291cnRyb29tLgoKIyMjIEEgYnJpZWYgZGV0b3VyIGJhY2sgdG8gc2FtcGxpbmcgcnVsZXMKCkJlZm9yZSB3ZSBjb250aW51ZSwgbGV0J3MganVzdCBnbyBiYWNrIHRvIHNvbWV0aGluZyBmcm9tIHRoZSBwcmV2aW91cyBzZWN0aW9uLgpJIG1hZGUgYSBiaWcgZGVhbCBhYm91dCBob3cgb3VyIHNhbXBsaW5nIHJ1bGVzIGNoYW5nZSB0aGUgc2hhcGUgb2YgdGhlIHNhbXBsaW5nCmRpc3RyaWJ1dGlvbiwgYW5kIHRoYXQgdGhpcyB0aGVuIGNoYW5nZXMgdGhlIGluZmVyZW5jZXMgdGhhdCB3ZSBtYWtlLiBUaGlzIGlzCnRoZSBjYXNlIGV2ZW4gaWYgbm90aGluZyBjaGFuZ2VzIGFib3V0IG91ciBhY3R1YWwgZGF0YS4gQnV0IGRvIGRpZmZlcmVudApzYW1wbGluZyBydWxlcyBjaGFuZ2UgdGhlIGxpa2VsaWhvb2Q/IFRvIHRlc3QgdGhpcyBvdXQsIHdlJ2xsIGdlbmVyYXRlIGEgbmV3CnNldCBvZiBzYW1wbGluZyBkaXN0cmlidXRpb25zIHVzaW5nIHRoZSBvdGhlciBzYW1wbGluZyBydWxlIChzYW1wbGluZyB1bnRpbCB3ZQpnZXQgMiBoZWFkcykuIEFuZCBmcm9tIHRoZXNlIHNhbXBsaW5nIGRpc3RyaWJ1dGlvbnMgd2UnbGwgZ2VuZXJhdGUgc29tZQpsaWtlbGlob29kcy4KCmBgYHtyfQojIGZ1bmN0aW9uIHYyICJzaW11bGF0ZXMiIHJlc3VsdHMgZnJvbSB0aGUgdmVyc2lvbiB3aGVyZSB5b3UKIyBmbGlwIHRoZSBjb2luIHVudGlsIGl0IGNvbWVzIHVwIHRhaWxzIG4gdGltZXMuCiMgdGhyZWUgcGFyYW1ldGVycyBuZWVkIHRvIGJlIHNldAojIDEuIHRoZSBudW1iZXIgb2YgdGFpbHMgdG8gc3RvcCBhdCAobl90YWlscykKIyAyLiB0aGUgcHJvYmFiaWxpdHkgb2YgaGVhZHMgKHByX2hlYWRzKQojIDMuIHRoZSBudW1iZXIgb2YgZmxpcHMgaW4gb3VyIG9ic2VydmF0aW9uIChvYnNfZmxpcHMpCgpjb2luX2ZsaXBfdjIgPC0gZnVuY3Rpb24obl90YWlscywgcHJfaGVhZHMsIG9ic19mbGlwcykgewogIHBtYXBfZGYoCiAgICB0aWJibGUoCiAgICAgIHRhaWxzID0gbl90YWlscywKICAgICAgcHJfaGVhZHMgPSBwcl9oZWFkcywKICAgICAgZmxpcHMgPSAwOihvYnNfZmxpcHMgKyA0KQogICAgKSwgIyBpbnB1dCB2YWx1ZXMKICAgIGZ1bmN0aW9uKHRhaWxzLCBwcl9oZWFkcywgZmxpcHMpIHsKICAgICAgdGliYmxlKAogICAgICAgIGZsaXBzID0gZmxpcHMsIHRhaWxzID0gdGFpbHMsCiAgICAgICAgZnJlcSA9IGRuYmlub20oZmxpcHMgLSB0YWlscywgdGFpbHMsIDEgLSBwcl9oZWFkcykKICAgICAgKQogICAgfQogICkgJT4lCiAgICBtdXRhdGUob3VyX29iID0gY2FzZV93aGVuKAogICAgICBmbGlwcyA9PSBvYnNfZmxpcHMgJiB0YWlscyA9PSB0YWlscyB+IFRSVUUsCiAgICAgIFRSVUUgfiBGQUxTRQogICAgKSkgIyBtYXJrIG91ciBvYnNlcnZhdGlvbgp9CmBgYAoKYGBge3J9CiMgZHJhdyBkaXN0cmlidXRpb25zIG9mIHRoZSBkYXRhIGZvciB2YXJpb3VzIHZhbHVlcyBvZiBwcl9oZWFkcyBmb3IgdmVyc2lvbiAyCiMgKGZsaXAgdW50aWwgbiB0YWlscykKCm5fdGFpbHMgPC0gMgpuX2ZsaXBzIDwtIDEwCnByX2hlYWRzX3ZhbHVlcyA8LSBjKDAuMiwgMC40LCAwLjYsIDAuOCkgIyBzZXQgb3VyIHByX2hlYWRzCm9ic19mbGlwcyA8LSAxMAojIG1ha2UgdGhlIHBsb3RzCmNvaW5fZmxpcF92Ml9wbG90cyA8LSBwbWFwKAogIHRpYmJsZShuX3RhaWxzID0gbl90YWlscywgcHJfaGVhZHMgPSBwcl9oZWFkc192YWx1ZXMsIG9ic19mbGlwcyA9IG9ic19mbGlwcyksCiAgZnVuY3Rpb24obl90YWlscywgcHJfaGVhZHMsIG9ic19mbGlwcykgewogICAgY29pbl9mbGlwX3YyKG5fdGFpbHMsIHByX2hlYWRzLCBvYnNfZmxpcHMpICU+JQogICAgICBnZ3Bsb3QoYWVzKHggPSBmbGlwcywgeSA9IGZyZXEpKSArCiAgICAgIGdlb21fbGluZShhbHBoYSA9IC4yNSwgbmEucm0gPSBUUlVFKSArCiAgICAgIGdlb21fcG9pbnQoYWVzKGNvbG91ciA9IG91cl9vYiksIHNpemUgPSAzLCBuYS5ybSA9IFRSVUUpICsKICAgICAgc2NhbGVfY29sb3VyX21hbnVhbCgKICAgICAgICBndWlkZSA9ICJub25lIiwKICAgICAgICB2YWx1ZXMgPSBjKCJUUlVFIiA9ICJibGFjayIsICJGQUxTRSIgPSAiZ3JleSIpCiAgICAgICkgKwogICAgICBsYWJzKAogICAgICAgIHggPSBnbHVlOjpnbHVlKCJudW1iZXIgb2YgZmxpcHMgdW50aWwge25fdGFpbHN9IHRhaWxzIiksCiAgICAgICAgeSA9ICJyZWxhdGl2ZSBmcmVxdWVuY3kiLAogICAgICAgIHRpdGxlID0gZ2x1ZTo6Z2x1ZSgiUChoZWFkcykgPSB7cHJfaGVhZHN9IikKICAgICAgKSArCiAgICAgIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMiwgMTIsIDIpLCBsaW1pdHMgPSBjKDIsIDEyKSkgKwogICAgICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzID0gYygwLCAuODUpKSArCiAgICAgIHRoZW1lX21pbmltYWwoKSArCiAgICAgIE5VTEwKICB9CikKCgoocGF0Y2h3b3JrOjp3cmFwX3Bsb3RzKGNvaW5fZmxpcF92Ml9wbG90cywgbnJvdyA9IDIpICsKICBwbG90X2Fubm90YXRpb24odGFnX2xldmVscyA9ICJBIikpCmBgYAoKV2UgY2FuIHNlZSB0aGF0IHRoZXNlIHNhbXBsaW5nIGRpc3RyaWJ1dGlvbnMgbG9vayB2ZXJ5IGRpZmZlcmVudCB0byB0aGUKc2FtcGxpbmcgZGlzdHJpYnV0aW9ucyB0aGF0IHdlIGdlbmVyYXRlZCBhYm92ZS4gQnV0IHdoYXQgd2UncmUgaW50ZXJlc3RlZCBpbgphcmUganVzdCB0aGUgaGlnaGxpZ2h0ZWQgcG9pbnRzLCBiZWNhdXNlIHdlJ2xsIHVzZSB0aGVzZSB0byBnZW5lcmF0ZSBvdXIKbGlrZWxpaG9vZC4KCmBgYHtyfQojIHRyYW5zbGF0ZSBvdXIgb2JzZXJ2YXRpb24gaW50byB0aGUgcGFyYW1ldGVycyBuZWVkZWQgZm9yIHZlcnNpb24gMgojIGdlbmVyYXRlIHRoZSBkYXRhIGFuZCBvdXQgdGhlIHJlbGF0aXZlIGZyZXF1ZW5jeSBvZiBvdXIgc3BlY2lmaWMgb2JzZXJ2YXRpb24Kbl90YWlscyA8LSBudW1iZXJfb2ZfZmxpcHMgLSBudW1iZXJfb2ZfaGVhZHMKb2JzX2ZsaXBzIDwtIG51bWJlcl9vZl9mbGlwcwpsaWtlbGlob29kX3YyIDwtIG1hcF9kZihwcl9oZWFkc19yYW5nZSwgZnVuY3Rpb24oeCkgewogIHN1cHByZXNzV2FybmluZ3MoeyAjIHN1cHJlc3Mgd2FybmluZ3MgYWJvdXQgaW1wb3NzaWJsZSB2YWx1ZXMKICAgIGNvaW5fZmxpcF92MihuX3RhaWxzLCB4LCBvYnNfZmxpcHMpICU+JQogICAgICBmaWx0ZXIob3VyX29iID09IFRSVUUpICU+JQogICAgICBzZWxlY3QoZnJlcSkgJT4lCiAgICAgIG11dGF0ZShwcl9oZWFkcyA9IHgpICU+JQogICAgICBtdXRhdGUoZnJlcSA9IGlmZWxzZShpcy5uYShmcmVxKSwgMCwgZnJlcSkpCiAgfSkKfSkgIyByZXBsYWNlIE5hTiAoaW1wb3NzaWJsZSB2YWx1ZXMpIHdpdGggMCBmb3IgcGxvdHRpbmcKCiMgbm93IGFjdHVhbGx5IGRyYXcgdGhlIHBsb3QKCmxpa2VsaWhvb2RfdjIgJT4lCiAgZ2dwbG90KGFlcyh4ID0gcHJfaGVhZHMsIHkgPSBmcmVxKSkgKwogIGdlb21fcG9pbnQoKSArCiAgZ2VvbV9saW5lKCkgKwogIHRoZW1lX21pbmltYWwoMTIpICsKICBzY2FsZV94X2NvbnRpbnVvdXMobmFtZSA9ICJQKGhlYWRzKSIsIGJyZWFrcyA9IHNlcSgwLCAxLCAuMikpICsKICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzID0gYygwLCAuNCksIG5hbWUgPSAicmVsYXRpdmUgZnJlcXVlbmN5IikgKwogIGxhYnMoCiAgICB0aXRsZSA9IGdsdWU6OmdsdWUoCiAgICAgICJsaWtlbGlob29kIGZ1bmN0aW9uIGZvciB7bnVtYmVyX29mX2hlYWRzfSAiLAogICAgICAiaW4ge251bWJlcl9vZl9mbGlwc30iCiAgICApLAogICAgc3VidGl0bGUgPSBnbHVlOjpnbHVlKCJzdG9wcGluZyBhZnRlciB7bl90YWlsc30gdGFpbHMiKQogICkKYGBgCgpUaGUgbmV3IGxpa2VsaWhvb2QgbWlnaHQsIGF0IGZpcnN0IGdsYW5jZSwgbG9vayBkaWZmZXJlbnQgdG8gdGhlIG9uZSB3ZQpnZW5lcmF0ZWQgZWFybGllciwgYnV0IGl0J3MganVzdCBhIHNjYWxlZCB2ZXJzaW9uIG9mIHRoZSBlYXJsaWVyIGxpa2VsaWhvb2QuIFdlCmNhbiBjaGVjayB0aGlzIGp1c3QgYnkgcmVzY2FsaW5nIHRoZSB0d28gbGlrZWxpaG9vZHMgc28gdGhhdCB0aGV5IGJvdGggaGF2ZSBhCm1heCBvZiAxLgoKYGBge3J9CiMgbm93IGRyYXcgc2NhbGVkIHZlcnNpb25zIG9mIHRoZSBwbG90cwoKbGlrZWxpaG9vZF92MV9wbG90IDwtIGxpa2VsaWhvb2RfdjEgJT4lCiAgbXV0YXRlKGZyZXEgPSBmcmVxIC8gbWF4KGZyZXEpKSAlPiUKICBnZ3Bsb3QoYWVzKHggPSBwcl9oZWFkcywgeSA9IGZyZXEpKSArCiAgZ2VvbV9wb2ludCgpICsKICBnZW9tX2xpbmUoKSArCiAgdGhlbWVfbWluaW1hbCgxMikgKwogIHNjYWxlX3hfY29udGludW91cyhuYW1lID0gIlAoaGVhZHMpIiwgYnJlYWtzID0gc2VxKDAsIDEsIC4yKSkgKwogIHNjYWxlX3lfY29udGludW91cyhsaW1pdHMgPSBjKDAsIDEpLCBuYW1lID0gInJlbGF0aXZlIGZyZXF1ZW5jeSIpICsKICBsYWJzKAogICAgdGl0bGUgPSBnbHVlOjpnbHVlKAogICAgICAibGlrZWxpaG9vZCBmdW5jdGlvbiBmb3Ige251bWJlcl9vZl9oZWFkc30gIiwKICAgICAgImhlYWRzIGluIHtudW1iZXJfb2ZfZmxpcHN9IGZsaXBzIgogICAgKSwKICAgIHN1YnRpdGxlID0gZ2x1ZTo6Z2x1ZSgic3RvcHBpbmcgYWZ0ZXIge251bWJlcl9vZl9mbGlwc30iKQogICkKCmxpa2VsaWhvb2RfdjJfcGxvdCA8LSBsaWtlbGlob29kX3YyICU+JQogIG11dGF0ZShmcmVxID0gZnJlcSAvIG1heChmcmVxKSkgJT4lCiAgZ2dwbG90KGFlcyh4ID0gcHJfaGVhZHMsIHkgPSBmcmVxKSkgKwogIGdlb21fcG9pbnQoKSArCiAgZ2VvbV9saW5lKCkgKwogIHRoZW1lX21pbmltYWwoMTIpICsKICBzY2FsZV94X2NvbnRpbnVvdXMobmFtZSA9ICJQKGhlYWRzKSIsIGJyZWFrcyA9IHNlcSgwLCAxLCAuMikpICsKICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzID0gYygwLCAxKSwgbmFtZSA9ICJyZWxhdGl2ZSBmcmVxdWVuY3kiKSArCiAgbGFicygKICAgIHRpdGxlID0gZ2x1ZTo6Z2x1ZSgKICAgICAgImxpa2VsaWhvb2QgZnVuY3Rpb24gZm9yIHtudW1iZXJfb2ZfaGVhZHN9ICIsCiAgICAgICJpbiB7bnVtYmVyX29mX2ZsaXBzfSIKICAgICksCiAgICBzdWJ0aXRsZSA9IGdsdWU6OmdsdWUoInN0b3BwaW5nIGFmdGVyIHtuX3RhaWxzfSB0YWlscyIpCiAgKQoKCihsaWtlbGlob29kX3YxX3Bsb3QgLyBsaWtlbGlob29kX3YyX3Bsb3QgKwogIHBsb3RfYW5ub3RhdGlvbih0YWdfbGV2ZWxzID0gIkEiKSkKYGBgCgpOb3cgdGhhdCB0aGV5J3JlIGJlZW4gcmVzY2FsZWQgd2UgY2FuIHNlZSB0aGF0IHRoZXkncmUgdGhleSBzYW1lLiBOb3RlIHRoYXQKc2NhbGluZyBjaGFuZ2VzIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBvbiB0aGUgbGlrZWxpaG9vZCwgYnV0IGl0CmRvZXNuJ3QgY2hhbmdlIHRoZSAqcmVsYXRpdmUqIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cy4gV2hlbiB3ZSB3YW50IHRvIGtub3cKdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gbGlrZWxpaG9vZCB2YWx1ZXMgd2UgdGFrZSB0aGUgKnJhdGlvKiBvZiB0aGVzZSB0d28KdmFsdWVzLiBUaGUgcmF0aW8gZ2l2ZXMgdXMgdGhlICpyZWxhdGl2ZSBkaXN0YW5jZSogYmV0d2VlbiB0aGUgaGVpZ2h0cyBvbiB0aGUKbGlrZWxpaG9vZCBmdW5jdGlvbiwgYW5kIHRoZSAqcmVsYXRpdmUgZGlzdGFuY2UqIGRvZXNuJ3QgY2hhbmdlIHdpdGggc2NhbGluZy4KCk1vcmUgaW1wb3J0YW50bHksIGhvd2V2ZXIsIHdoYXQgdGhpcyBkZW1vbnN0cmF0ZXMgaXMgdGhhdCB3aGVuIHdlIGRvIGluZmVyZW5jZQp3aXRoICoqbGlrZWxpaG9vZHMqKiBpbnN0ZWFkIG9mICoqc2FtcGxpbmcgZGlzdHJpYnV0aW9ucyoqLCB0aGluZ3MgbGlrZQpzdG9wcGluZyBydWxlcywgZGF0YSB0aGF0IHdhc24ndCBjb2xsZWN0ZWQgYnV0IG1pZ2h0IGhhdmUgYmVlbiBjb2xsZWN0ZWQsIGFuZAphbGwgdGhvc2Ugb3RoZXIgc29ydHMgb2YgdGhpbmdzIHRoYXQgd2VyZSB0cmlja3kgYWJvdXQgKnAqLXZhbHVlcyBkb24ndCBjb21lIGluCnRvIHBsYXkuIFdlIG9ubHkgaGF2ZSB0aGUgd29ycnkgYWJvdXQgKip0aGUgZGF0YSB3ZSBhY3R1YWxseSBoYXZlKiosIGFuZCB0aGUKKipsaWtlbGlob29kKiogd2hpY2ggcmVsYXRlcyAqKnBhcmFtZXRlciB2YWx1ZXMqKiB0byAqKmRhdGEqKi4KCiMjIyBUaGUgbGlrZWxpaG9vZCByYXRpbwoKVGhlIGxpa2VsaWhvb2QgcmF0aW8gaXMgZ29pbmcgdG8gYmUgb3VyIG1lYXN1cmUgb2YgZXZpZGVuY2Ugb2YgaG93IG11Y2gKdGhlIGRhdGEgc3VwcG9ydHMgb25lIGh5cG90aGVzaXMgb3ZlciBhbm90aGVyLiBJZiB0aGUgbGlrZWxpaG9vZCBhdCBwb2ludApvbmUgKCRcdGhldGFfMSQpIGlzIGZvdXIgdGltZXMgdGhlIGxhcmdlciB0aGFuIHRoZSBsaWtlbGlob29kIGF0IHBvaW50IHR3bwooJFx0aGV0YV8yJCkgdGhlbiB0aGUgZGF0YSBhcmUgZm91ciB0aW1lcyBtb3JlIGxpa2VseSB1bmRlciB0aGUgaHlwb3RoZXNpcwokXHRoZXRhID0gXHRoZXRhXzEkIHRoYW4gdGhlIGh5cG90aGVzaXMgJFx0aGV0YSA9IFx0aGV0YV8yJC4gT3Igc2ltcGx5CnB1dCwgdGhlIGRhdGEgc3VwcG9ydHMgdGhlIGh5cG90aGVzaXMgJFx0aGV0YT1cdGhldGFfMSQgIG92ZXIKJFx0aGV0YT1cdGhldGFfMiQgYnV0IGEgZmFjdG9yIG9mIDQgdG8gMS4KCkxldCdzIGxvb2sgYXQgdGhlIGxpa2VsaWhvb2QgZm9yIG91ciBhY3R1YWwgZGF0YSBhbmQgb3VyIHR3byBoeXBvdGhlc2VzCmFib3V0IHRoZSBjb2luIGJpYXMuIEp1c3QgdG8gZHJpdmUgaG9tZSB0aGUgcG9pbnQgdGhhdCB0aGUgc2FtcGxpbmcgcnVsZQpkb2Vzbid0IG1hdHRlciwgSSdtIGdvaW5nIHRvIHdvcmsgb3V0IHRoZSBsaWtlbGlob29kIHJhdGlvIGZvciB0aGUKc2FtcGxpbmcgcnVsZSB3aGVyZSBJIGZsaXAgdGhlIGNvaW4gMTAgdGltZXMgYW5kIHRoZSBzYW1wbGluZyBydWxlIHdoZXJlCkkgZmxpcCB0aGUgY29pbiB1bnRpbCBJIGdldCAyIGhlYWRzIGFuZCBqdXN0IGhhcHBlbiB0byBmbGlwIGl0IDEwIHRpbWVzLgpXZSdsbCBzZWUgdGhhdCB0aGUgYWJzb2x1dGUgdmFsdWVzIG9mIHRoZSBsaWtlbGlob29kcyBjaGFuZ2UgKGFzIHdlIHNhdyBpbgp0aGUgcGxvdHMgYWJvdmUpLCBidXQgdGhhdCB0aGUgbGlrZWxpaG9vZCByYXRpbyBiZXR3ZWVuIHRoZSBoeXBvdGhlc2VzCmRvbid0IGNoYW5nZS4gCgpUbyBtYWtlIHN1cmUgdGhhdCB0aGUgbnVtYmVycyB3b3JrIG91dCBjb3JyZWN0bHksIEkgd29uJ3QgdXNlIHNpbXVsYXRpb25zCnRvIGdlbmVyYXRlIHRoZSBsaWtlbGlob29kcy4gSW5zdGVhZCBJJ2xsIGp1c3QgZ2VuZXJhdGUgZWFjaCBsaWtlbGlob29kCndpdGggdGhlIHJlbGV2YW50IGZvcm11bGEuIAoKYGBge3J9CiMgZGVmaW5lIGEgZnVuY3Rpb24gZm9yIG5pY2UgcHJpbnRpbmcKcHJpbnRfbGlrZWxpaG9vZCA8LSBmdW5jdGlvbihoMSwgaDIsIGxpa2VsaWhvb2RfMSwgbGlrZWxpaG9vZF8yKSB7CiAgbGlrZWxpaG9vZF8xX3RleHQgPC0gZ2x1ZTo6Z2x1ZSgKICAgICJUaGUgbGlrZWxpaG9vZCBmb3IgJFxcbWF0aGNhbHt7SH19XzEkIChQKGhlYWRzKSA9IHtoMX0pICIsCiAgICAiaXMge3JvdW5kKGxpa2VsaWhvb2RfMSwyKX0iCiAgKQogIGxpa2VsaWhvb2RfMl90ZXh0IDwtIGdsdWU6OmdsdWUoCiAgICAiVGhlIGxpa2VsaWhvb2QgZm9yICRcXG1hdGhjYWx7e0h9fV8yJCAoUChoZWFkcykgPSB7aDJ9KSAiLAogICAgImlzIHtyb3VuZChsaWtlbGlob29kXzIsMil9IgogICkKICByYXRpb190ZXh0IDwtIGdsdWU6OmdsdWUoCiAgICAiVGhlIGxpa2VsaWhvb2QgcmF0aW8gaXMge3JvdW5kKGxpa2VsaWhvb2RfMSAvIGxpa2VsaWhvb2RfMiwgMil9IgogICkKICBpbnRlcnByZXRhdGlvbiA8LSBnbHVlOjpnbHVlKAogICAgIlRoZSBkYXRhIGFyZSB7cm91bmQobGlrZWxpaG9vZF8xIC8gbGlrZWxpaG9vZF8yLCAyKX0gdGltZXMgbW9yZSAiLAogICAgInByb2JhYmxlIHVuZGVyICRcXG1hdGhjYWx7e0h9fV8xJCB0aGFuICRcXG1hdGhjYWx7e0h9fV8yJCIKICApCiAgcGFzdGUoYyhsaWtlbGlob29kXzFfdGV4dCwgbGlrZWxpaG9vZF8yX3RleHQsIHJhdGlvX3RleHQsIGludGVycHJldGF0aW9uKSwKICAgIGNvbGxhcHNlID0gIlxuXG4iCiAgKQp9CmBgYAoKRmlyc3QsIGZvciB2ZXJzaW9uIDEsIHdoZXJlIEkgZmxpcCB0aGUgY29pbiAxMCB0aW1lcyAoKipiaW5vbWlhbCoqCnNhbXBsaW5nIHJ1bGUpLgoKYGBge3J9CiMgc2V0IG91dCBvYnNlcnZhdGlvbgpuIDwtIDEwICMgbnVtYmVyIG9mIGZsaXBzCmggPC0gOCAjIG51bWJlciBvZiBoZWFkcwp0IDwtIG4gLSBoICMgbnVtYmVyIG9mIHRhaWxzCgojIHNldCBvdXIgdHdvIGh5cG90aGVzZXMKaDEgPC0gMC42ICMgdGhlIHByb2JhYmlsaXR5IG9mIGdldHRpbmcgaGVhZHMgaXMgMC42CmgyIDwtIDAuOCAjIHRoZSBwcm9iYWJpbGl0eSBvZiBnZXR0aW5nIGhlYWRzIGlzIDAuOAoKIyB3b3JrIG91dCB0aGUgbGlrZWxpaG9vZCB2YWx1ZXMKbGlrZWxpaG9vZF8xIDwtIGRiaW5vbShoLCBuLCBoMSkKbGlrZWxpaG9vZF8yIDwtIGRiaW5vbShoLCBuLCBoMikKCnByaW50X2xpa2VsaWhvb2QoaDEsIGgyLCBsaWtlbGlob29kXzEsIGxpa2VsaWhvb2RfMikgJT4lIGRpc3BsYXlfbWFya2Rvd24oKQpgYGAKClNlY29uZCwgZm9yIHZlcnNpb24gMiwgd2hlcmUgSSBmbGlwIHRoZSBjb2luIHVudGlsIEkgZ2V0IDIgaGVhcnMKKCoqbmVnYXRpdmUtYmlub21pYWwqKiBzYW1wbGluZyBydWxlKS4KCmBgYHtyfQojIFNldCBvdXIgb2JzZXJ2YXRpb24KbiA8LSAxMCAjIG51bWJlciBvZiBmbGlwcwpoIDwtIDggIyBudW1iZXIgb2YgaGVhZHMKdCA8LSBuIC0gaCAjIG51bWJlciBvZiB0YWlscwoKIyBzZXQgb3VyIHR3byBoeXBvdGhlc2VzCmgxIDwtIDAuNiAjIHRoZSBwcm9iYWJpbGl0eSBvZiBnZXR0aW5nIGhlYWRzIGlzIDAuNgpoMiA8LSAwLjggIyB0aGUgcHJvYmFiaWxpdHkgb2YgZ2V0dGluZyBoZWFkcyBpcyAwLjgKCiMgd29yayBvdXQgdGhlIGxpa2VsaWhvb2QgdmFsdWVzCmxpa2VsaWhvb2RfMSA8LSBkbmJpbm9tKHQsIGgsIGgxKQpsaWtlbGlob29kXzIgPC0gZG5iaW5vbSh0LCBoLCBoMikKCnByaW50X2xpa2VsaWhvb2QoaDEsIGgyLCBsaWtlbGlob29kXzEsIGxpa2VsaWhvb2RfMikgJT4lIGRpc3BsYXlfbWFya2Rvd24oKQpgYGAKCiMjIyBBIG5vdGUgYWJvdXQgbGlrZWxpaG9vZCBmdW5jdGlvbnMgYW5kIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbnMKCk9uZSBjb21tb24gbWlzY29uY2VwdGlvbiBhYm91dCBsaWtlbGlob29kIGZ1bmN0aW9ucyBpcyB0aGF0IHRoZXkncmUKcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9ucy4gVGhpcyBtaXNjb25jZXB0aW9uIGNhbiBjb21lIGluIGEgZmV3IGRpZmZlcmVudApmb3Jtcywgc28gaXQncyB3b3J0aCBqdXN0IHN0cmVzc2luZyBhZ2FpbiB3aGF0IGEgbGlrZWxpaG9vZCBmdW5jdGlvbiBpcy4gCgpGaXJzdCwgd2UgY2FuIHRlbGwgYSBsaWtlbGlob29kIGZ1bmN0aW9uIGlzbid0IGEgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uLApiZWNhdXNlIGZvciBhIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbiB0aGUgYXJlYSB1bmRlciB0aGUgY3VydmUgd291bGQgaGF2ZQp0byBzdW0gdG8gMS4gRWFjaCBwb2ludCBvbiBhIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbiBnaXZlcyB0aGUgcHJvYmFiaWxpdHkKb2YgYSBzcGVjaWZpYyBldmVudC4gVGhlIHdob2xlIGN1cnZlIGRlc2NyaWJlcyBhbGwgdGhlIGV2ZW50cyB0aGF0IGNvdWxkCmhhcHBlbiwgYW5kIHRoZSBhcmVhIHVuZGVyIHRoZSBjdXJ2ZSBnaXZlcyB0aGUgcHJvYmFiaWxpdHkgdGhhdCBvbmUgb2YgdGhlCnBvc3NpYmxlIGV2ZW50cyBoYXBwZW5zLiBUaGF0IGlzLCBpdCBpcyB0aGUgc3VtIG9mIGFsbCB0aGUgaW5kaXZpZHVhbApwcm9iYWJpbGl0aWVzIG9mIHRoZSBkaWZmZXJlbnQgZXZlbnRzLgoKSW4gdGhlIHBsb3QgYmVsb3csIHdlIGNhbiBzZWUgdGhlIGxpa2VsaWhvb2QgZnVuY3Rpb25zIGZvciBkaWZmZXJlbnQKZXZlbnRzIChkaWZmZXJlbnQgbnVtYmVycyBvZiBoZWFkcyBpbiAxMCBmbGlwcykuIFdlIGNhbiBzZWUgdGhhdCB0aGUgYXJlYQp1bmRlciB0aGUgY3VydmUgdmFyaWVzIGluIGVhY2ggY2FzZS4gSWYgdGhlc2Ugd2VyZSBwcm9iYWJpbGl0eQpkaXN0cmlidXRpb25zIHRoZW4gdGhlIGFyZWEgdW5kZXIgdGhlIGN1cnZlIGluIGVhY2ggY2FzZSB3b3VsZCBiZSAxLgoKYGBge3J9CiMgcGxvdCBzb21lIGxpa2VsaWhvb2QgZnVuY3Rpb25zCgpzY2VuYXJpb3MgPC0gbGlzdCgKICBwMSA9IGxpc3QoaGVhZHMgPSAwLCBmbGlwcyA9IDEwKSwKICBwMiA9IGxpc3QoaGVhZHMgPSAxLCBmbGlwcyA9IDIpLAogIHAzID0gbGlzdChoZWFkcyA9IDAsIGZsaXBzID0gMiksCiAgcDQgPSBsaXN0KGhlYWRzID0gMiwgZmxpcHMgPSA1KQopCgpwbG90cyA8LSBtYXAoc2NlbmFyaW9zLCBmdW5jdGlvbih4KSB7CiAgZGF0YV9tb2RlbCA8LSBiYXllc3BsYXk6Omxpa2VsaWhvb2QoImJpbm9taWFsIiwKICAgIHN1Y2Nlc3NlcyA9IHgkaGVhZHMsCiAgICB0cmlhbHMgPSB4JGZsaXBzCiAgKQogIGF1YyA8LSBpbnRlZ3JhdGUoZGF0YV9tb2RlbCRsaWtlbGlob29kX2Z1bmN0aW9uLCAwLCAxKSR2YWx1ZQogIHBsb3QoZGF0YV9tb2RlbCkgKwogICAgbGFicygKICAgICAgdGl0bGUgPSBnbHVlOjpnbHVlKCJsaWtlbGlob29kIGZvciB7eCRoZWFkc30gaGVhZHMgaW4ge3gkZmxpcHN9IGZsaXBzIiksCiAgICAgIHN1YnRpdGxlID0gZ2x1ZTo6Z2x1ZSgiYXJlYSB1bmRlciBjdXJ2ZSBpcyB7cm91bmQoYXVjLDMpfSIpCiAgICApICsKICAgIHRoZW1lX21pbmltYWwoMTIpICsKICAgIE5VTEwKfSkKCnBhdGNod29yazo6d3JhcF9wbG90cyhwbG90cykKYGBgCgpUaGlzIG1pc2NvbmNlcHRpb24gYWJvdXQgbGlrZWxpaG9vZCBmdW5jdGlvbnMgYmVpbmcgcHJvYmFiaWxpdHkKZGlzdHJpYnV0aW9uIG9mdGVuIHRha2VzIHRoZSBmb3JtIG9mIHRoaW5raW5nIHRoYXQgdGhlIGxpa2VsaWhvb2QgZnVuY3Rpb24KdGVsbHMgdXNlIHRoZSBwcm9iYWJpbGl0eSBvZiB0aGUgcGFyYW1ldGVyIGJlaW5nIGEgc3BlY2lmaWMgdmFsdWUuIFRoYXQKaXMsIGl0IHRlbGxzIHVzIHRoYXQgdGhlcmUncyBhIGhpZ2hlciBwcm9iYWJpbGl0eSB0aGF0ICRcdGhldGE9XHRoZXRhXzEkCnRoYW4gJFx0aGV0YT1cdGhldGFfMiQsIGdpdmVuIG91ciBkYXRhLiBQdXQgYW5vdGhlciB3YXksIHRoaXMKbWlzY29uY2VwdGlvbiBzdGF0ZXMgdGhhdCB0aGUgbGlrZWxpaG9vZCB0ZWxscyB1cyAkcChcdGhldGF8eSkkLiBUaGlzCnF1YW50aXR5LCBob3dldmVyLCBpcyB3aGF0J3Mga25vdyBhcyB0aGUgKipwb3N0ZXJpb3IgcHJvYmFiaWxpdHkqKi4KUmF0aGVyLCB0aGUgbGlrZWxpaG9vZCB0ZWxscyB1cyB0aGUgcmVzZXJ2ZSBjb25kaXRpb25hbCwgb3IgJHAoeXxcdGhldGEpJC4KVGhhdCBpcywgaXQgdGVsbHMgdXNlIHRoZSBwcm9iYWJpbGl0eSBvZiBvYnRhaW5pbmcgb3VyIGRhdGEgZ2l2ZW4KZGlmZmVyZW50IHZhbHVlcyBvZiB0aGUgcGFyYW1ldGVyLgoKVG8gZW1waGFzaXNlIHRoYXQgdGhlIGxpa2VsaWhvb2QgaXMgbm90IGEgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIGl0IGlzCm9mdGVuIGRlbm90ZWQgJFxtYXRoY2Fse0x9KFx0aGV0YXx5KSQuCgojIyBUZXN0aW5nIG1vcmUgY29tcGxleCBoeXBvdGhlc2VzCgpTbyB3ZSd2ZSBzZWVuIHRoYXQgY29tcGFyaW5nIGxpa2VsaWhvb2RzIChieSB0YWtpbmcgdGhlaXIgcmF0aW8pIGNhbiB0ZWxsCnVzIHdoaWNoIGh5cG90aGVzaXMgaXMgYmV0dGVyIHN1cHBvcnRlZCBieSB0aGUgZGF0YS4gSG93ZXZlciwgdGhlcmUncwphIGNvdXBsZSBvZiBwcm9ibGVtcyB3aXRoIHdoYXQgd2UndmUgZG9uZSB1cCB1bnRpbCBub3cuIEZpcnN0LCBob3cgZG8gd2UKa25vdyBleHBsaWNpdGx5IHNldCBhIHRocmVzaG9sZCBmb3Igd2hlbiB3ZSB3b3VsZCBzdGFydCBkaWdnaW5nIGZvcgp0cmVhc3VyZS4gSXMgdGhlcmUgYWxzbyBhIHRocmVzaG9sZCBmb3IgbGlrZWxpaG9vZCByYXRpb3M/IFRvIGFuc3dlciB0aGlzCnF1ZXN0aW9uLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHRha2UgaW50byBhY2NvdW50IGEgbG90IG9mIGFkZGl0aW9uYWwKZmFjdG9ycy4gQW5kIHRoZSBhbnN3ZXIgdG8gdGhpcyBxdWVzdGlvbiBpcyBwcm9iYWJseSBnb2luZyB0byBiZQpjb250ZXh0LWRlcGVuZGVudC4gRm9yIGV4YW1wbGUsIGlmIHdlJ3JlIHBsYWNpbmcgYmV0cyBvbiBoeXBvdGhlc2VzLCB3ZSdyZQpwcm9iYWJseSBnb2luZyB0byB3YW50IHRvIHRha2UgaW50byBhY2NvdW50IHRoZSByZWxhdGl2ZSBwYXktb2Zmcy4gSWYKd2UncmUgdXNpbmcgZXZpZGVuY2UgdG8gZGVjaWRlIHNvbWVib2R5J3MgZ3VpbHQgaW4gYSBjb3VydCBjYXNlLCB3ZSdyZQpwcm9iYWJseSBnb2luZyB0byB3YW50IHRvIHRha2UgaW50byBhY2NvdW50IHRoaW5ncyBsaWtlICJyZWFzb25hYmxlCmRvdWJ0Ii4gSW4gc2hvcnQsIHRoZXJlJ3Mgbm90IGEgc3RyYWlnaHQgZm9yd2FyZCBhbnN3ZXIgdG8gdGhpcyBxdWVzdGlvbiwKc28gd2UnbGwgc2V0IGl0IGFzaWRlIGZvciBub3cuIEluc3RlYWQsIHdlJ2xsIHR1cm4gdG8gdGhlIHNlY29uZCBwcm9ibGVtLgoKVGhlIHNlY29uZCBwcm9ibGVtIHdpdGggd2hhdCB3ZSd2ZSBkb25lIHVwIHVudGlsIG5vdyBpcyB0aGF0IHdlJ3ZlIGp1c3QKYmVlbiBjb21wYXJpbmcgc2luZ2xlIHBvaW50IGh5cG90aGVzaXMuIFdlIGNhbiBjYW4gc2F5LCBmb3IgZXhhbXBsZSwKd2hldGhlciB0aGUgZGF0YSBzdXBwb3J0cyBQKGhlYWRzKSA9IDAuNSBvdmVyIHRoZSBoeXBvdGhlc2lzIFAoaGVhZHMpCj0gMC44LCBhbmQgd2UgY2FuIHF1YW50aWZ5IHRoaXMgbGV2ZWwgb2Ygc3VwcG9ydC4gQnV0IHVzdWFsbHksIHdlIGFyZSBub3QKY29tcGFyaW5nIHR3byBzaW1wbGUgaHlwb3RoZXNlcyBsaWtlIHRoaXMuIE91ciBoeXBvdGhlc2VzIHRha2UgYSBtb3JlCmNvbXBsZXggZm9ybSBsaWtlOiAiSXMgdGhlIGNvaW4gZmFpcj8iCgpIb3cgbWlnaHQgd2UgZ28gYWJvdXQgYW5zd2VyaW5nIHRoaXMgcXVlc3Rpb24/CgpUbyBjb21lIHVwIHdpdGggYSB3YXkgdG8gYW5zd2VyIHRoaXMgcXVlc3Rpb24gd2UncmUgZ29pbmcgdG8gdGhpbmsgYWJvdXQKaHlwb3RoZXNlcyBpbiB0ZXJtcyBvZiAqKnByZWRpY3Rpb25zKiouIE91ciBmaXJzdCBoeXBvdGhlc2lzLAokXG1hdGhjYWx7SH1fMCQsIHdpbGwgYmUgdGhhdCB0aGUgY29pbiBpcyBmYWlyLiBBbmQgd2UnbGwgc2F5IGEgZmFpciBjb2luCmhhcyBhIGJpYXMgb2YgMC41LiBXaGF0IGRvIHdlIHByZWRpY3Qgd2lsbCBoYXBwZW4gaWYgd2UgZmxpcCB0aGUgY29pbnMgMTAKdGltZXM/IE1vc3Qgb2YgdGhlIHRpbWUgaXQnbGwgc2hvdyBhcm91bmQgYWJvdXQgNSBoZWFkcyBhbmQgNSB0YWlscywgYnV0Cml0IHdpbGwgYWxzbyByYXJlbHkgc2hvdyAxIGhlYWQgYW5kIDkgaGVhZHMgZXRjLiBJZiB3ZSBwbG90dGVkIGl0LCBpdAp3b3VsZCBqdXN0IGJlIG91ciBzYW1wbGluZyBkaXN0cmlidXRpb24gZnJvbSBiZWZvcmUuIAoKRm9yICRcbWF0aGNhbHtIfV8xJCwgdGhhdCB0aGUgY29pbiBpc24ndCBmYWlyLCB3aGF0IGRvIHdlIHByZWRpY3Qgd2lsbApoYXBwZW4gaWYgd2UgZmxpcHBlZCBpdCAxMCB0aW1lcz8gQmVmb3JlIHdlIGNhbiB3b3JrIHRoaXMgb3V0IHdlIG5lZWQgdG8KdGhpbmsgYSBsaXR0bGUgYml0IGFib3V0IHdoYXQgaXQgbWVhbnMgZm9yIGEgY29pbiBub3QgdG8gYmUgZmFpci4gRm9yIG5vdywKbGV0J3Mgc2F5IHRoYXQgaXQgbWVhbnMgdGhhdCBpdCBjYW4gaGF2ZSBzb21lIGJpYXMgYmV0d2VlbiAwIGFuZCAxLCBidXQKdGhhdCB3ZSBkb24ndCBrbm93IHdoYXQgaXQgaXMuIEZvciBvdXIgZmFpciBjb2luLCBpZiB3ZSBjb2xsZWN0ZWQgYSB2ZXJ5CmxhcmdlIG51bWJlciBvZiBzYW1wbGVzIHRoZSBtb3N0IGNvbW1vbiBvdXRjb21lIHdvdWxkIGJlIDUgaGVhZHMgYW5kCjUgdGFpbHMsIGJ1dCB3b3VsZCBiZSB0aGUgbW9zdCBjb21tb24gb3V0Y29tZSB3aXRoIG91ciB1bmZhaXIgY29pbj8gV291bGQKaXQgYmUgNSBoZWFkcyBhbmQgNSB0YWlscz8gV291bGQgaXQgYmUgMCBoZWFkcz8gMSBoZWFkPyA5IGhlYWRzPyBEbyB3ZQpoYXZlIGFueSBncm91bmRzIGZvciAqKnByZWRpY3RpbmcqKiB0aGF0IG9uZSBvdXRjb21lIHdvdWxkIGJlIG1vcmUgY29tbW9uCnRoYW4gYW5vdGhlciBvdXRjb21lPyBXZSBhcmd1YWJseSBkbyBub3QuIElmIHNvLCB0aGVuIGlmIEkgYXNrZWQgd2hpY2ggb2YKdGhlIDExIHBvc3NpYmxlIG91dGNvbWVzIChmcm9tIGEgc2FtcGxlIG9mIDEwIGNvaW4gZmxpcHMpIGlzIG1vcmUgcHJvYmFibGUKdGhhbiB0aGUgb3RoZXJzIHlvdSBtaWdodCBzYXkgbm9uZS4gSWYgbm9uZSBvZiB0aGUgb3V0Y29tZXMgYXJlIG1vcmUKcHJvYmFibGUgdGhhbiBhbnkgb2YgdGhlIG90aGVyIG91dGNvbWVzLCBhbmQgZ2l2ZW4gdGhhdCB0aGVyZSdzIDExCnBvc3NpYmxlIG91dGNvbWVzLCB0aGVuIG91ciBwcmVkaWN0aW9uIG11c3QgYmUgdGhhdCBlYWNoIG91dGNvbWUgaGFzCmEgMSBpbiAxMSBjaGFuY2Ugb2Ygb2NjdXJyaW5nLgoKQmVsb3csIHdlIGNhbiBzZWUgcGxvdHMgb2Ygb3VyIHR3byBwcmVkaWN0aW9ucy4gRmlyc3QsIHdoYXQgd2Ugd291bGQKcHJlZGljdCBpZiB3ZSBrbmV3IHRoZSBjb2luIGJpYXMgd2FzIDAuNSwgYW5kIHNlY29uZCB3aGF0IHdlIHdvdWxkIHByZWRpY3QKaWYgd2UgaGFkIG5vIHJlYXNvbiBmb3IgZmF2b3VyaW5nIG9uZSBvdXRjb21lIG92ZXIgYW5vdGhlci4gCgpgYGB7cn0KCgojIHRoZSB0d28gcHJlZGljdGlvbnMKCnByZWRpY3Rpb25zMSA8LSB0aWJibGU6OnRpYmJsZSgKICB4ID0gc2VxKDAsIDEwLCAxKSwKICB5ID0gZGJpbm9tKHgsIDEwLCAwLjUpCikgJT4lCiAgZ2dwbG90KGRhdGEgPSAuLCBhZXMoeCA9IHgsIHkgPSB5KSkgKwogIGdlb21fcG9pbnQoKSArCiAgZ2VvbV9saW5lKCkgKwogIGxhYnMoeCA9ICJudW1iZXIgb2YgaGVhZHMiLCB5ID0gInByb2JhYmlsaXR5IikgKwogIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgMTAsIDEpKSArCiAgdGhlbWVfbWluaW1hbCgxNCkKCgpwcmVkaWN0aW9uczIgPC0gdGliYmxlOjp0aWJibGUoCiAgeCA9IHNlcSgwLCAxMCwgMSksCiAgeSA9IDEgLyBsZW5ndGgoeCkKKSAlPiUKICBnZ3Bsb3QoZGF0YSA9IC4sIGFlcyh4ID0geCwgeSA9IHkpKSArCiAgZ2VvbV9wb2ludCgpICsKICBnZW9tX2xpbmUoKSArCiAgbGFicyh4ID0gIm51bWJlciBvZiBoZWFkcyIsIHkgPSAicHJvYmFiaWxpdHkiKSArCiAgc2NhbGVfeF9jb250aW51b3VzKGJyZWFrcyA9IHNlcSgwLCAxMCwgMSkpICsKICB0aGVtZV9taW5pbWFsKDE0KQoKKHByZWRpY3Rpb25zMSAgLyBwcmVkaWN0aW9uczIpICsKICBwbG90X2Fubm90YXRpb24odGFnX2xldmVscyA9ICJBIikKCmBgYAoKTm93IHRoYXQgd2UgaGF2ZSBhIGludHVpdGlvbiBmb3IgaHlwb3RoZXNlcyBpbiB0ZXJtcyBvZiBwcmVkaWN0aW9ucywgbGV0CnVzZSBmb3JtYWxpc2UgaXQgYSBiaXQuIEFuZCBpbnN0ZWFkIG9mIHRoaW5raW5nIGFib3V0IGFsbCB0aGUgZGF0YSB0aGF0Cm1pZ2h0IGJlIHByb2R1Y2VkIGxldCdzIGp1c3QgdHJ5IGFuZCB0aGluayBhYm91dCB0aGUgcHJvYmFiaWxpdHkgb2YKb2J0YWluaW5nIG91ciBkYXRhIG9mIDggaGVhZHMgaW4gMTAgZmxpcHMuIElmIGEgY29pbiBpcyBmYWlyLCB0aGVuIGluIDEwCmNvaW4gZmxpcHMgdGhlcmUgYXJlIGV4YWN0bHkgJDJeezEwfSQgcG9zc2libGUgc2VxdWVuY2VzIGFuZCA0NSBvZiB0aGVzZQpzZXF1ZW5jZXMgd291bGQgZ2l2ZSA4IGhlYWRzIGluIDEwIGZsaXBzLiBUaGVyZWZvcmUsIGlmIHRoZSBjb2luIGlzIGZhaXIsCnRoZW4gdGhlIHByb2JhYmlsaXR5IG9mIG9idGFpbmluZyBvdXIgcmVzdWx0IG9mIDggaGVhZHMgaW4gMTAgZmxpcHMgaW4KJFxmcmFjezQ1fXsxMDI0fSQsIG9yIGFib3V0IDAuMDQ0LiBJJ3ZlIHdvcmtlZCB0aGlzIG91dCBleGFjdGx5LCBidXQgd2UnZApnZXQgdGhlIHNhbWUgdmFsdWUgaWYgd2UgcmFuIHRoZSBzaW11bGF0aW9ucywgb3IgaWYgd2UganVzdCBsb29rZWQgYXQgdGhlCmxpa2VsaWhvb2QgZnVuY3Rpb24gYXQgJFx0aGV0YT0wLjUkLiBUaGlzIGlzIGFmdGVyIGFsbCwgd2hhdCB0aGUKbGlrZWxpaG9vZCBmdW5jdGlvbiB0ZWxscyB1c2U6IHRoZSBwcm9iYWJpbGl0eSBvZiBvYnRhaW5pbmcgb3VyIGRhdGEgZm9yCmEgZ2l2ZW4gdmFsdWUgb2YgdGhlIHBhcmFtZXRlci4gCgpOb3cgb24gdG8gdGhlIG1vcmUgY29tcGxleCBleGFtcGxlIHdoZXJlIHRoZSBjb2luIGJpYXMgaXMgc29tZSB1bmtub3duCnZhbHVlIGJldHdlZW4gMCBhbmQgMS4gV2hhdCBub3cgaXMgdGhlIHByb2JhYmlsaXR5IG9mIG9idGFpbmluZyBvdXIgZGF0YS4KT25lIGdvb2Qgc3RyYXRlZ3kgb2YgZGVhbGluZyB3aXRoIHVua25vd25zIGlzIHRvIGF2ZXJhZ2UgYWNyb3NzIHRoZQpwb3NzaWJpbGl0aWVzLiBGb3IgZXhhbXBsZSwgaWYgSSBkaWRuJ3Qga25vdyB3aGF0IHRoZSBjb2luIGJpYXMgd2FzLCBidXQKSSBrbmV3IGl0IGNvdWxkIGVpdGhlciBiZSAwLjUgb3IgMC42LCB0aGVuIHRvIHdvcmsgb3V0IHRoZSBwcm9iYWJpbGl0eSBvZgpvYnRhaW5pbmcgb3VyIGN1cnJlbnQgZGF0YSBJIGNvdWxkIGp1c3Qgd29yayBvdXQgdGhlIHByb2JhYmlsaXR5IG9mCm9idGFpbmluZyBvdXIgY3VycmVudCBkYXRhIGlmIHRoZSBiaWFzIHdhcyAwLjUgKH4wLjA0NCksIGFuZCB0aGVuIHdvcmsgb3V0CnRoZSBwcm9iYWJpbGl0eSBvZiBvYnRhaW5pbmcgb3VyIGN1cnJlbnQgZGF0YSBpZiAwLjYgKH4wLjEyMSksIGFuZCB0aGVuCmp1c3QgYXZlcmFnZSB0aGVtIHRvZ2V0aGVyICh+MC4wODIpLiBBZ2FpbiwgSSBqdXN0IHRha2UgdGhlIHZhbHVlcyBmcm9tCnRoZSBsaWtlbGlob29kIGZ1bmN0aW9uIGF0ICRcdGhldGE9MC41JCBhbmQgJFx0aGV0YT0wLjYkIGFuZCBhdmVhZ2UgdGhlbQp0b2dldGhlci4gCgpCdXQgaW4gb3VyIGV4YW1wbGUgaXQncyBub3QganVzdCB0aGUgY2FzZSB0aGF0IHRoZSBiaWFzIG9mIHRoZSBjb2luIGNvdWxkCmJlIDAuNSBvciAwLjYuIEZvciBvdXIgc2Vjb25kIGh5cG90aGVzaXMgd2Ugc2FpZCBpdCBjb3VsZCBiZSBhbnkgdmFsdWUKYmV0d2VlbiAwIGFuZCAxLiBUaGF0IGlzLCBoeXBvdGhlc2lzIGlzIHRoZSBzZXQgJFxUaGV0YQo9IFx7XHRoZXRhXzEsXHRoZXRhXzIsLi4uLFx0aGV0YV9uXH0kIHdoZXJlIGVhY2ggJFx0aGV0YV8xJCB0byAkXHRoZXRhX24kCmlzIHNvbWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBUbyBrZWVwIHRoaW5ncyBzaW1wbGUgZm9yIG5vdywgd2UnbGwgc2F5CnRoYXQgJFxUaGV0YSA9XHtcdGhldGFfMT1cZnJhY3swfXsxMH0sClx0aGV0YV8yPVxmcmFjezF9ezEwfSwuLi4sXHRoZXRhX3sxMX09XGZyYWN7MTB9ezEwfVx9JC4gQW4gYXZlcmFnZSBpcyBqdXN0CmEgc3VtIHdoZXJlIGVhY2ggdmFsdWUgaXMgbXVsdGlwbGllZCBieSAkXGZyYWN7MX17bn0kLCB0aGVyZWZvcmUsIHRoZQphdmVyYWdlIGFjcm9zcyB0aGVzZSAxMSB2YWx1ZXMgd291bGQgYmU6CgokJFxzdW1fe2k9MX1eezExfVxtYXRoY2Fse0x9KFx0aGV0YV9pfFxtYXRoYmZ7eX0pXGNkb3R7fVxmcmFjezF9ezExfSQkCgpUaGlzIGdpdmVzIGEgdmFsdWUgb2YgYXBwcm94aW1hdGVseSAkXGZyYWN7MX17MTJ9JCwgd2hpY2ggaXMgcHJldHR5IGNsb3NlCnRvIHRoZSB2YWx1ZSBvZiAkXGZyYWN7MX17MTF9JCB3ZSB3b3JrZWQgb3V0IGVhcmxpZXIuIFdoeSBpcyBpdCBub3QgdGhlCnNhbWU/IFdlbGwsIGVhcmxpZXIsIHdlIHNhaWQgaXQgY291bGQgYmUgKiphbnkqKiB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuCldlJ3JlIG9ubHkgbG9va2luZyBhdCAxMSB2YWx1ZXMuIExldCdzIGluc3RlYWQgbG9vayBhdCAxMDEgdmFsdWVzIGJldHdlZW4KMCBhbmQgMS4gTm93ICRcVGhldGEgPSBce1x0aGV0YV8xPVxmcmFjezB9ezEwMH0sClx0aGV0YV8yPVxmcmFjezF9ezEwMH0sLi4uLFx0aGV0YV97MTAxfT1cZnJhY3sxMDB9ezEwMH1cfSQuIE5vdyB3ZSBnZXQKYSB2YWx1ZSB0aGF0J3MgZXZlbiBjbG9zZXIgdG8gJFxmcmFjezF9ezExfSQuIFRvIGdldCB0byBleGFjdGx5CiRcZnJhY3sxfXsxMX0kLCBob3dldmVyLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIGxvb2sgYXQgZXZlbiBtb3JlIHBvaW50cy4KSW5zdGVhZCBvZiBzcGFjaW5nIHRoZSBwb2ludHMgb3V0IGJ5ICRcZnJhY3sxfXsxMH0kIG9yICRcZnJhY3sxfXsxMDB9JCwKd2UncmUgZ29pbmcgdG8gbmVlZCBpbmZpbml0ZXNpbWFsbHkgc21hbGwgc3BhY2luZy4gVGhhdCdzIG1lYW5zIHdlIGp1c3QKc3dpdGNoIG91dCB0aGUgc3VtIGZvciBhbiBpbnRlZ3JhbCwgYnV0IHRoZSBsb2dpYyBpcyB0aGUgc2FtZS4gV2UncmUgc3RpbGwKanVzdCB0YWtpbmcgYW4gYXZlcmFnZS4KCiQkXGludF97XHRoZXRhXGluXFRoZXRhfVxtYXRoY2Fse0x9KFx0aGV0YXxcbWF0aGJme3l9KWQoXHRoZXRhKSQkCgpOb3cgdGhhdCB3ZSdyZSB0YWtpbmcgYW4gaW50ZWdyYWwsIHdlIGdldCBleGFjdGx5ICRcZnJhY3sxfXsxMX0kLgoKTm93IHRoYXQgd2UgaGF2ZSB0aGVzZSB0d28gdmFsdWVzOiBGaXJzdCwgJFxmcmFjezQ1fXsxMDI0fSQsIHdoaWNoIGdpdmVzIHRoZQpwcm9iYWJpbGl0eSBvZiBvYnRhaW5pbmcgOCBoZWFkcyBpbiAxMCBmbGlwcyBpZiAkXHRoZXRhPTAuNSQsIGFuZCBzZWNvbmQsCiRcZnJhY3sxfXsxMX0kLCB3aGljaCB0aGUgcHJvYmFiaWxpdHkgb2Ygb2J0YWluaW5nIDggaGVhZCBpbiAgMTAgZmxpcHMgaWYKJFx0aGV0YSQgd2FzIHNvbWUgdW5rbm93biB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIHdoYXQgY2FuIHdlIGRvIHdpdGggdGhlbT8KV2VsbCwgd2UgY2FuIGp1c3QgdGFrZSB0aGUgcmF0aW8hIEp1c3QgbGlrZSB3ZSBkaWQgd2l0aCB0aGUgdHdvIHNpbXBsZSBwb2ludApoeXBvdGhlc2VzLCB3ZSBjYW4gYWxzbyB0YWtlIHRoZSByYXRpbyBiZXR3ZWVuIG91ciBzaW1wbGUgcG9pbnQgaHlwb3RoZXNpcyBhbmQKb3VyIG1vcmUgY29tcGxleCBoeXBvdGhlc2lzLiBUYWtpbmcgdGhpcyByYXRpbyB0ZWxscyB1cyB0aGF0J3Mgd2UnZCBiZQokMlxmcmFjezM0fXs0OTV9JCB0aW1lcyBtb3JlIGxpa2VseSB0byBzZWUgb3VyIGRhdGEgaWYgJFx0aGV0YSQgd2FzIHNvbWUKdW5rbm93biB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgdGhhbiBpZiAkXHRoZXRhPTAuNSQuCgpUaGlua2luZyBiYWNrIHRvIHRoZSAgKmxhdyBvZiBsaWtlbGlob29kKiB0aGF0IHdlIGNvdmVyZWQgYXQgdGhlIHN0YXJ0IG9mCnRoaXMgc2VjdGlvbiwgd2Ugc2FpZCBpZiBvdXIgZGF0YSB3b3VsZCBiZSBwcm9kdWNlZCBtb3JlIG9mdGVuIGlmCiRcbWF0aGNhbHtIfV8xJCB3ZXJlIHRydWUgdGhhbiBpZiAkXG1hdGhjYWx7SH1fMiQgd2VyZSB0cnVlLCB0aGVuIHRoZSBkYXRhCnByb3ZpZGUgc3VwcG9ydCBmb3IgJFxtYXRoY2Fse0h9XzEkIG92ZXIgJFxtYXRoY2Fse0h9XzIkLiBUaGlzIGlzIGV4YWN0bHkKdGhlIG51bWJlciB0aGF0IHdlJ3ZlIGp1c3Qgd29ya2VkIG91dC4KCiMjIyBUaGVyZSdzIG1vcmUgdGhhbiBvbmUgd2F5IHRvIGF2ZXJhZ2UKCkFib3ZlIHdlIHdvcmtlZCBvdXQgdHdvIHZhbHVlcy4gVGhlIHNlY29uZCBudW1iZXIgd2UgY2FsY3VsYXRlZCBieQphdmVyYWdpbmcgdGhlIGxpa2VsaWhvb2QgZnVuY3Rpb24sIGJ1dCB0aGUgZmlyc3QgbnVtYmVyIHdlIGNhbGN1bGF0ZWQgYnkKanVzdCB0YWtpbmcgYSBzaW5nbGUgcG9pbnQgb24gdGhlIGxpa2VsaWhvb2QgZnVuY3Rpb24uIFNvIG9uZSBpbnZvbHZlZCBhbgphdmVyYWdlIGFuZCB0aGUgb3RoZXIgZGlkIG5vdC4gT3IgZGlkIGl0PyBXZSBjYW4gYWN0dWFsbHkgdGhpbmsgb2YgYm90aCBhcwppbnZvbHZpbmcgYW4gYXZlcmFnZSBvZiB0aGUgbGlrZWxpaG9vZCBmdW5jdGlvbi4gVGhleSdyZSBqdXN0IGRpZmZlcmVudApraW5kcyBvZiBhdmVyYWdlLiBXZSBjYW4gdmlldyBib3RoIGFzIHRha2luZyBhICp3ZWlnaHRlZCBhdmVyYWdlKiwgd2hlcmUKZGlmZmVyZW50IHZhbHVlcyBjb250cmlidXRlIG1vcmUgb3IgbGVzcyB0byB0aGUgYXZlcmFnZS4gRm9yIHRoZSBzZWNvbmQKbnVtYmVyLCBhbGwgdmFsdWVzIGluIHRoZSBhdmVyYWdlIHdlcmUgKndlaWdodGVkIGVxdWFsbHkqLiBUaGF0IGlzLCBpdCB3YXMKanVzdCBsaWtlIGEgcmVndWxhciBhdmVyYWdlLiBGb3IgdGhlIGZpcnN0LCBpdCBjYW4gYmUgdmlld2VkIGFzIHRha2luZyBhbgphdmVyYWdlIHdoZXJlIHRoZSBsaWtlbGlob29kIHZhbHVlIGZvciAkXHRoZXRhPTAuNSQgaXMgZ2l2ZW4gYSB3ZWlnaHQgb2YKMSwgYW5kIGFsbCBvdmVyIHZhbHVlcyBvZiBnaXZlbiBhIHdlaWdodCBvZiAwLiBXZSBjb3VsZCB2aXN1YWxpc2UgdGhlc2UKd2VpZ2h0aW5nIGluIHRoZSBwbG90cyBiZWxvdy4gCgpgYGB7cn0KI3wgZmlnLmhlaWdodDogNAoKcG9pbnQgPC0gZ2dwbG90KAogIGRhdGEgPSB0aWJibGUoeCA9IDAuNSwgeSA9IDEpLAogIGFlcyh4ID0geCwgeSA9IHkpCikgKwogIGdlb21fcG9pbnQoKSArCiAgZ2VvbV9zZWdtZW50KHggPSAwLjUsIHhlbmQgPSAwLjUsIHkgPSAwLCB5ZW5kID0gMSkgKwogIHhsaW0oMCwgMSkgKwogIHlsaW0oMCwgMSkgKwogIGxhYnMoeCA9ICJjb2luIGJpYXMiLCB5ID0gIndlaWdodCIpICsKICB0aGVtZV9taW5pbWFsKDE0KQoKdW5pZm9ybSA8LSBnZ3Bsb3QoCiAgZGF0YSA9IHRpYmJsZSh4ID0gc2VxKDAsIDEsIDAuMSksIHkgPSAxKSwKICBhZXMoeCA9IHgsIHkgPSB5KQopICsKICBnZW9tX2xpbmUoKSArCiAgeGxpbSgwLCAxKSArCiAgeWxpbSgwLCAxKSArCiAgbGFicyh4ID0gImNvaW4gYmlhcyIsIHkgPSAid2VpZ2h0IikgKwogIHRoZW1lX21pbmltYWwoMTQpCgoKCnBvaW50ICsgdW5pZm9ybQpgYGAKCgpUaGVzZSAqd2VpZ2h0aW5ncyogY2FuIGJlIHRob3VnaHQgb2YgYXMgKnByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbnMqLiBXZQphcmUgZ29pbmcgdG8gY2FsbCB0aGVzZSAqKnByaW9ycyoqLiBNYXRoZW1hdGljYWxseSwgdGhleSByZXByZXNlbnRzIHRoZQp3ZWlnaHRzIHRoYXQgd2UgYXBwbHkgdG8gdGhlIHZhbHVlcyB0aGF0IHdlIGF2ZXJhZ2UgdG9nZXRoZXIuIEJ1dCB3aGF0IGRvCnRoZXkgcmVwcmVzZW50cyAqY29uY2VwdHVhbGx5Ki4gT25lIHdheSB0byB0aGluayBvZiB0aGVtIGlzIHRoYXQgdGhleQoqcmVwcmVzZW50IG91ciBiZWxpZWZzIGFib3V0IHRoZSBwYXJhbWV0ZXIgdmFsdWUqIChpbiB0aGlzIGNhc2UgdGhlICpjb2luCmJpYXMqKS4gT3IsIHRoYXQgdGhleSByZXByZXNlbnQgb3VyICptb2RlbCBvZiB0aGUgaHlwb3RoZXNpcyotdGhhdCBpcywKdGhleSByZXByZXNlbnQgd2hhdCB0aGUgaHlwb3RoZXNpcyBoYXMgdG8gc2F5IGFib3V0IHRoZSBwYXJhbWV0ZXIgdmFsdWUuClNvIHRoZSBmYWlyIGNvaW4gaHlwb3RoZXNpcyByZXByZXNlbnRzIGlzIGEgbW9kZWwgdGhhdCBzYXlzICp0aGUgY29pbiBiaWFzCmlzIGV4YWN0bHkgMC41Ki4gVGhlIG90aGVyIGh5cG90aGVzaXMgaXMgYSBtb2RlbCB0aGF0IHNheSAqYWxsIHZhbHVlcyBvZgp0aGUgY29pbiBiaWFzIGJldHdlZW4gMCBhbmQgMSBhcmUgZXF1YWxseSBwcm9iYWJsZSouIAoKQXQgdGhlIHN0YXJ0IG9mIHRoaXMgc2VjdGlvbiB3ZSBzYWlkIHRoYXQgZm9yIG91ciBhbHRlcm5hdGl2ZSBmb3IgYSBmYWlyCmNvaW4gd2UnZCBzYXkgdGhhdCBhbGwgdmFsdWVzIG9mIHRoZSBjb2luIGJpYXMgd2VyZSBlcXVhbGx5IGxpa2VseSwgYW5kCnRoaXMgaXMgd2hhdCB3ZSdkIG1lYW4gYnkgYW4gdW5mYWlyIGNvaW4uIEJ1dCB0aGlzIGlzIG9ubHkgb25lIHBvc3NpYmxlCm1vZGVsIG9mIGFuIHVuZmFpciBjb2luLiBXZSBtaWdodCBhY3R1YWxseSB0aGluayB0aGF0IGlmIGEgY29pbiBpcyB1bmZhaXIKdGhlbiBpdCdsbCBzaG93IGhlYWRzIGZhciBtb3JlIG9mdGVuIHRoYW4gdGFpbHMuIE9yLCB3ZSBtaWdodCB0aGluayB0aGF0CnVuZmFpciBjb2lucyB3aWxsIHNob3cgdGFpbHMgbW9yZSBvZnRlbiB0aGFuIGhlYWRzLiBXZSBtaWdodCBldmVuIHRoaW5rCnRoYXQgdW5mYWlyIGNvaW5zIHdpbGwgYmVoYXZlIHZlcnkgc2ltaWxhcmx5IHRvIGZhaXIgY29pbnMsIGJ1dCB0aGV5J2xsCmp1c3Qgb3V0Y29tZXMgb2YgNSBoZWFkIGFuZCA1IHRhaWxzIGEgbGl0dGxlIGJpdCBsZXNzIG9mdGVuIHRoYW4gdGhlCiRcZnJhY3syNTJ9ezEwMjR9JCB0aGF0IHdlJ2Qgc2VlIHdpdGggYSBwZXJmZWN0bHkgZmFpciBjb2luLiBUaGVzZSBhcmUgYWxsCmRpZmZlcmVudCAqbW9kZWxzKiB0aGF0IHdlIG1pZ2h0IGhhdmUgYWJvdXQgdW5mYWlyIGNvaW5zLiBXZSBjYW4gcmVwcmVzZW50CnRoZXNlIGh5cG90aGVzZXMgaW4gdGVybXMgb2Ygd2hhdCB0aGV5IHNheSBhYm91dCB0aGUgY29pbiBiaWFzIHBhcmFtZXRlci4KVGhhdCBpcywgd2UgY2FuIHJlcHJlc2VudCB0aGVtIGFzICp3ZWlnaHRzKiBvciAqcHJpb3JzKi4gV2UnbGwgbGVhcm4gbW9yZQppbiB0aGUgbmV4dCBzZWN0aW9uIGFib3V0IGhvdyB0byBzcGVjaWZ5IHRoZXNlLCBidXQgZm9yIG5vdyBJJ2xsIGp1c3QKZ2VuZXJhdGUgc29tZSBwbG90LiAKCgpgYGB7cn0KI3wgZmlnLmhlaWdodDogNwoKZmFpcl9jb2luIDwtIHBsb3QoYmF5ZXNwbGF5OjpwcmlvcigicG9pbnQiLCAwLjUpKSArCiAgdGhlbWVfbWluaW1hbCgxNCkgKwogIGxhYnMoeCA9ICJjb2luIGJpYXMiLCB5ID0gIndlaWdodCIpCgptb3JlX2hlYWRzIDwtIHBsb3QoYmF5ZXNwbGF5OjpwcmlvcigiYmV0YSIsIDIsIDEpKSArCiAgdGhlbWVfbWluaW1hbCgxNCkgKwogIGxhYnMoeCA9ICJjb2luIGJpYXMiLCB5ID0gIndlaWdodCIpCgptb3JlX3RhaWxzIDwtIHBsb3QoYmF5ZXNwbGF5OjpwcmlvcigiYmV0YSIsIDEsIDIpKSArCiAgdGhlbWVfbWluaW1hbCgxNCkgKwogIGxhYnMoeCA9ICJjb2luIGJpYXMiLCB5ID0gIndlaWdodCIpCgpqdXN0X29mZiA8LSBwbG90KGJheWVzcGxheTo6cHJpb3IoImJldGEiLCAxMCwgMTApKSArCiAgdGhlbWVfbWluaW1hbCgxNCkgKwogIGxhYnMoeCA9ICJjb2luIGJpYXMiLCB5ID0gIndlaWdodCIpCgphbGxfZXF1YWwgPC0gcGxvdChiYXllc3BsYXk6OnByaW9yKCJiZXRhIiwgMSwgMSkpICsKICB0aGVtZV9taW5pbWFsKDE0KSArCiAgbGFicyh4ID0gImNvaW4gYmlhcyIsIHkgPSAid2VpZ2h0IikKCihtb3JlX2hlYWRzIC8KICBtb3JlX3RhaWxzIC8KICBqdXN0X29mZikgKyBwYXRjaHdvcms6OnBsb3RfYW5ub3RhdGlvbih0YWdfbGV2ZWxzID0gIkEiKQpgYGAKCkluIHBhbmVsICoqQSoqLCB2YWx1ZXMgb2YgdGhlIGNvaW4gYmlhcyBjbG9zZXIgdG8gMSAoc2hvdyBoZWFkcyBhbGwgdGhlIHRpbWUpCmFuZCBnaXZlbiBtb3JlIHdlaWdodCB0aGFuIHZhbHVlcyBjbG9zZXIgdG8gMCAobmV2ZXIgc2hvdyBoZWFkcykuIFRoaXMgbWVhbnMgd2UKZXhjZXB0IHRoZSBjb2luIHRvIHNob3cgaGVhZHMgbW9yZSBvZnRlbi4gSW4gcGFuZWwgKipCKiosIHdlIHNlZSB0aGUgb3Bwb3NpdGUuCkZpbmFsbHksIGluIHBhbmVsICoqQyoqLCB3ZSB3ZWlnaHQgdmFsdWVzIGNsb3NlciB0byAwLjUgKGZhaXIpIGhpZ2hlciB0aGFuCnZhbHVlcyBjbG9zZXIgdG8gMCBvciAxLiBUaGF0IGlzLCB3ZSBkb24ndCB0aGluayB0aGUgY29pbiBiaWFzIGlzIGV4YWN0bHkgMC41LCAKYnV0IHdlIHRoaW5rIHZhbHVlcyBjbG9zZXIgdG8gMC41IGFyZSBtb3JlIHByb2JhYmxlIHRoYW4gdmFsdWVzIGZ1cnRoZXIgYXdheQpmcm9tIDAuNS4KCk5vdyB0aGF0IHdlJ3JlIHRha2luZyBhIHdlaWdodGVkIGF2ZXJhZ2UsIG91ciBlYXJsaWVyIGZvcm11bGEgYmVmb3JlOgoKJCRcaW50X3tcdGhldGFcaW5cVGhldGF9XG1hdGhjYWx7TH0oXHRoZXRhfFxtYXRoYmZ7eX0pZChcdGhldGEpJCQKCk5vdyBqdXN0IGJlY29tZXM6CgokJFxpbnRfe1x0aGV0YVxpblxUaGV0YX1cbWF0aGNhbHtMfShcdGhldGF8XG1hdGhiZnt5fSlwKFx0aGV0YSlkXHRoZXRhJCQKCkluIHdvcmRzIHdlJ2QgcmVhZCB0aGlzIGFzOgoKPiAqVGhlIHByb2JhYmlsaXR5IG9mIG9idGFpbmluZyBvdXIgZGF0YSB1bmRlciB0aGUgc3BlY2lmaWVkIG1vZGVsIGlzIGVxdWFsIHRvCj4gdGhlIGludGVncmFsIG9mIHRoZSBsaWtlbGhvb2QgKHRoZSBtb2RlbCBvZiB0aGUgZGF0YSkgbXVsdGlwbGllZCBieSB0aGUgcHJpb3IgCj4gKHRoZSB3ZWlnaHRzKS4qCgpXZSBtaWdodCBkZW5vdGUgdGhpcyBhcyAkcChZfFxtYXRoY2Fse019X2kkKSBvciBzaW1wbHkgJFxtYXRoY2Fse019X2kkLiBXaGVuCmNvbXBhcmluZyB0d28gbW9kZWxzLS0tZm9yIGV4YW1wbGUsICRcbWF0aGNhbHtNfV8xJCBhbmQgJFxtYXRoY2Fse019XzAkLCB3ZQp0YWtlIHRoZSByYXRpbyBhcyBmb2xsb3dzOgoKJCRcZnJhY3tcbWF0aGNhbHtNfV8xfXtcbWF0aGNhbHtNfV8wfSQkCgpUcnkgbm90IHRvIGJlIHRvbyBpbnRpbWlkYXRlZCBieSB0aGUgZm9ybXVsYSBhYm92ZS4gSXQganVzdCBtZWFucyB0aGF0IHdlJ3JlCndvcmtpbmcgb3V0IHRoZSBwcm9iYWJpbGl0eSBvZiBvYnRhaW5pbmcgb3VyIGRhdGEgZm9yIGEgZ2l2ZW4gdmFsdWUgb2YgdGhlCnBhcmFtZXRlciwgYW5kIHRoYXQgd2UncmUgZG9pbmcgdGhpcyBmb3IgYSByYW5nZSBvZiBwYXJhbWV0ZXIgdmFsdWVzLiBBbmQKZmluYWxseSwgd2UncmUgdGFraW5nIGEgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGVzZS4gVGhlcmUncyBvbmx5IDMgcGFydHMgdG8gdGhlCmZvcm11bGEuIAoKMS4gVGhlIGxpa2VsaWhvb2QsIHdoaWNoIHRlbGxzIHVzIHRoZSBwcm9iYWJpbGl0eSBvZiBvYnRhaW5lZCBvdXIgZGF0YSBhdAogICBhIHNwZWNpZmljIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXI6ICRcbWF0aGNhbHtMfShcdGhldGF8XG1hdGhiZnt5fSkkCgoyLiBUaGUgcHJpb3IsIHdoaWNoIGRldGVybWluZXMgdGhlIHdlaWdodHMgZm9yIHdlaWdodGVkIGF2ZXJhZ2Ugb2YgdGhlIAogICBsaWtlbGlob29kIHZhbHVlczogJHAoXHRoZXRhKSQKCjMuIFRoZSBpbnRlZ3JhbCwgd2hpY2ggcGVyZm9ybXMgdGhlICJhdmVyYWdpbmciIGFjcm9zcyBhbGwgdGhlIGRpZmZlcmVudCB2YWx1ZXMKICAgb2YgdGhlIHBhcmFtZXRlciByYW5nZTogJFxpbnRfe1x0aGV0YVxpblxUaGV0YX0uLi5kXHRoZXRhJAoKIyMjIyBWaXN1YWxpc2luZyBwcmVkaWN0aW9ucwoKV2UgY2FuIGFsc28gcmVwcmVzZW50IHRoZXNlIGRpZmZlcmVudCBtb2RlbHMgb2YgdGhlIGNvaW4gYmFpcyBpbiB0ZXJtcyBvZiB3aGF0Cm91dGNvbWVzIHdlJ2QgcHJlZGljdCwganVzdCBsaWtlIHdlIGRpZCB3aXRoIHRoZSBlYXJsaWVyIHByZWRpY3Rpb25zLiBJbiB0aGUKbmV4dCBzZWN0aW9uLCB3ZSdsbCBhbHNvIGxlYXJuIGFib3V0IGhvdyB0byB0dXJucyBwcmlvcnMgaW50byBwcmVkaWN0aW9ucywgYnV0CmZvciBub3cgd2UnbGwganVzdCBsb29rIGF0IHNvbWUgcGxvdHMuIEluIGVhY2ggb2YgdGhlc2UgcGxvdHMgd2UnbGwgc2hvdyB3aGF0CndlIHdvdWxkICBwcmVkaWN0IGlmIHRoZSBjb2luIHdhcyBleGFjdGx5IGZhaXIgb3ZlcmxhaWQgb24gZWFjaCBvZiB0aGVzZQpkaWZmZXJlbnQgbW9kZWxzIG9mICp1bmZhaXJuZXNzKi4gSW4gZWFjaCBvZiB0aGUgcGxvdHMgd2UnbGwgaGlnaGxpZ2h0IG91cgphY3R1YWwgb3V0Y29tZSBvZiA4IGhlYWRzIGluIDEwIGZsaXBzLgoKYGBge3J9CiN8IGZpZy5oZWlnaHQ6IDEwCgpgZmFpciBjb2luYCA8LSBiYXllc3BsYXk6OmV4dHJhY3RfcHJlZGljdGlvbnMoCiAgYmF5ZXNwbGF5OjpsaWtlbGlob29kKCJiaW5vbWlhbCIsIDgsIDEwKSAqCiAgICBiYXllc3BsYXk6OnByaW9yKCJwb2ludCIsIDAuNSkKKQoKYHNob3dzIG1vcmUgaGVhZHNgIDwtIGJheWVzcGxheTo6ZXh0cmFjdF9wcmVkaWN0aW9ucygKICBiYXllc3BsYXk6Omxpa2VsaWhvb2QoImJpbm9taWFsIiwgOCwgMTApICoKICAgIGJheWVzcGxheTo6cHJpb3IoImJldGEiLCAyLCAxKQopCgpgc2hvd3MgbW9yZSB0YWlsc2AgPC0gYmF5ZXNwbGF5OjpleHRyYWN0X3ByZWRpY3Rpb25zKAogIGJheWVzcGxheTo6bGlrZWxpaG9vZCgiYmlub21pYWwiLCA4LCAxMCkgKgogICAgYmF5ZXNwbGF5OjpwcmlvcigiYmV0YSIsIDEsIDIpCikKCmBqdXN0IG9mZiBmYWlyYCA8LSBiYXllc3BsYXk6OmV4dHJhY3RfcHJlZGljdGlvbnMoCiAgYmF5ZXNwbGF5OjpsaWtlbGlob29kKCJiaW5vbWlhbCIsIDgsIDEwKSAqCiAgICBiYXllc3BsYXk6OnByaW9yKCJiZXRhIiwgMTAsIDEwKQopCgpgYWxsIGVxdWFsYCA8LSBiYXllc3BsYXk6OmV4dHJhY3RfcHJlZGljdGlvbnMoCiAgYmF5ZXNwbGF5OjpsaWtlbGlob29kKCJiaW5vbWlhbCIsIDgsIDEwKSAqCiAgICBiYXllc3BsYXk6OnByaW9yKCJiZXRhIiwgMSwgMSkKKQoKKChiYXllc3BsYXk6OnZpc3VhbF9jb21wYXJlKGBmYWlyIGNvaW5gLCBgc2hvd3MgbW9yZSBoZWFkc2ApICsKICBsYWJzKHggPSAibnVtYmVyIG9mIGhlYWRzIiwgeSA9ICJwKHkpIikgKwogIHRoZW1lX21pbmltYWwoMTIpKSAvCiAgKGJheWVzcGxheTo6dmlzdWFsX2NvbXBhcmUoYGZhaXIgY29pbmAsIGBzaG93cyBtb3JlIHRhaWxzYCkgKwogICAgbGFicyh4ID0gIm51bWJlciBvZiBoZWFkcyIsIHkgPSAicCh5KSIpICsKICAgIHRoZW1lX21pbmltYWwoMTIpKSAvCiAgKGJheWVzcGxheTo6dmlzdWFsX2NvbXBhcmUoYGZhaXIgY29pbmAsIGBqdXN0IG9mZiBmYWlyYCkgKwogICAgbGFicyh4ID0gIm51bWJlciBvZiBoZWFkcyIsIHkgPSAicCh5KSIpICsKICAgIHRoZW1lX21pbmltYWwoMTIpKSAvCiAgKGJheWVzcGxheTo6dmlzdWFsX2NvbXBhcmUoYGZhaXIgY29pbmAsIGBhbGwgZXF1YWxgKSArCiAgICBsYWJzKHggPSAibnVtYmVyIG9mIGhlYWRzIiwgeSA9ICJwKHkpIikgKwogICAgdGhlbWVfbWluaW1hbCgxMikpKSArCiAgcGF0Y2h3b3JrOjpwbG90X2Fubm90YXRpb24odGFnX2xldmVscyA9ICJBIikKYGBgCgpJbiBwYW5lbCAqKkEqKiwgd2Ugc2VlIHRoZSBwcmVkaWN0aW9ucyBmcm9tIG91ciBmYWlyIGNvaW4gbW9kZWwgYWdhaW5zdCBvdXIKcHJlZGljdGlvbnMgZnJvbSBhIG1vZGVsIHdoZXJlIHRoZSBjb2luIHNob3dzIGhlYWRzIG1vcmUgb2Z0ZW4uIEluIHBhbmVsICoqQioqLAp3ZSBzZWUgdGhlIGZhaXIgY29pbiBwcmVkaWN0aW9ucyBhZ2FpbnN0IGEgY29pbiB0aGF0IHNob3dzIHRhaWxzIG1vcmUgb2Z0ZW4uIEluCnBhbmVsICoqQyoqIHdlIHNlZSBvdXIgZmFpciBjb2luIG1vZGVsIGFnYWluIGEgbW9kZWwgd2hlcmUgdGhlIGJpYXMgaXMganVzdApzbGlnaHRseSBvZmYgZnJvbSBmYWlyLiBBbmQgZmluYWxseSBpbiBwYW5lbCAqKkQqKiwgd2Ugc2VlIHRoZSBwcmVkaWN0aW9ucyBvZgp0aGUgZmFpciBjb2luIG1vZGVsIGFnYWluc3QgYSBtb2RlbCB3aGVyZSB3ZSBoYXZlIG5vIHJlYXNvbiBmb3IgdGhpbmtpbmcgdGhhdApvbmUgb3V0Y29tZSBpcyBtb3JlIGxpa2VseSB0aGFuIGFueSBvdGhlciBvdXRjb21lLiAKCkluIGVhY2ggb2YgdGhlc2UgcGFuZWxzIHdlIGNhbiB3ZWlnaCB1cCB0aGUgZXZpZGVuY2UgZm9yIHdoZXRoZXIgb3VyIGRhdGEKc3VwcG9ydCBvbmUgbW9kZWwgb3ZlciB0aGUgb3RoZXIgYnkgbG9va2luZyBhdCB3aGV0aGVyIG91ciBkYXRhIHdvdWxkIGJlCnByb2R1Y2VkIG1vcmUgb2Z0ZW4gaWYgJFxtYXRoY2Fse0h9XzEkIHdlcmUgdHJ1ZSB0aGFuIGlmICRcbWF0aGNhbHtIfV8yJCB3ZXJlCnRydWUuIFRoYXQgaXMsdyB3ZSBjYW4gc2VlIHdoZXRoZXIgdGhlIGRhdGEgcHJvdmlkZSBzdXBwb3J0IGZvciAkXG1hdGhjYWx7SH1fMSQKb3ZlciAkXG1hdGhjYWx7SH1fMiQganVzdCBieSBsb29raW5nIGF0IHdoZXRoZXIgdGhlIGJsdWUgaGlnaGxpZ2h0ZWQgcG9pbnQgaXMKaGlnaGVyIChtb3JlIHByb2JhYmxlKSB0aGFuIHRoZSByZWQgaGlnaGxpZ2h0ZWQgcG9pbnQgKGxlc3MgcHJvYmFibGUpLgo" download="03-likelihoods.Rmd"><img src="https://img.shields.io/badge/.Rmd-Download-blue"></a>
[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/ljcolling/bayes2022/blob/main/_notebooks/03-likelihoods.ipynb)

Coming up with an alternative to *p* values requires us to rearrange our
thinking a bit. So let's first get straight what we're doing with frequentist
inference. In frequentist inference we set some parameter to a certain value
($\theta$), we then generate data from imaginary experiments using that
parameter setting, and we then compare our data to the data from those
experiments. We then ask the question: "Given that parameter value, how
surprising is our data?" At no point are we making inferences *about the value*
of $\theta$. We **set** the value, and we ask a question about our data in
relation to **all the possible data** that might be generated.

To think about what an alternative might look like, let us think back to our
earlier example on the different meanings of probability. With *p*-values we
thought about probability in terms of relative frequency. We were asking "how
often?" questions. But I also mentioned another example. The example of being
90% sure that the accused committed a crime. If we want to be rational humans,
when we make claims like this what we usually do is examine the evidence. We
**compare** whether there is more evidence for the accused's guilt or the
accused's innocence. That is, we take the courtroom evidence and examine
whether it supports hypothesis 1 (the accused is guilty) or hypothesis 2 (the
accused is innocent). To do this we balance of probabilities. Is is more
probable that we'd see this evidence if hypothesis 1 was true, or is it more
probable that we'd see this evidence if hypothesis 2 was true? (In a civil
trial we'd just weigh up the probabilities, but in a criminal trial we'd have
to also examine whether this difference in probabilities exceeds some
threshold. We'll leave this issue of thresholds for now). Might we be able to
apply the same kind of thinking to statistical evidence?

To understand the concept of statistical evidence, let's go back to our coin
flipping example. In our coin flipping example, we collected 10 flips and found
8 heads and 2 tails. Our frequentist analysis asked something like, "is this
data surprising?". But we could ask another question. That question might go
something like this: "Is it more likely that the **bias is 0.6** or that the
**bias is 0.8** given that we'd obtained 8 heads in 10 flips?"

To try and answer this question, we'll again create some simulations. We'll
start by creating two **sampling distributions**. For now we'll keep things
simple and we'll create these sampling distributions on the assumption that I
intended to flip the coin 10 times. To create our sampling distributions we'll
first set $\theta$ to 0.6 and run the simulations, and then we'll set $\theta$
to 0.8 and run the simulations. I know the distribution they'll follow, so I'll
just compute the distributions directly rather than actually running the
simulations.

```{r}
# flip the coin n times and then count up the heads.
# three parameters need to be set
# 1. the number of flips (n_flips)
# 2. the probability of heads (pr_heads)
# 3. the number of heads in our observation (obs_heads)

coin_flip_v1 <- function(n_flips, pr_heads, obs_heads) {
  pmap_df(
    tibble(heads = 0:n_flips, flips = n_flips, pr_heads = pr_heads),
    function(heads, flips, pr_heads) {
      tibble(
        flips = flips, heads = heads,
        freq = dbinom(heads, flips, pr_heads)
      )
    }
  ) %>% # get the frequency
    mutate(our_ob = case_when(
      flips == n_flips & heads == obs_heads ~ TRUE,
      TRUE ~ FALSE
    )) # mark our observation
}
```

We can draw the distributions of the possible data that would occur for
different values of P(heads) = $\theta$. In each of the plots, our
actual observation will be highlighted. Although we're "simulating" all
possible observations, you'll see that we're only going to care about our
**actual** observation. We will want to know the relative frequency with which
**that** result occurs, not the frequency of results that didn't but might've
occurred. I'm going to draw several distributions not just two that correspond
to the values of $\theta$ that we're interested in.

```{r}
# draw distributions of the data for various values of pr_heads for version 1
# (flip n times)

n_flips <- 10

pr_heads_values <- c(0.2, 0.4, 0.6, 0.8) # set our pr_heads values

obs_heads <- 8

# make the plots
coin_flip_v1_plots <- pmap(
  tibble(n_flips = n_flips, pr_heads = pr_heads_values, obs_heads = obs_heads),
  function(n_flips, pr_heads, obs_heads) {
    coin_flip_v1(n_flips, pr_heads, obs_heads) %>%
      ggplot(aes(x = heads, y = freq)) +
      geom_line(alpha = .25) +
      geom_point(aes(colour = our_ob), size = 3) +
      scale_colour_manual(
        guide = "none",
        values = c("TRUE" = "black", "FALSE" = "grey")
      ) +
      labs(
        x = glue::glue("number of heads in {n_flips} flips"),
        y = "relative frequency",
        title = glue::glue("P(heads) = {pr_heads}")
      ) +
      scale_x_continuous(breaks = c(seq(0, n_flips, 1))) +
      scale_y_continuous(limits = c(0, .5)) +
      theme_minimal() +
      NULL
  }
)

# make the plots pretty and arrange them

(patchwork::wrap_plots(coin_flip_v1_plots, nrow = 2) +
  plot_annotation(tag_levels = "A"))
```

Let's take these plots and create a new one out of them. Since we're just
interested in **our specific observation** we'll take all the marked points and
put them on a plot of their own. Now we'll still have relative frequency on the
y-axis, but on the x-axis we won't have the observation anymore (because we're
only focused on one specific outcome). Instead, we'll have $\theta$ on the
x-axis.

```{r}
# first set our observation again
number_of_heads <- 8
number_of_flips <- 10

# and set the range of bias to consider
pr_heads_range <- seq(0, 1, .1) # 0/10, 1/10 ... 9/10, 10/10

# translate our observation into the parameters needed for version 1
# generate the data and pull out the relative frequency of our specific
# observation

n_flips <- number_of_flips
obs_heads <- number_of_heads
likelihood_v1 <- map_df(pr_heads_range, function(x) {
  coin_flip_v1(n_flips, x, obs_heads) %>%
    filter(our_ob == TRUE) %>%
    select(freq) %>%
    mutate(pr_heads = x)
})
```

```{r}
# now actually draw the plot

likelihood_v1 %>%
  ggplot(aes(x = pr_heads, y = freq)) +
  geom_point() +
  geom_line() +
  theme_minimal(12) +
  scale_x_continuous(name = "P(heads)", breaks = seq(0, 1, .2)) +
  scale_y_continuous(limits = c(0, .4), name = "relative frequency") +
  labs(
    title = glue::glue(
      "likelihood function for {number_of_heads}",
      " heads in {number_of_flips} flips"
    ),
    subtitle = glue::glue("stopping after {number_of_flips}")
  )
```

This new plot that we're created illustrates what's know as the **likelihood**
function. The likelihood function describes the relationship between values of
the parameter and **our data**. It's made up of slices of the sampling
distribution-the slices that correspond to our actual observation. Remember
that when we were doing inference with the sampling distribution we were
looking at the extreme tails of the sampling distribution. That is, we were
interested in the entire shape of the sampling distribution. Now we're instead
only interested in the thin slice that corresponds to our observation.

## Doing inference with likelihoods

The likelihood plays a key role in Bayesian inference. Inferences on the basis
of likelihoods are derived from what is known at the *law of likelihood*.
Simply stated, the *law of likelihood* says that for a given pair of
hypotheses---for example, $\mathcal{H}_1$ that the coin bias is P(heads)=0.6
and $\mathcal{H}_2$ that the coin bias is P(heads)=0.8---then data support
$\mathcal{H}_1$ over $\mathcal{H}_2$ if the likelihood of $\mathcal{H}_1$
exceeds that of $\mathcal{H}_2$. Or, put another way, if our data would be
produced more often if $\mathcal{H}_1$ were true than if $\mathcal{H}_2$ were
true, then the data provide support for $\mathcal{H}_1$ over $\mathcal{H}_2$
(See [Hacking,
1965](https://www.google.co.uk/books/edition/Logic_of_Statistical_Inference/cEJfDAAAQBAJ?hl=en&gbpv=0) Chapter 5, for both formulations).

This definition might seem a little opaque, but we can read these likelihood
values straight off our likelihood plot. The height of the likelihood plot, at
each value of $\theta$, tells you the probability of obtaining your data given
that value of $\theta$. If the likelihood function is higher at $\theta=0.8$
than $\theta=0.6$ then the probability of obtaining our data would be higher if
$\theta$ was 0.8 than it would be if $\theta$ was 0.6. Consequently, our data
support the hypothesis that $\theta=0.8$ *over* the hypothesis $\theta=0.6$. A
key point here, that's worth stressing, is that this is a comparison between
two specific hypothesis. Does this data support this one specific hypothesis
over this other specific hypothesis. What you're doing here is *weighing up
probabilities* just like you would do in a courtroom.

### A brief detour back to sampling rules

Before we continue, let's just go back to something from the previous section.
I made a big deal about how our sampling rules change the shape of the sampling
distribution, and that this then changes the inferences that we make. This is
the case even if nothing changes about our actual data. But do different
sampling rules change the likelihood? To test this out, we'll generate a new
set of sampling distributions using the other sampling rule (sampling until we
get 2 heads). And from these sampling distributions we'll generate some
likelihoods.

```{r}
# function v2 "simulates" results from the version where you
# flip the coin until it comes up tails n times.
# three parameters need to be set
# 1. the number of tails to stop at (n_tails)
# 2. the probability of heads (pr_heads)
# 3. the number of flips in our observation (obs_flips)

coin_flip_v2 <- function(n_tails, pr_heads, obs_flips) {
  pmap_df(
    tibble(
      tails = n_tails,
      pr_heads = pr_heads,
      flips = 0:(obs_flips + 4)
    ), # input values
    function(tails, pr_heads, flips) {
      tibble(
        flips = flips, tails = tails,
        freq = dnbinom(flips - tails, tails, 1 - pr_heads)
      )
    }
  ) %>%
    mutate(our_ob = case_when(
      flips == obs_flips & tails == tails ~ TRUE,
      TRUE ~ FALSE
    )) # mark our observation
}
```

```{r}
# draw distributions of the data for various values of pr_heads for version 2
# (flip until n tails)

n_tails <- 2
n_flips <- 10
pr_heads_values <- c(0.2, 0.4, 0.6, 0.8) # set our pr_heads
obs_flips <- 10
# make the plots
coin_flip_v2_plots <- pmap(
  tibble(n_tails = n_tails, pr_heads = pr_heads_values, obs_flips = obs_flips),
  function(n_tails, pr_heads, obs_flips) {
    coin_flip_v2(n_tails, pr_heads, obs_flips) %>%
      ggplot(aes(x = flips, y = freq)) +
      geom_line(alpha = .25, na.rm = TRUE) +
      geom_point(aes(colour = our_ob), size = 3, na.rm = TRUE) +
      scale_colour_manual(
        guide = "none",
        values = c("TRUE" = "black", "FALSE" = "grey")
      ) +
      labs(
        x = glue::glue("number of flips until {n_tails} tails"),
        y = "relative frequency",
        title = glue::glue("P(heads) = {pr_heads}")
      ) +
      scale_x_continuous(breaks = seq(2, 12, 2), limits = c(2, 12)) +
      scale_y_continuous(limits = c(0, .85)) +
      theme_minimal() +
      NULL
  }
)


(patchwork::wrap_plots(coin_flip_v2_plots, nrow = 2) +
  plot_annotation(tag_levels = "A"))
```

We can see that these sampling distributions look very different to the
sampling distributions that we generated above. But what we're interested in
are just the highlighted points, because we'll use these to generate our
likelihood.

```{r}
# translate our observation into the parameters needed for version 2
# generate the data and out the relative frequency of our specific observation
n_tails <- number_of_flips - number_of_heads
obs_flips <- number_of_flips
likelihood_v2 <- map_df(pr_heads_range, function(x) {
  suppressWarnings({ # supress warnings about impossible values
    coin_flip_v2(n_tails, x, obs_flips) %>%
      filter(our_ob == TRUE) %>%
      select(freq) %>%
      mutate(pr_heads = x) %>%
      mutate(freq = ifelse(is.na(freq), 0, freq))
  })
}) # replace NaN (impossible values) with 0 for plotting

# now actually draw the plot

likelihood_v2 %>%
  ggplot(aes(x = pr_heads, y = freq)) +
  geom_point() +
  geom_line() +
  theme_minimal(12) +
  scale_x_continuous(name = "P(heads)", breaks = seq(0, 1, .2)) +
  scale_y_continuous(limits = c(0, .4), name = "relative frequency") +
  labs(
    title = glue::glue(
      "likelihood function for {number_of_heads} ",
      "in {number_of_flips}"
    ),
    subtitle = glue::glue("stopping after {n_tails} tails")
  )
```

The new likelihood might, at first glance, look different to the one we
generated earlier, but it's just a scaled version of the earlier likelihood. We
can check this just by rescaling the two likelihoods so that they both have a
max of 1.

```{r}
# now draw scaled versions of the plots

likelihood_v1_plot <- likelihood_v1 %>%
  mutate(freq = freq / max(freq)) %>%
  ggplot(aes(x = pr_heads, y = freq)) +
  geom_point() +
  geom_line() +
  theme_minimal(12) +
  scale_x_continuous(name = "P(heads)", breaks = seq(0, 1, .2)) +
  scale_y_continuous(limits = c(0, 1), name = "relative frequency") +
  labs(
    title = glue::glue(
      "likelihood function for {number_of_heads} ",
      "heads in {number_of_flips} flips"
    ),
    subtitle = glue::glue("stopping after {number_of_flips}")
  )

likelihood_v2_plot <- likelihood_v2 %>%
  mutate(freq = freq / max(freq)) %>%
  ggplot(aes(x = pr_heads, y = freq)) +
  geom_point() +
  geom_line() +
  theme_minimal(12) +
  scale_x_continuous(name = "P(heads)", breaks = seq(0, 1, .2)) +
  scale_y_continuous(limits = c(0, 1), name = "relative frequency") +
  labs(
    title = glue::glue(
      "likelihood function for {number_of_heads} ",
      "in {number_of_flips}"
    ),
    subtitle = glue::glue("stopping after {n_tails} tails")
  )


(likelihood_v1_plot / likelihood_v2_plot +
  plot_annotation(tag_levels = "A"))
```

Now that they're been rescaled we can see that they're they same. Note that
scaling changes the absolute distance between points on the likelihood, but it
doesn't change the *relative* distance between the points. When we want to know
the difference between two likelihood values we take the *ratio* of these two
values. The ratio gives us the *relative distance* between the heights on the
likelihood function, and the *relative distance* doesn't change with scaling.

More importantly, however, what this demonstrates is that when we do inference
with **likelihoods** instead of **sampling distributions**, things like
stopping rules, data that wasn't collected but might have been collected, and
all those other sorts of things that were tricky about *p*-values don't come in
to play. We only have the worry about **the data we actually have**, and the
**likelihood** which relates **parameter values** to **data**.

### The likelihood ratio

The likelihood ratio is going to be our measure of evidence of how much
the data supports one hypothesis over another. If the likelihood at point
one ($\theta_1$) is four times the larger than the likelihood at point two
($\theta_2$) then the data are four times more likely under the hypothesis
$\theta = \theta_1$ than the hypothesis $\theta = \theta_2$. Or simply
put, the data supports the hypothesis $\theta=\theta_1$  over
$\theta=\theta_2$ but a factor of 4 to 1.

Let's look at the likelihood for our actual data and our two hypotheses
about the coin bias. Just to drive home the point that the sampling rule
doesn't matter, I'm going to work out the likelihood ratio for the
sampling rule where I flip the coin 10 times and the sampling rule where
I flip the coin until I get 2 heads and just happen to flip it 10 times.
We'll see that the absolute values of the likelihoods change (as we saw in
the plots above), but that the likelihood ratio between the hypotheses
don't change. 

To make sure that the numbers work out correctly, I won't use simulations
to generate the likelihoods. Instead I'll just generate each likelihood
with the relevant formula. 

```{r}
# define a function for nice printing
print_likelihood <- function(h1, h2, likelihood_1, likelihood_2) {
  likelihood_1_text <- glue::glue(
    "The likelihood for $\\mathcal{{H}}_1$ (P(heads) = {h1}) ",
    "is {round(likelihood_1,2)}"
  )
  likelihood_2_text <- glue::glue(
    "The likelihood for $\\mathcal{{H}}_2$ (P(heads) = {h2}) ",
    "is {round(likelihood_2,2)}"
  )
  ratio_text <- glue::glue(
    "The likelihood ratio is {round(likelihood_1 / likelihood_2, 2)}"
  )
  interpretation <- glue::glue(
    "The data are {round(likelihood_1 / likelihood_2, 2)} times more ",
    "probable under $\\mathcal{{H}}_1$ than $\\mathcal{{H}}_2$"
  )
  paste(c(likelihood_1_text, likelihood_2_text, ratio_text, interpretation),
    collapse = "\n\n"
  )
}
```

First, for version 1, where I flip the coin 10 times (**binomial**
sampling rule).

```{r}
# set out observation
n <- 10 # number of flips
h <- 8 # number of heads
t <- n - h # number of tails

# set our two hypotheses
h1 <- 0.6 # the probability of getting heads is 0.6
h2 <- 0.8 # the probability of getting heads is 0.8

# work out the likelihood values
likelihood_1 <- dbinom(h, n, h1)
likelihood_2 <- dbinom(h, n, h2)

print_likelihood(h1, h2, likelihood_1, likelihood_2) %>% display_markdown()
```

Second, for version 2, where I flip the coin until I get 2 hears
(**negative-binomial** sampling rule).

```{r}
# Set our observation
n <- 10 # number of flips
h <- 8 # number of heads
t <- n - h # number of tails

# set our two hypotheses
h1 <- 0.6 # the probability of getting heads is 0.6
h2 <- 0.8 # the probability of getting heads is 0.8

# work out the likelihood values
likelihood_1 <- dnbinom(t, h, h1)
likelihood_2 <- dnbinom(t, h, h2)

print_likelihood(h1, h2, likelihood_1, likelihood_2) %>% display_markdown()
```

### A note about likelihood functions and probability distributions

One common misconception about likelihood functions is that they're
probability distributions. This misconception can come in a few different
forms, so it's worth just stressing again what a likelihood function is. 

First, we can tell a likelihood function isn't a probability distribution,
because for a probability distribution the area under the curve would have
to sum to 1. Each point on a probability distribution gives the probability
of a specific event. The whole curve describes all the events that could
happen, and the area under the curve gives the probability that one of the
possible events happens. That is, it is the sum of all the individual
probabilities of the different events.

In the plot below, we can see the likelihood functions for different
events (different numbers of heads in 10 flips). We can see that the area
under the curve varies in each case. If these were probability
distributions then the area under the curve in each case would be 1.

```{r}
# plot some likelihood functions

scenarios <- list(
  p1 = list(heads = 0, flips = 10),
  p2 = list(heads = 1, flips = 2),
  p3 = list(heads = 0, flips = 2),
  p4 = list(heads = 2, flips = 5)
)

plots <- map(scenarios, function(x) {
  data_model <- bayesplay::likelihood("binomial",
    successes = x$heads,
    trials = x$flips
  )
  auc <- integrate(data_model$likelihood_function, 0, 1)$value
  plot(data_model) +
    labs(
      title = glue::glue("likelihood for {x$heads} heads in {x$flips} flips"),
      subtitle = glue::glue("area under curve is {round(auc,3)}")
    ) +
    theme_minimal(12) +
    NULL
})

patchwork::wrap_plots(plots)
```

This misconception about likelihood functions being probability
distribution often takes the form of thinking that the likelihood function
tells use the probability of the parameter being a specific value. That
is, it tells us that there's a higher probability that $\theta=\theta_1$
than $\theta=\theta_2$, given our data. Put another way, this
misconception states that the likelihood tells us $p(\theta|y)$. This
quantity, however, is what's know as the **posterior probability**.
Rather, the likelihood tells us the reserve conditional, or $p(y|\theta)$.
That is, it tells use the probability of obtaining our data given
different values of the parameter.

To emphasise that the likelihood is not a probability distribution it is
often denoted $\mathcal{L}(\theta|y)$.

## Testing more complex hypotheses

So we've seen that comparing likelihoods (by taking their ratio) can tell
us which hypothesis is better supported by the data. However, there's
a couple of problems with what we've done up until now. First, how do we
know explicitly set a threshold for when we would start digging for
treasure. Is there also a threshold for likelihood ratios? To answer this
question, we're going to have to take into account a lot of additional
factors. And the answer to this question is probably going to be
context-dependent. For example, if we're placing bets on hypotheses, we're
probably going to want to take into account the relative pay-offs. If
we're using evidence to decide somebody's guilt in a court case, we're
probably going to want to take into account things like "reasonable
doubt". In short, there's not a straight forward answer to this question,
so we'll set it aside for now. Instead, we'll turn to the second problem.

The second problem with what we've done up until now is that we've just
been comparing single point hypothesis. We can can say, for example,
whether the data supports P(heads) = 0.5 over the hypothesis P(heads)
= 0.8, and we can quantify this level of support. But usually, we are not
comparing two simple hypotheses like this. Our hypotheses take a more
complex form like: "Is the coin fair?"

How might we go about answering this question?

To come up with a way to answer this question we're going to think about
hypotheses in terms of **predictions**. Our first hypothesis,
$\mathcal{H}_0$, will be that the coin is fair. And we'll say a fair coin
has a bias of 0.5. What do we predict will happen if we flip the coins 10
times? Most of the time it'll show around about 5 heads and 5 tails, but
it will also rarely show 1 head and 9 heads etc. If we plotted it, it
would just be our sampling distribution from before. 

For $\mathcal{H}_1$, that the coin isn't fair, what do we predict will
happen if we flipped it 10 times? Before we can work this out we need to
think a little bit about what it means for a coin not to be fair. For now,
let's say that it means that it can have some bias between 0 and 1, but
that we don't know what it is. For our fair coin, if we collected a very
large number of samples the most common outcome would be 5 heads and
5 tails, but would be the most common outcome with our unfair coin? Would
it be 5 heads and 5 tails? Would it be 0 heads? 1 head? 9 heads? Do we
have any grounds for **predicting** that one outcome would be more common
than another outcome? We arguably do not. If so, then if I asked which of
the 11 possible outcomes (from a sample of 10 coin flips) is more probable
than the others you might say none. If none of the outcomes are more
probable than any of the other outcomes, and given that there's 11
possible outcomes, then our prediction must be that each outcome has
a 1 in 11 chance of occurring.

Below, we can see plots of our two predictions. First, what we would
predict if we knew the coin bias was 0.5, and second what we would predict
if we had no reason for favouring one outcome over another. 

```{r}


# the two predictions

predictions1 <- tibble::tibble(
  x = seq(0, 10, 1),
  y = dbinom(x, 10, 0.5)
) %>%
  ggplot(data = ., aes(x = x, y = y)) +
  geom_point() +
  geom_line() +
  labs(x = "number of heads", y = "probability") +
  scale_x_continuous(breaks = seq(0, 10, 1)) +
  theme_minimal(14)


predictions2 <- tibble::tibble(
  x = seq(0, 10, 1),
  y = 1 / length(x)
) %>%
  ggplot(data = ., aes(x = x, y = y)) +
  geom_point() +
  geom_line() +
  labs(x = "number of heads", y = "probability") +
  scale_x_continuous(breaks = seq(0, 10, 1)) +
  theme_minimal(14)

(predictions1  / predictions2) +
  plot_annotation(tag_levels = "A")

```

Now that we have a intuition for hypotheses in terms of predictions, let
use formalise it a bit. And instead of thinking about all the data that
might be produced let's just try and think about the probability of
obtaining our data of 8 heads in 10 flips. If a coin is fair, then in 10
coin flips there are exactly $2^{10}$ possible sequences and 45 of these
sequences would give 8 heads in 10 flips. Therefore, if the coin is fair,
then the probability of obtaining our result of 8 heads in 10 flips in
$\frac{45}{1024}$, or about 0.044. I've worked this out exactly, but we'd
get the same value if we ran the simulations, or if we just looked at the
likelihood function at $\theta=0.5$. This is after all, what the
likelihood function tells use: the probability of obtaining our data for
a given value of the parameter. 

Now on to the more complex example where the coin bias is some unknown
value between 0 and 1. What now is the probability of obtaining our data.
One good strategy of dealing with unknowns is to average across the
possibilities. For example, if I didn't know what the coin bias was, but
I knew it could either be 0.5 or 0.6, then to work out the probability of
obtaining our current data I could just work out the probability of
obtaining our current data if the bias was 0.5 (~0.044), and then work out
the probability of obtaining our current data if 0.6 (~0.121), and then
just average them together (~0.082). Again, I just take the values from
the likelihood function at $\theta=0.5$ and $\theta=0.6$ and aveage them
together. 

But in our example it's not just the case that the bias of the coin could
be 0.5 or 0.6. For our second hypothesis we said it could be any value
between 0 and 1. That is, hypothesis is the set $\Theta
= \{\theta_1,\theta_2,...,\theta_n\}$ where each $\theta_1$ to $\theta_n$
is some value between 0 and 1. To keep things simple for now, we'll say
that $\Theta =\{\theta_1=\frac{0}{10},
\theta_2=\frac{1}{10},...,\theta_{11}=\frac{10}{10}\}$. An average is just
a sum where each value is multiplied by $\frac{1}{n}$, therefore, the
average across these 11 values would be:

$$\sum_{i=1}^{11}\mathcal{L}(\theta_i|\mathbf{y})\cdot{}\frac{1}{11}$$

This gives a value of approximately $\frac{1}{12}$, which is pretty close
to the value of $\frac{1}{11}$ we worked out earlier. Why is it not the
same? Well, earlier, we said it could be **any** value between 0 and 1.
We're only looking at 11 values. Let's instead look at 101 values between
0 and 1. Now $\Theta = \{\theta_1=\frac{0}{100},
\theta_2=\frac{1}{100},...,\theta_{101}=\frac{100}{100}\}$. Now we get
a value that's even closer to $\frac{1}{11}$. To get to exactly
$\frac{1}{11}$, however, we're going to have to look at even more points.
Instead of spacing the points out by $\frac{1}{10}$ or $\frac{1}{100}$,
we're going to need infinitesimally small spacing. That's means we just
switch out the sum for an integral, but the logic is the same. We're still
just taking an average.

$$\int_{\theta\in\Theta}\mathcal{L}(\theta|\mathbf{y})d(\theta)$$

Now that we're taking an integral, we get exactly $\frac{1}{11}$.

Now that we have these two values: First, $\frac{45}{1024}$, which gives the
probability of obtaining 8 heads in 10 flips if $\theta=0.5$, and second,
$\frac{1}{11}$, which the probability of obtaining 8 head in  10 flips if
$\theta$ was some unknown value between 0 and 1, what can we do with them?
Well, we can just take the ratio! Just like we did with the two simple point
hypotheses, we can also take the ratio between our simple point hypothesis and
our more complex hypothesis. Taking this ratio tells us that's we'd be
$2\frac{34}{495}$ times more likely to see our data if $\theta$ was some
unknown value between 0 and 1 than if $\theta=0.5$.

Thinking back to the  *law of likelihood* that we covered at the start of
this section, we said if our data would be produced more often if
$\mathcal{H}_1$ were true than if $\mathcal{H}_2$ were true, then the data
provide support for $\mathcal{H}_1$ over $\mathcal{H}_2$. This is exactly
the number that we've just worked out.

### There's more than one way to average

Above we worked out two values. The second number we calculated by
averaging the likelihood function, but the first number we calculated by
just taking a single point on the likelihood function. So one involved an
average and the other did not. Or did it? We can actually think of both as
involving an average of the likelihood function. They're just different
kinds of average. We can view both as taking a *weighted average*, where
different values contribute more or less to the average. For the second
number, all values in the average were *weighted equally*. That is, it was
just like a regular average. For the first, it can be viewed as taking an
average where the likelihood value for $\theta=0.5$ is given a weight of
1, and all over values of given a weight of 0. We could visualise these
weighting in the plots below. 

```{r}
#| fig.height: 4

point <- ggplot(
  data = tibble(x = 0.5, y = 1),
  aes(x = x, y = y)
) +
  geom_point() +
  geom_segment(x = 0.5, xend = 0.5, y = 0, yend = 1) +
  xlim(0, 1) +
  ylim(0, 1) +
  labs(x = "coin bias", y = "weight") +
  theme_minimal(14)

uniform <- ggplot(
  data = tibble(x = seq(0, 1, 0.1), y = 1),
  aes(x = x, y = y)
) +
  geom_line() +
  xlim(0, 1) +
  ylim(0, 1) +
  labs(x = "coin bias", y = "weight") +
  theme_minimal(14)



point + uniform
```


These *weightings* can be thought of as *probability distributions*. We
are going to call these **priors**. Mathematically, they represents the
weights that we apply to the values that we average together. But what do
they represents *conceptually*. One way to think of them is that they
*represent our beliefs about the parameter value* (in this case the *coin
bias*). Or, that they represent our *model of the hypothesis*-that is,
they represent what the hypothesis has to say about the parameter value.
So the fair coin hypothesis represents is a model that says *the coin bias
is exactly 0.5*. The other hypothesis is a model that say *all values of
the coin bias between 0 and 1 are equally probable*. 

At the start of this section we said that for our alternative for a fair
coin we'd say that all values of the coin bias were equally likely, and
this is what we'd mean by an unfair coin. But this is only one possible
model of an unfair coin. We might actually think that if a coin is unfair
then it'll show heads far more often than tails. Or, we might think that
unfair coins will show tails more often than heads. We might even think
that unfair coins will behave very similarly to fair coins, but they'll
just outcomes of 5 head and 5 tails a little bit less often than the
$\frac{252}{1024}$ that we'd see with a perfectly fair coin. These are all
different *models* that we might have about unfair coins. We can represent
these hypotheses in terms of what they say about the coin bias parameter.
That is, we can represent them as *weights* or *priors*. We'll learn more
in the next section about how to specify these, but for now I'll just
generate some plot. 


```{r}
#| fig.height: 7

fair_coin <- plot(bayesplay::prior("point", 0.5)) +
  theme_minimal(14) +
  labs(x = "coin bias", y = "weight")

more_heads <- plot(bayesplay::prior("beta", 2, 1)) +
  theme_minimal(14) +
  labs(x = "coin bias", y = "weight")

more_tails <- plot(bayesplay::prior("beta", 1, 2)) +
  theme_minimal(14) +
  labs(x = "coin bias", y = "weight")

just_off <- plot(bayesplay::prior("beta", 10, 10)) +
  theme_minimal(14) +
  labs(x = "coin bias", y = "weight")

all_equal <- plot(bayesplay::prior("beta", 1, 1)) +
  theme_minimal(14) +
  labs(x = "coin bias", y = "weight")

(more_heads /
  more_tails /
  just_off) + patchwork::plot_annotation(tag_levels = "A")
```

In panel **A**, values of the coin bias closer to 1 (show heads all the time)
and given more weight than values closer to 0 (never show heads). This means we
except the coin to show heads more often. In panel **B**, we see the opposite.
Finally, in panel **C**, we weight values closer to 0.5 (fair) higher than
values closer to 0 or 1. That is, we don't think the coin bias is exactly 0.5, 
but we think values closer to 0.5 are more probable than values further away
from 0.5.

Now that we're taking a weighted average, our earlier formula before:

$$\int_{\theta\in\Theta}\mathcal{L}(\theta|\mathbf{y})d(\theta)$$

Now just becomes:

$$\int_{\theta\in\Theta}\mathcal{L}(\theta|\mathbf{y})p(\theta)d\theta$$

In words we'd read this as:

> *The probability of obtaining our data under the specified model is equal to
> the integral of the likelhood (the model of the data) multiplied by the prior 
> (the weights).*

We might denote this as $p(Y|\mathcal{M}_i$) or simply $\mathcal{M}_i$. When
comparing two models---for example, $\mathcal{M}_1$ and $\mathcal{M}_0$, we
take the ratio as follows:

$$\frac{\mathcal{M}_1}{\mathcal{M}_0}$$

Try not to be too intimidated by the formula above. It just means that we're
working out the probability of obtaining our data for a given value of the
parameter, and that we're doing this for a range of parameter values. And
finally, we're taking a weighted average of these. There's only 3 parts to the
formula. 

1. The likelihood, which tells us the probability of obtained our data at
   a specific value of the parameter: $\mathcal{L}(\theta|\mathbf{y})$

2. The prior, which determines the weights for weighted average of the 
   likelihood values: $p(\theta)$

3. The integral, which performs the "averaging" across all the different values
   of the parameter range: $\int_{\theta\in\Theta}...d\theta$

#### Visualising predictions

We can also represent these different models of the coin bais in terms of what
outcomes we'd predict, just like we did with the earlier predictions. In the
next section, we'll also learn about how to turns priors into predictions, but
for now we'll just look at some plots. In each of these plots we'll show what
we would  predict if the coin was exactly fair overlaid on each of these
different models of *unfairness*. In each of the plots we'll highlight our
actual outcome of 8 heads in 10 flips.

```{r}
#| fig.height: 10

`fair coin` <- bayesplay::extract_predictions(
  bayesplay::likelihood("binomial", 8, 10) *
    bayesplay::prior("point", 0.5)
)

`shows more heads` <- bayesplay::extract_predictions(
  bayesplay::likelihood("binomial", 8, 10) *
    bayesplay::prior("beta", 2, 1)
)

`shows more tails` <- bayesplay::extract_predictions(
  bayesplay::likelihood("binomial", 8, 10) *
    bayesplay::prior("beta", 1, 2)
)

`just off fair` <- bayesplay::extract_predictions(
  bayesplay::likelihood("binomial", 8, 10) *
    bayesplay::prior("beta", 10, 10)
)

`all equal` <- bayesplay::extract_predictions(
  bayesplay::likelihood("binomial", 8, 10) *
    bayesplay::prior("beta", 1, 1)
)

((bayesplay::visual_compare(`fair coin`, `shows more heads`) +
  labs(x = "number of heads", y = "p(y)") +
  theme_minimal(12)) /
  (bayesplay::visual_compare(`fair coin`, `shows more tails`) +
    labs(x = "number of heads", y = "p(y)") +
    theme_minimal(12)) /
  (bayesplay::visual_compare(`fair coin`, `just off fair`) +
    labs(x = "number of heads", y = "p(y)") +
    theme_minimal(12)) /
  (bayesplay::visual_compare(`fair coin`, `all equal`) +
    labs(x = "number of heads", y = "p(y)") +
    theme_minimal(12))) +
  patchwork::plot_annotation(tag_levels = "A")
```

In panel **A**, we see the predictions from our fair coin model against our
predictions from a model where the coin shows heads more often. In panel **B**,
we see the fair coin predictions against a coin that shows tails more often. In
panel **C** we see our fair coin model again a model where the bias is just
slightly off from fair. And finally in panel **D**, we see the predictions of
the fair coin model against a model where we have no reason for thinking that
one outcome is more likely than any other outcome. 

In each of these panels we can weigh up the evidence for whether our data
support one model over the other by looking at whether our data would be
produced more often if $\mathcal{H}_1$ were true than if $\mathcal{H}_2$ were
true. That is,w we can see whether the data provide support for $\mathcal{H}_1$
over $\mathcal{H}_2$ just by looking at whether the blue highlighted point is
higher (more probable) than the red highlighted point (less probable).
