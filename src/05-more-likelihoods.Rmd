---
output: pdf_document
---
```{r setup, echo=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
suppressMessages(expr = {
  if ("xfun" %in% row.names(installed.packages()) == FALSE) {
    install.packages("xfun")
  }

  display_markdown <<- knitr::asis_output
  display_html <<- knitr::asis_output

  xfun::pkg_attach(
    c(
      "tidyverse",
      "polspline",
      "patchwork",
      "magrittr",
      "bayesplay",
      "knitr",
      "broom",
      "bayesplay"
    ),
    install = TRUE
  )
})

table_format <- "html"
```
# Moving beyond coin flips
<a href="data:text/x-markdown;base64,LS0tCnRpdGxlOiAiQmV5b25kIGNvaW4gY2xpcHMiCm91dHB1dDogaHRtbF9kb2N1bWVudAotLS0KCmBgYHtyIHNldHVwLCBlY2hvPUZBTFNFLCBtZXNzYWdlID0gRkFMU0UsIHdhcm5pbmcgPSBGQUxTRX0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KGVjaG8gPSBGQUxTRSwgbWVzc2FnZSA9IEZBTFNFLCB3YXJuaW5nID0gRkFMU0UpCnN1cHByZXNzTWVzc2FnZXMoZXhwciA9IHsKICBpZiAoInhmdW4iICVpbiUgcm93Lm5hbWVzKGluc3RhbGxlZC5wYWNrYWdlcygpKSA9PSBGQUxTRSkgewogICAgaW5zdGFsbC5wYWNrYWdlcygieGZ1biIpCiAgfQoKICBkaXNwbGF5X21hcmtkb3duIDw8LSBrbml0cjo6YXNpc19vdXRwdXQKICBkaXNwbGF5X2h0bWwgPDwtIGtuaXRyOjphc2lzX291dHB1dAoKICB4ZnVuOjpwa2dfYXR0YWNoKAogICAgYygKICAgICAgInRpZHl2ZXJzZSIsCiAgICAgICJwb2xzcGxpbmUiLAogICAgICAicGF0Y2h3b3JrIiwKICAgICAgIm1hZ3JpdHRyIiwKICAgICAgImJheWVzcGxheSIsCiAgICAgICJrbml0ciIsCiAgICAgICJicm9vbSIsCiAgICAgICJiYXllc3BsYXkiCiAgICApLAogICAgaW5zdGFsbCA9IFRSVUUKICApCn0pCgp0YWJsZV9mb3JtYXQgPC0gImh0bWwiCmBgYAojIE1vdmluZyBiZXlvbmQgY29pbiBmbGlwcwoKSW4gdGhlIHByZXZpb3VzIHNlY3Rpb24gKHNlZSBbQW4gYWx0ZXJuYXRpdmUgdG8gKnAqCnZhbHVlc10oYW4tYWx0ZXJuYXRpdmUtdG8tcC12YWx1ZXMuaHRtbCksIGFuZCBbVGhlIEJheWVzCmZhY3Rvcl0odGhlLWJheWVzLWZhY3Rvci5odG1sKSksIHdlIHdlcmUgaW50cm9kdWNlZCB0byB0aGUgY29uY2VwdCBvZiB0aGUKKipsaWtlbGlob29kKiouIEluIHRoZXNlIHNlY3Rpb25zLCB3ZSBzcGVjaWZpY2FsbHkgY292ZXJlZCB0aGUgKipiaW5vbWlhbCoqCmxpa2VsaWhvb2QsIHdoaWNoIGNhbiBiZSB1c2VkIGZvciB3b3JraW5nIG91dCBCYXllcyBmYWN0b3JzIGZvciBzYW1wbGVzIG9mCkJlcm5vdWxsaSB0cmlhbHMtLS10aGF0IGlzLCB0cmlhbHMgd2l0aCB0d28gZGlzY3JldGUgb3V0Y29tZXMgbGlrZSBoZWFkcyBhbmQKdGFpbHMgb3Igc3VjY2Vzc2VzIGFuZCBmYWlsdXJlcy4gV2UgdXNlZCB0aGlzIHNwZWNpZmljYWxseSBmb3IgY29tcHV0aW5nIG91cgpCYXllcyBmYWN0b3JzIGZvciBoeXBvdGhlc2VzIGFib3V0IGNvaW4gZmxpcHMuIEFsdGhvdWdoIHRoZXNlIEJheWVzIGZhY3RvcnMKY291bGQgYmUgdXNlZCBhbnl3aGVyZSB3aGVyZSB3ZSBtaWdodCBvcmRpbmFyaWx5IHVzZSBhIGZyZXF1ZW50aXN0ICoqYmlub21pYWwKdGVzdCoqIGl0IGlzIHN0aWxsIHJhdGhlciBsaW1pdGVkIGluIHNjb3BlLiBUaGVyZWZvcmUsIGluIHRoaXMgc2VjdGlvbiwgd2UnbGwKY292ZXIgQmF5ZXMgZmFjdG9ycyB0aGF0IGNhbiBiZSB1c2VkIGluIG90aGVyIHNpdHVhdGlvbnMuIFNwZWNpZmljYWxseSwgd2UnbGwKZm9jdXMgcHJpbWFyaWx5IG9uIHNpdHVhdGlvbnMgd2hlcmUgd2UncmUgaW50ZXJlc3RlZCBpbiAqKmRpZmZlcmVuY2VzIGJldHdlZW4KbWVhbnMqKi0tLXRoYXQgaXMsIHNpdHVhdGlvbnMgd2hlcmUgd2UgbWlnaHQgb3RoZXJ3aXNlIHVzZSBhICp0Ki10ZXN0IG9yIEFOT1ZBLgoKIyMgQ2hvb3NpbmcgYSBsaWtlbGlob29kCgpJbiBvdXIgaW5pdGlhbCBleGFtcGxlIG9uIGh1bnRpbmcgdHJlYXN1cmUgKHNlZSBbTnVsbCBoeXBvdGhlc2lzIHNpZ25pZmljYW5jZQp0ZXN0aW5nXShudWxsLWh5cG90aGVzaXMtc2lnbmlmaWNhbmNlLXRlc3RpbmcuaHRtbCkpIG91ciB0cmVhc3VyZSBodW50aW5nCmRldmljZSB3b3JrZWQgYnksIG9uIGF2ZXJhZ2UsIHBvaW50aW5nIGF0IDAgd2hlbiB0aGVyZSB3YXMgbm8gdHJlYXN1cmUKYXJvdW5kIGFuZCwgb24gYXZlcmFnZSwgcG9pbnRpbmcgYXQgc29tZSBvdGhlciB2YWx1ZSB3aGVuIHRoZXJlIHdhcyB0cmVhc3VyZQphcm91bmQuCgpUbyB3b3JrIG91dCB3aGV0aGVyIG91ciBkZXZpY2Ugd2FzLCBvbiBhdmVyYWdlLCBwb2ludGluZyBhdCBhIHBhcnRpY3VsYXIgdmFsdWUKd2UgY29sbGVjdGVkIGEgc2FtcGxlIG9mIGEgZml4ZWQgc2l6ZSAoMTAgaW4gb3VyIGZpcnN0IGV4YW1wbGUpIGFuZCB0aGVuIHdvcmtlZApvdXQgdGhlIGF2ZXJhZ2Ugb2YgdGhlc2UgdmFsdWVzLiBGb3IgZXhhbXBsZSwgd2UgbWlnaHQndmUgY29sbGVjdGVkIGEgc2FtcGxlIG9mCjEwIHZhbHVlcyBhcyBmb2xsb3dzOgoKYGBge3J9CnNldC5zZWVkKDEyMykKCnNhbXBsZV9zaXplIDwtIDEwCnNhbXBsZV9tZWFuIDwtIDAKc2FtcGxlX3NkIDwtIDI1CnNhbXBsZV9kYXRhIDwtIHJub3JtKG4gPSBzYW1wbGVfc2l6ZSwgbSA9IHNhbXBsZV9tZWFuLCBzZCA9IHNhbXBsZV9zZCkKCnBhc3RlMCgiKipTYW1wbGUgZGF0YSoqOiAiLCBwYXN0ZShyb3VuZChzYW1wbGVfZGF0YSwgMSksIGNvbGxhcHNlID0gIiwgIiksICIKCioqU2FtcGxlIG1lYW4qKjogIiwgcm91bmQobWVhbihzYW1wbGVfZGF0YSksIDIpKSAlPiUKICBkaXNwbGF5X21hcmtkb3duKCkKYGBgCgpBZnRlciBjb2xsZWN0aW5nIGEgbGFyZ2UgbnVtYmVyIG9mIHNhbXBsZXMsIHdlIGNvdWxkIHBsb3Qgb3VyIGF2ZXJhZ2VzIGFzCmZvbGxvd3M6CgpgYGB7cn0KCmdlbmVyYXRlX2RhdGEgPC0gZnVuY3Rpb24oc2l6ZSwgbWVhbiwgc2QsIHNhbXBsZXMpIHsKICBwdXJycjo6bWFwX2RmKDE6c2FtcGxlcywgZnVuY3Rpb24oeCkgewogICAgZGF0YSA8LSBybm9ybShzaXplLCBtZWFuLCBzZCkKICAgIHRpYmJsZTo6dGliYmxlKAogICAgICBtZWFuID0gbWVhbihkYXRhKSwKICAgICAgdCA9IG1lYW4gLyAoc2QoZGF0YSkgLyBzcXJ0KHNpemUpKSwKICAgICAgZCA9IG1lYW4gLyBzZChkYXRhKQogICAgKQogIH0pCn0KCgpzYW1wbGVfbWVhbnNfZGF0YSA8LSBnZW5lcmF0ZV9kYXRhKDEwLCAwLCAyNSwgMTAwMDApCnNhbXBsZV9tZWFuc19kYXRhX25vbnplcm8gPC0gZ2VuZXJhdGVfZGF0YSgxMCwgMTkuNiwgMjUsIDEwMDAwKQoKCmdlbmVyYXRlX3Bsb3QgPC0gZnVuY3Rpb24oZGF0YSkgewogIGRlbnNpdHlfcGxvdF9tZWFucyA8LSB0aWJibGUoeCA9IHNlcShtaW4oZGF0YSRtZWFuKSwKICAgIG1heChkYXRhJG1lYW4pLAogICAgbGVuZ3RoLm91dCA9IDEwMDAwCiAgKSkgJT4lCiAgICBtdXRhdGUoeSA9IHBvbHNwbGluZTo6ZGxvZ3NwbGluZSgKICAgICAgeCwKICAgICAgcG9sc3BsaW5lOjpsb2dzcGxpbmUoZGF0YSRtZWFuKQogICAgKSkKCiAgZGVuc2l0eV9wbG90X3RzIDwtIHRpYmJsZSh4ID0gc2VxKG1pbihkYXRhJHQpLAogICAgbWF4KGRhdGEkdCksCiAgICBsZW5ndGgub3V0ID0gMTAwMDAKICApKSAlPiUKICAgIG11dGF0ZSh5ID0gcG9sc3BsaW5lOjpkbG9nc3BsaW5lKAogICAgICB4LAogICAgICBwb2xzcGxpbmU6OmxvZ3NwbGluZShkYXRhJHQpCiAgICApKQoKICBkZW5zaXR5X3Bsb3RfZHMgPC0gdGliYmxlKHggPSBzZXEobWluKGRhdGEkZCksCiAgICBtYXgoZGF0YSRkKSwKICAgIGxlbmd0aC5vdXQgPSAxMDAwMAogICkpICU+JQogICAgbXV0YXRlKHkgPSBwb2xzcGxpbmU6OmRsb2dzcGxpbmUoCiAgICAgIHgsCiAgICAgIHBvbHNwbGluZTo6bG9nc3BsaW5lKGRhdGEkZCkKICAgICkpCgoKCiAgbWVhbl9wbG90IDwtIGdncGxvdCgpICsKICAgIGdlb21faGlzdG9ncmFtKAogICAgICBkYXRhID0gZGF0YSwKICAgICAgYWVzKHggPSBtZWFuLCB5ID0gLi5kZW5zaXR5Li4pLCBiaW5zID0gMzAsIG5hLnJtID0gVFJVRQogICAgKSArCiAgICBnZW9tX2xpbmUoCiAgICAgIGRhdGEgPSBkZW5zaXR5X3Bsb3RfbWVhbnMsIGFlcyh4ID0geCwgeSA9IHkpLCBzaXplID0gMSwKICAgICAgbmEucm0gPSBUUlVFCiAgICApICsKICAgIHRoZW1lX21pbmltYWwoMTQpICsKICAgIGxhYnMoeCA9ICLOvCIsIHkgPSAiRGVuc2l0eSIpICsKICAgIE5VTEwKCiAgdF9wbG90IDwtIGdncGxvdCgpICsKICAgIGdlb21faGlzdG9ncmFtKAogICAgICBkYXRhID0gZGF0YSwKICAgICAgYWVzKHggPSB0LCB5ID0gLi5kZW5zaXR5Li4pLCBiaW5zID0gMzAsIG5hLnJtID0gVFJVRSwKICAgICkgKwogICAgZ2VvbV9saW5lKAogICAgICBkYXRhID0gZGVuc2l0eV9wbG90X3RzLCBhZXMoeCA9IHgsIHkgPSB5KSwgc2l6ZSA9IDEsCiAgICAgIG5hLnJtID0gVFJVRQogICAgKSArCiAgICB0aGVtZV9taW5pbWFsKDE0KSArCiAgICBsYWJzKHggPSAidCIsIHkgPSAiRGVuc2l0eSIpICsKICAgIE5VTEwKCgogIGRfcGxvdCA8LSBnZ3Bsb3QoKSArCiAgICBnZW9tX2hpc3RvZ3JhbSgKICAgICAgZGF0YSA9IGRhdGEsCiAgICAgIGFlcyh4ID0gZCwgeSA9IC4uZGVuc2l0eS4uKSwgYmlucyA9IDMwLCBuYS5ybSA9IFRSVUUsCiAgICApICsKICAgIGdlb21fbGluZSgKICAgICAgZGF0YSA9IGRlbnNpdHlfcGxvdF9kcywgYWVzKHggPSB4LCB5ID0geSksIHNpemUgPSAxLAogICAgICBuYS5ybSA9IFRSVUUKICAgICkgKwogICAgdGhlbWVfbWluaW1hbCgxNCkgKwogICAgbGFicyh4ID0gIs60IiwgeSA9ICJEZW5zaXR5IikgKwogICAgTlVMTAoKICBsaXN0KG1lYW5fcGxvdCA9IG1lYW5fcGxvdCwgdF9wbG90ID0gdF9wbG90LCBkX3Bsb3QgPSBkX3Bsb3QpCn0KYGBgCgpgYGB7cn0KbGlzdCgKICBwbG90ID0gZ2VuZXJhdGVfcGxvdChzYW1wbGVfbWVhbnNfZGF0YSksCiAgbGltaXRzID0gbGlzdChjKC0zMCwgMzApLCBjKC00LCA0KSwgYygtMiwgMikpCikgJT4lCiAgcG1hcChmdW5jdGlvbihwbG90LCBsaW1pdHMpIHBsb3QgKyB4bGltKGxpbWl0cykpICU+JQogIHdyYXBfcGxvdHMobmNvbCA9IDMpICsgcGxvdF9hbm5vdGF0aW9uKHRhZ19sZXZlbCA9ICJBIikKYGBgCgpJbiB0aGUgYWJvdmUgZXhhbXBsZXMsIHdlJ3ZlIHNldCB0aGUgKnBhcmFtZXRlciogb2YgaW50ZXJlc3QgKHRoZSBtZWFuKSB0byAwLgpUaGUgYWJvdmUgcGxvdHMgYXJlIGp1c3QgZXhhbXBsZXMgb2YgdGhlIHNhbXBsaW5nIGRpc3RyaWJ1dGlvbiB3aGVuIHRoZQpwYXJhbWV0ZXIgaXMgMC4gUGFuZWwgKipBKiogc2hvd3MgdGhlIHNhbXBsaW5nIGRpc3RyaWJ1dGlvbiBvZiB0aGUgKnJhdyBtZWFucyouClBhbmVsICoqQioqIHNob3dzIHRoZSBzYW1wbGluZyBkaXN0cmlidXRpb24gb2YgdGhlIHJhdyBtZWFucyByZS1zY2FsZWQgdG8gKnQqCnZhbHVlcy4gRmluYWxseSwgcGFuZWwgKipDKiogc2hvd3MgdGhlIHNhbXBsaW5nIGRpc3RyaWJ1dGlvbiBvZiB0aGUgcmF3IG1lYW5zCnJlLXNjYWxlZCB0byAqQ29oZW4ncyBkKiB2YWx1ZXMgKHdoZXJlICRcZGVsdGEgPSBcZnJhY3tcbXV9e1xzaWdtYX0kKS4gQWxsCnRoZXNlIHBsb3RzIGFwcHJveGltYXRlbHkgZm9sbG93IHRoZSBzaGFwZSBvZiBhICpub3JtYWwgZGlzdHJpYnV0aW9uKiBvciBhCip0IGRpc3RyaWJ1dGlvbiouIFdlIGNvdWxkIHVzZSB0aGVzZSBwbG90cyB0byB3b3JrIG91dCAqcCogdmFsdWVzLCBqdXN0CmFzIHdlIHByZXZpb3VzbHkgZGlkLgoKQnV0LCBhcyB3ZSBkaWQgd2l0aCB0aGUgY29pbiBmbGlwIGV4YW1wbGVzLCB3aGVuIHdvcmtpbmcgd2l0aCAqbGlrZWxpaG9vZHMqLAp3ZSdyZSBpbnRlcmVzdGVkIGluIHRoZSBwcm9iYWJpbGl0eSBvZiBvYnRhaW5pbmcgb3VyIGRhdGEgdW5kZXIgZGlmZmVyZW50CnZhbHVlcyBvZiB0aGUgcGFyYW1ldGVyLiBUaGF0IGlzLCB3ZSBtdXN0IGNvbnNpZGVyIHRoZSBwcm9iYWJpbGl0eSBvZiBvYnRhaW5pbmcKb3VyIGN1cnJlbnQgZGF0YSBub3QganVzdCBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgcGFyYW1ldGVyIG9mIGludGVyZXN0IGlzIDAsIGJ1dAphbHNvIHdoZXJlIHRoZSBwYXJhbWV0ZXIgb2YgaW50ZXJlc3QgaXMgc29tZSBvdGhlciB2YWx1ZS4gRm9yIGV4YW1wbGUsIHRoZQpwbG90cyBiZWxvdyBoYXZlIGJlZW4gZ2VuZXJhdGVkIGJ5IHNldHRpbmcgdGhlIHBhcmFtZXRlciB2YWx1ZS0tdGhhdCBpcywgdGhlCnZhbHVlIHRvIHdoaWNoIHRoZSBkZXZpY2UsIG9uIGF2ZXJhZ2UgcG9pbnRzLS0tdG8gYSByYXcgbWVhbiBvZiBhcHByb3hpbWF0ZWx5CjE5LjYuIFdlJ3ZlIGFsc28gc2V0IHRoZSBhdmVyYWdlIHNwcmVhZCBvZiB0aGUgdmFsdWVzLS0tdGhhdCBpcywgdGhlIHN0YW5kYXJkCmRldmlhdGlvbi0tdG8gMjUuIENvbnNlcXVlbnRseSwgd2hlbiByZXNjYWxlZCB0byBhICp0KiB2YWx1ZSwgdGhpcyB3b3VsZCByZXN1bHQKaW4gYW4gYXZlcmFnZSAqdCogb2YgJFxmcmFjezE5LjZ9e1xmcmFjezI1fXtcc3FydHsxMH19fSQuIEFuZCB3aGVuIHJlc2NhbGVkIHRvCmEgKmQqIHZhbHVlLCB0aGlzIHdvdWxkIHJlc3VsdCBpbiBhbiBhdmVyYWdlICpkKiB2YWx1ZSBvZiAkXGZyYWN7MTkuNn17MjV9JC4KCmBgYHtyfQpsaXN0KAogIHBsb3QgPSBnZW5lcmF0ZV9wbG90KHNhbXBsZV9tZWFuc19kYXRhX25vbnplcm8pLAogIGxpbWl0cyA9IGxpc3QoYygtMTAsIDUwKSwgYygtMiwgOCksIGMoLTEsIDUpKQopICU+JQogIHBtYXAoZnVuY3Rpb24ocGxvdCwgbGltaXRzKSBwbG90ICsgeGxpbShsaW1pdHMpKSAlPiUKICB3cmFwX3Bsb3RzKG5jb2wgPSAzKSArIHBsb3RfYW5ub3RhdGlvbih0YWdfbGV2ZWwgPSAiQSIpCmBgYAoKRm9yIHRoZXNlIHBsb3RzLCBwYW5lbCAqKkEqKiBhZ2FpbiBzaG93cyB0aGUgKnJhdyBtZWFucyosIHdpdGggcGFuZWwgKipCKioKc2hvd2luZyB0aGUgKnQqIHZhbHVlcywgYW5kIHBhbmVsICoqQyoqIHNob3dpbmcgdGhlIENvaGVuJ3MgKmQqIHZhbHVlcy4gVGhlCmRpc3RyaWJ1dGlvbiBpbiBQYW5lbCAqKkEqKiBub3cgYXBwcm94aW1hdGVseSBmb2xsb3dzIHRoZSBzaGFwZSBvZiBhICpub3JtYWwKZGlzdHJpYnV0aW9uKiBvciBhICpzY2FsZWQgYW5kIHNoaWZ0ZWQgdCBkaXN0cmlidXRpb24qLiBQYW5lbCAqKkIqKiBhbmQgKipDKioKbm93IGZvbGxvdyB0aGUgc2hhcGUgb2Ygc2xpZ2h0bHkgZGlmZmVyZW50bHkgc2NhbGVkIHZlcnNpb25zIG9mIHRoZQoqbm9uLWNlbnRyYWwgdCBkaXN0cmlidXRpb24qLgoKSW4gdGhlIHNlY3Rpb24gdGhhdCBmb2xsb3dzLCB3ZSdsbCBkaXNjb3ZlciBhbmQgbGVhcm4gaG93IHRvIHVzZSB0aGVzZQpsaWtlbGlob29kczogVGhlICpub3JtYWwqIGxpa2VsaWhvb2QsIHRoZSAqc2NhbGVkIGFuZCBzaGlmdGVkIHQqIGxpa2VsaWhvb2QsCmFuZCB0aHJlZSB2ZXJzaW9ucyBvZiB0aGUgKm5vbi1jZW50cmFsIHQqIGxpa2VsaWhvb2QgKHdoaWNoIGBiYXllc3BsYXlgIGNhbGxzCnRoZSAqbm9uLWNlbnRyYWwgdCosICpub24tY2VudHJhbCBkKiwgYW5kICpub24tY2VudHJhbCBkMiogbGlrZWxpaG9vZHMpLgoKIyMjIFRoZSB2YXJpYW5jZSBvZiBsaWtlbGlob29kcwoKV2hlbiB3ZSB3ZXJlIGV4YW1pbmluZyBjb2luIGZsaXBzLCB3ZSBzYXcgdGhhdCB0aGUgc2FtcGxpbmcgZGlzdHJpYnV0aW9uIChpbgp0aGUgZmxpcCB1bnRpbCAqKm4qKiBmbGlwcyBjYXNlKSBmb2xsb3dlZCB0aGUgKmJpbm9taWFsIGRpc3RyaWJ1dGlvbiouIEFuZCB3aGVuCndlIHdhbnRlZCB0byBtYWtlIGluZmVyZW5jZXMgYWJvdXQgcGFyYW1ldGVyIHZhbHVlcyAodGhlIGNvaW4gYmlhcykgd2UgdXNlZCB0aGUKKmJpbm9taWFsKiBsaWtlbGlob29kLiBPdXIgZGF0YSwgd2hpY2ggd2UgdXNlZCB0byBtYWtlIG91ciBpbmZlcmVuY2UgY29uc2lzdGVkCm9mLCBmaXJzdCwgdGhlIG51bWJlciBvZiBoZWFkcyBhbmQsIHNlY29uZCwgdGhlIG51bWJlciBvZiBmbGlwcy4KClRoZXNlIHR3byB2YWx1ZXMgY29udHJvbGxlZCBkaWZmZXJlbnQgYXNwZWN0cyBvZiB0aGUgc2hhcGUgb2YgdGhlIGxpa2VsaWhvb2QKZnVuY3Rpb24uIEZpcnN0LCB0aGUgbnVtYmVyIG9mIGhlYWRzIHRoYXQgd2Ugb2JzZXJ2ZWQgbW9yZS1vci1sZXNzIGNvbnRyb2xsZWQKd2hlcmUgdGhlIHBlYWsgb2YgdGhlIGxpa2VsaWhvb2QgZnVuY3Rpb24gd2FzIGxvY2F0ZWQuIFNlY29uZCwgdGhlIG51bWJlciBvZgpmbGlwcywgb3IgdGhlIHNhbXBsZSBzaXplLCBjb250cm9sbGVkIGhvdyBzcHJlYWQgb3V0IHRoZSBsaWtlbGlob29kIGZ1bmN0aW9uCndhcy4gSW4gdGhlIHBsb3RzIGJlbG93IHdlIGNhbiBzZWUgdGhyZWUgY2FzZXMgb2Ygb2JzZXJ2aW5nICRcZnJhY3tufXsyfSQgaGVhZHMKaW4gMiwgMjAsIGFuZCAxMDAgZmxpcHMuIEluIGFsbCB0aHJlZSBwbG90cywgdGhlIGxpa2VsaWhvb2QgZnVuY3Rpb24gaXMgcGVha2VkCmF0IDAuNSBhbmQgZHJvcHMgb2ZmIGFzIHdlIG1vdmUgYXdheSBmcm9tIDAuNS4gVGhlIHJhdGUgb2YgdGhpcyBkcm9wIG9mZiwKaG93ZXZlciwgaXMgc3RlZXBlciBhcyB0aGUgc2FtcGxlIHNpemUgaW5jcmVhc2VzLgoKYGBge3J9Cmxpa2VsaWhvb2RzIDwtIGMoCiAgbGlrZWxpaG9vZCgiYmlub21pYWwiLCAyIC8gMiwgMiksCiAgbGlrZWxpaG9vZCgiYmlub21pYWwiLCAyMCAvIDIsIDIwKSwKICBsaWtlbGlob29kKCJiaW5vbWlhbCIsIDEwMCAvIDIsIDEwMCkKKQoKKG1hcChsaWtlbGlob29kcywgZnVuY3Rpb24oeCkgewogIHBsb3QoeCkgKwogICAgdGhlbWVfbWluaW1hbCgxNCkgKwogICAgZ2VvbV92bGluZSh4aW50ZXJjZXB0ID0gMC44LCBsaW5ldHlwZSA9IDIpICsKICAgIHNjYWxlX3hfY29udGludW91cygKICAgICAgYnJlYWtzID0gYygwLCAwLjIsIC41LCAwLjgsIDEpLAogICAgICBsaW1pdHMgPSBjKDAsIDEpCiAgICApICsKICAgIGxhYnMoc3VidGl0bGUgPSBnbHVlOjpnbHVlKAogICAgICAie3gkcGFyYW1ldGVyc1tbMV1dfSBoZWFkcyBpbiB7eCRwYXJhbWV0ZXJzW1syXV19IgogICAgKSkKfSkgJT4lCiAgd3JhcF9wbG90cyhuY29sID0gMykgKyBwbG90X2Fubm90YXRpb24odGFnX2xldmVsID0gIkEiKSkgJT4lIHNob3coKQpgYGAKCldoYXQgaXMgdGhlIGltcG9ydGFudCBpbnR1aXRpb24gaGVyZT8gVG8gZ2V0IGEgaGFuZGxlIG9uIHRoZSBpbnR1aXRpb24gd2UgY2FuCnRoaW5rIG9mIHRoZSBleHRyZW1lIGNhc2VzLiBXaGVuIHRoZSBjb2luIGlzIHZlcnkgYmlhc2VkLS0tZm9yIGV4YW1wbGUsIGl0CnNob3dzIGhlYWRzIDAuOCBvZiB0aGUgdGltZS0tLXRoZW4gaXQgd2lsbCBzdGlsbCBzb21ldGltZXMgc2hvdyB0YWlscy4gSXQgbWlnaHQKZXZlbiBzb21ldGltZXMgc2hvdyB0YWlscyBvbiB0aGUgZmlyc3QgZmxpcC4gSW4gZmFjdCwgaXQnbGwgc2hvdyB0YWlscyBvbiB0aGUKZmlyc3QgZmxpcCAwLjIgb2YgdGhlIHRpbWUuIFRoZXJlZm9yZSwgd2Ugd291bGRuJ3QgYmUgdGhhdCBzdXJwcmlzZWQgaWYgYWZ0ZXIKdHdvIGZsaXBzIHdlIGhhdmUgb25lIGhlYWQgYW5kIG9uZSB0YWlsLCBiZWNhdXNlIGl0IHdvbid0IGJlIHN1Y2ggYW4gdW5jb21tb24Kb2NjdXJyZW5jZS4gQnV0IGluIHRoZSBzaXR1YXRpb24gd2hlcmUgd2UncmUgbWFraW5nIDEwMCBmbGlwcywgaXQgbm93IGJlY29tZXMKbW9yZSBhbmQgbW9yZSB1bmxpa2VseSB0aGF0IHdlJ2Qgc2VlIGVxdWFsIG51bWJlcnMgb2YgaGVhZHMgYW5kIHRhaWxzIGlmIHRoZQpjb2luIGJpYXMgcmVhbGx5IHdhcyAwLjguIFdlIGNhbiBwdXQgbnVtYmVycyB0byBpdCBieSBjYWxjdWxhdGluZyB0aGUKbGlrZWxpaG9vZCByYXRpbyBiZXR3ZWVuIDAuNSBhbmQgMC44IGZvciBlYWNoIG9mIHRoZSB0aHJlZSBzYW1wbGUgc2l6ZXMuCgpgYGB7cn0KCm1hcF9kZihsaWtlbGlob29kcywgZnVuY3Rpb24oeCkgewogIHRpYmJsZSgKICAgIGxyID0geCRsaWtlbGlob29kX2Z1bmN0aW9uKDAuNSkgLyB4JGxpa2VsaWhvb2RfZnVuY3Rpb24oMC44KSwKICAgIHRyaWFscyA9IHgkcGFyYW1ldGVycyR0cmlhbHMKICApCn0pICU+JQogIGdsdWU6OmdsdWVfZGF0YSgiV2hlbiB0aGVyZSBhcmUge3RyaWFsc30gdHJpYWxzLCB0aGUgbGlrZWxpaG9vZCByYXRpbwpiZXR3ZWVuIM64ID0gMC41IGFuZCDOuCA9IDAuOCBpcyB7cm91bmQobHIsMil9LlxuXG5cbiIpICU+JQogIHBhc3RlMCguLCBjb2xsYXBzZSA9ICJcbiIpICU+JQogIGRpc3BsYXlfbWFya2Rvd24oKQpgYGAKCkZvciBhbGwgdGhlIGxpa2VsaWhvb2RzIHRoYXQgd2UnbGwgZXhhbWluZSBpbiB0aGlzIHNlY3Rpb24sIHdoZW4gZGVmaW5pbmcgdGhlCmxpa2VsaWhvb2RzIHdlJ2xsIGhhdmUgb25lIHZhbHVlIHRoYXQgcmVwcmVzZW50cyBvdXIgb2JzZXJ2YXRpb246IHRoZSBtZWFuIHdlCm9ic2VydmUsIHRoZSAqdCogdmFsdWUgd2Ugb2JzZXJ2ZSwgb3IgdGhlICpkKiB2YWx1ZSB3ZSBvYnNlcnZlLiBUaGlzIHdpbGwgYmUKYW5hbG9nb3VzIHRvIHRoZSBudW1iZXIgb2YgaGVhZHMgd2Ugb2JzZXJ2ZSBpbiB0aGUgY29pbiBmbGlwIGV4YW1wbGUuIEFuZCB3ZSdsbApoYXZlIGEgdmFsdWUgKG9yIHZhbHVlcykgdGhhdCBkZWZpbmVzIGhvdyBwZWFrZWQgb3Igc3ByZWFkIG91dCB0aGUgbGlrZWxpaG9vZAp3aWxsIGJlOiB0aGlzIGNvdWxkIGJlIHRoZSBzYW1wbGUgc2l6ZSwgdGhlIGRlZ3JlZXMgb2YgZnJlZWRvbSBhbmQvb3Igc3RhbmRhcmQKZGV2aWF0aW9uLiAKCkluIG1vcmUgdGVjaG5pY2FsIHRlcm1zLCBhbGwgdGhlIGxpa2VsaWhvb2RzIHRoYXQgd2UnbGwgZXhhbWluZSB3aWxsIGhhdmUgb25lCnBhcmFtZXRlciB0aGF0IHdlJ3JlIG1ha2luZyBpbmZlcmVuY2VzIGFib3V0OiB0aGUgKm1lYW4qLCB0aGUgKnQqIHZhbHVlLCBvciB0aGUKKmQqIHZhbHVlLiBCdXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBhbHNvIGhhdmUgYSAqdmFyaWFuY2UqIGFzc29jaWF0ZWQgd2l0aCBpdC4KQW5kIGFzIHdlJ2xsIHNlZSBpbiB0aGUgZXhhbXBsZXMgYmVsb3csIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIGludGVyZXN0ZWQKaW4gKnJhdyBtZWFucyosKnQqIHZhbHVlcywgb3IgKmQqIHZhbHVlcywgdGhlIHNhbXBsaW5nIGRpc3RyaWJ1dGlvbnMgYXJlCnNsaWdodGx5IGRpZmZlcmVudCBzaGFwZXMuIFRoZXJlZm9yZSwgdGhlICpsaWtlbGlob29kcyogdGhhdCB3ZSB1c2UgaW4gZWFjaApjYXNlIHdpbGwgYmUgc2xpZ2h0bHkgZGlmZmVyZW50LiBXZSdsbCBsb29rIGF0IGVhY2ggb2YgdGhlc2UgaW4gdHVybi4KCiMjIEluZmVyZW5jZXMgYWJvdXQgcmF3IG1lYW5zCgpXaGVuIHdlJ3JlIGludGVyZXN0ZWQgaW4gbWFraW5nIGluZmVyZW5jZXMgYWJvdXQgdGhlICpyYXcgbWVhbnMqIHdlIGhhdmUgdHdvCmNob2ljZXMgYXZhaWxhYmxlIHRvIHVzLiBUaGUgbW9zdCBzdHJhaWdodGZvcndhcmQgY2hvaWNlIGlzIHRvIGNob29zZSB0aGUKKm5vcm1hbCogbGlrZWxpaG9vZC4gVGhlIHNoYXBlIG9mIHRoZSAqbm9ybWFsKiBsaWtlbGlob29kIGlzIGNvbnRyb2xsZWQgYnkKKip0d28qKiB2YWx1ZXMuIFRoZSBmaXJzdCB2YWx1ZSBpcyBvdXIgKipvYnNlcnZlZCBtZWFuKiouIFRoaXMgdmFsdWUgY29udHJvbHMKdGhlIGxvY2F0aW9uIG9mIHRoZSBwZWFrIG9mIHRoZSBsaWtlbGlob29kIGZ1bmN0aW9uLiBUaGUgc2Vjb25kIHZhbHVlIGlzIHRoZQoqKnN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgbWVhbioqLiAgVGhlICoqc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBtZWFuKiogaXMKbW9yZSBjb21tb25seSBrbm93biBhcyB0aGUgKipzdGFuZGFyZCBlcnJvciBvZiB0aGUgbWVhbioqLiBXZSBjYW4gd29yayBvdXQgdGhlCipzdGFuZGFyZCBlcnJvciogdXNpbmcgdGhlIGZvbGxvd2luZyBmb3JtdWxhOgoKJCRcc2lnbWFfe1xiYXJ7eH19ID0gXGZyYWN7XHNpZ21hfXtcc3FydHtufX0sJCQKCndoZXJlICRcc2lnbWEkIGlzIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIHBvcHVsYXRpb24uIFVzdWFsbHksIHdlIGRvbid0Cmtub3cgdGhlIHZhbHVlIG9mICRcc2lnbWEkLCBzbyB3ZSBlc3RpbWF0ZSBpdCB1c2luZyAkcyQsIG9yIHRoZSBzdGFuZGFyZApkZXZpYXRpb24gb2Ygb3VyIHNhbXBsZS4KClRvIHNlZSBob3cgZGVmaW5pbmcgYSAqbm9ybWFsKiBsaWtlbGlob29kIHdvcmtzIGluIHByYWN0aWNlLCB3ZSdsbCBnZW5lcmF0ZSBvdXIKZGF0YS4gRnJvbSB0aGlzLCB3ZSdsbCB3b3JrIG91dCB0aGUgbWVhbiBvZiBvdXIgc2FtcGxlLCBhbmQgd2UnbGwgZXN0aW1hdGUgdGhlCnN0YW5kYXJkIGVycm9yICh0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBtZWFuKS4KClRvIGdlbmVyYXRlIG91ciBkYXRhLCB3ZSdsbCBzZXQgdXAgYSBkYXRhIGdlbmVyYXRpbmcgcHJvY2VzcyAoeW91IGNhbiB0aGluayBvZgp0aGlzIGFzICoqdGhlIHBvcHVsYXRpb24qKikgYW5kIHdlJ2xsIGRyYXcgYSBzYW1wbGUgb2YgMTAgdmFsdWVzIGZyb20gdGhpcy4gT3VyCmRhdGEgZ2VuZXJhdGluZyBwcm9jZXNzIHdpbGwgaGF2ZSBhICRcbXUkIChtZWFuIG9mIHRoZSBwb3B1bGF0aW9uKSBvZiAxOS42LCBhbmQKYSAkXHNpZ21hJCAoc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBwb3B1bGF0aW9uKSBvZiAyNS4KCgpgYGB7cn0KCnNldC5zZWVkKDEyMykKc2FtcGxlX2RhdGEgPC0gcm5vcm0obiA9IDEwLCBtZWFuID0gMTkuNiwgc2QgPSAyNSkKCmdsdWU6OmdsdWUoIioqU2FtcGxlIGRhdGEqKjoge3Bhc3RlKHJvdW5kKHNhbXBsZV9kYXRhLCAyKSwgY29sbGFwc2UgPSAnLCAnKX0KCioqTWVhbiBvZiBzYW1wbGUqKjoge3JvdW5kKG1lYW4oc2FtcGxlX2RhdGEpLCAyKX0KCgoqKlN0YW5kYXJkIGRldmlhdGlvbiBvZiBzYW1wbGUqKjoge3JvdW5kKHNkKHNhbXBsZV9kYXRhKSwgMil9CgoKKipTaXplIG9mIHNhbXBsZSoqOiB7cm91bmQobGVuZ3RoKHNhbXBsZV9kYXRhKSwgMil9CgoqKlN0YW5kYXJkIGRldmlhdGlvbiBvZiBzYW1wbGluZyBkaXN0cmlidXRpb24gKHN0YW5kYXJkIGVycm9yKSoqOiB7cm91bmQoc2Qoc2FtcGxlX2RhdGEpL3NxcnQobGVuZ3RoKHNhbXBsZV9kYXRhKSkgLDIpfQoiKSAlPiUKICBkaXNwbGF5X21hcmtkb3duKCkKYGBgCgpOb3RlIHRoYXQgdGhlIHR3byB2YWx1ZXMgdGhhdCB3ZSB3YW50IGFyZSB0aGUgKm1lYW4gb2YgdGhlIHNhbXBsZSogYW5kIHRoZQoqc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBtZWFuKi4gQSBjb21tb24gY29uZnVzaW9uIGlzIHRoYXQgeW91IHdhbnQgdGhlCipzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIHNhbXBsZSouIFRoaXMgaXMgbm90IHRoZSB2YWx1ZSB0aGF0IHdlIHdhbnQsIGFuZCB3ZQpvbmx5IGNhbGN1bGF0ZSBpdCBiZWNhdXNlIHdlIGNhbiB1c2UgaXQgdG8gZXN0aW1hdGUgdGhlICpzdGFuZGFyZCBkZXZpYXRpb24gb2YKdGhlIHBvcHVsYXRpb24qIGFuZCwgZnJvbSB0aGlzLCB0aGUgKnN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgbWVhbiouCgpOb3cgd2UgY2FuIGRlZmluZSB0aGUgbGlrZWxpaG9vZCwgYW5kIHdlIGNhbiBwbG90IGl0LgoKYGBge3J9CiN8IGVjaG8gPSBUUlVFLCBpbmNsdWRlID0gVFJVRQpkYXRhX21vZGVsIDwtIGxpa2VsaWhvb2QoCiAgZmFtaWx5ID0gIm5vcm1hbCIsCiAgbWVhbiA9IDIxLjQ3LAogIHNkID0gNy41NAopCgpwbG90KGRhdGFfbW9kZWwpICsKICBsYWJzKHRpdGxlID0gImxpa2VsaWhvb2QgZm9yIG1lYW4gPSAyMS40NyAobm9ybWFsKSIpICsKICB4bGltKC0xMCwgNTApICsKICB0aGVtZV9taW5pbWFsKDE0KQpgYGAKCkZyb20gb3VyIGxpa2VsaWhvb2QgcGxvdCB3ZSBjYW4gc2VlIHRoYXQgb3VyIGRhdGEgd291bGQgYmUgZ2VuZXJhdGVkIG1vcmUgb2Z0ZW4KaWYgdGhlIG1lYW4gb2YgdGhlIGRhdGEgZ2VuZXJhdGluZyBwcm9jZXNzIHdhcyAyMSBhbmQgbGVzcyBvZnRlbiBpZiB0aGUgbWVhbiBvZgp0aGUgZGF0YSBnZW5lcmF0aW5nIHByb2Nlc3Mgd2FzIDMwLgoKSW4gZmFjdCwgd2UgY2FuIHB1dCBhIG51bWJlciB0byBpdCBhbmQgc2F5IHRoYXQ6CgpgYGB7cn0KCmxpa2VsaWhvb2RfcmF0aW9fbiA8LSBkYXRhX21vZGVsJGxpa2VsaWhvb2RfZnVuY3Rpb24oMjEpIC8KICBkYXRhX21vZGVsJGxpa2VsaWhvb2RfZnVuY3Rpb24oMzApCgpnbHVlOjpnbHVlKCJUaGUgZGF0YSB3b3VsZCBiZSBwcm9kdWNlZCB7cm91bmQobGlrZWxpaG9vZF9yYXRpb19uLCAyKX0gdGltZXMgbW9yZQpvZnRlbiBpZiB0aGUgbWVhbiBvZiB0aGUgcG9wdWxhdGlvbiB3YXMgMjEgdGhhbiBpdCB3b3VsZCBiZSBpZiB0aGUgbWVhbiBvZiB0aGUKcG9wdWxhdGlvbiB3YXMgMzAuIikgJT4lCiAgZGlzcGxheV9tYXJrZG93bigpCmBgYAoKVGhlIGxpa2VsaWhvb2QgZnVuY3Rpb24gd2lsbCBnZXQgd2lkZXIgb3IgbmFycm93ZXIgd2hlbiB0aGUgKnN0YW5kYXJkIGRldmlhdGlvbgpvZiB0aGUgbWVhbiogY2hhbmdlcy4gVGhlIHR3byBmYWN0b3JzIHRoYXQgY29udHJvbCB0aGUgKnN0YW5kYXJkIGRldmlhdGlvbiBvZgp0aGUgbWVhbiogYXJlIHRoZSBzYW1wbGUgc2l6ZSBhbmQgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgcG9wdWxhdGlvbi4gSW4KdGhlIGV4YW1wbGUgYmVsb3cgd2UnbGwga2VlcCBvdXIgZXN0aW1hdGUgb2YgdGhlICpzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlCnBvcHVsYXRpb24qIHRoZSBzYW1lIGJ1dCB3ZSdsbCBpbmNyZWFzZSB0aGUgc2FtcGxlIHNpemUuIENvbnNlcXVlbnRseSwgdGhlCipzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIG1lYW4qIHdpbGwgZGVjcmVhc2UgYW5kIG91ciBsaWtlbGlob29kIGZ1bmN0aW9uIHdpbGwKYmVjb21lIG5hcnJvd2VyLgoKYGBge3J9CiN8IGVjaG8gPSBUUlVFLCBpbmNsdWRlID0gVFJVRQoKZGF0YV9tb2RlbCA8LSBsaWtlbGlob29kKAogIGZhbWlseSA9ICJub3JtYWwiLAogIG1lYW4gPSAyMS40NywKICBzZCA9IDIuMzg0CikKCnBsb3QoZGF0YV9tb2RlbCkgKwogIGxhYnModGl0bGUgPSAibGlrZWxpaG9vZCBmb3IgbWVhbiA9IDIxLjQ3IikgKwogIHhsaW0oLTEwLCA1MCkgKwogIHRoZW1lX21pbmltYWwoMTQpCmBgYAoKQW5kIHRoaXMgd291bGQgYWxzbyBtYWtlIGEgY2hhbmdlIHRvIGFueSBsaWtlbGlob29kIHJhdGlvIHdlIGNvdWxkIGNhbGN1bGF0ZS4KRm9yIGV4YW1wbGUsIGNhbGN1bGF0aW5nIHRoZSBuZXcgbGlrZWxpaG9vZCByYXRpbyBjb21wYXJpbmcgJFxtdSA9IDMwJCBhbmQgJFxtdQo9IDIxJCB3b3VsZCBnaXZlIHRoZSBmb2xsb3dpbmcgcmVzdWx0OgoKYGBge3J9Cmxpa2VsaWhvb2RfcmF0aW8gPC0gZGF0YV9tb2RlbCRsaWtlbGlob29kX2Z1bmN0aW9uKDIxKSAvCiAgZGF0YV9tb2RlbCRsaWtlbGlob29kX2Z1bmN0aW9uKDMwKQoKZ2x1ZTo6Z2x1ZSgiVGhlIGRhdGEgd291bGQgYmUgcHJvZHVjZWQge3JvdW5kKGxpa2VsaWhvb2RfcmF0aW8sIDIpfSB0aW1lcyBtb3JlCm9mdGVuIGlmIHRoZSBtZWFuIG9mIHRoZSBwb3B1bGF0aW9uIHdhcyAyMSB0aGFuIGl0IHdvdWxkIGJlIGlmIHRoZSBtZWFuIG9mIHRoZQpwb3B1bGF0aW9uIHdhcyAzMC4iKSAlPiUKICBkaXNwbGF5X21hcmtkb3duKCkKYGBgCgpJbiB0aGUgcHJlY2VkaW5nIGV4YW1wbGVzLCB3ZSB3ZXJlIG1vZGVsbGluZyBvdXIgZGF0YSB3aXRoIGEgKm5vcm1hbCoKbGlrZWxpaG9vZC4gQW5kIHdlIHdlcmUgZXN0aW1hdGluZyB0aGUgKnN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgbWVhbiogdXNpbmcKdGhlICpzdGFuZGFyZCBkZXZpYXRpb24gb2Ygb3VyIHNhbXBsZSouIFdlIGRpZCB0aGlzLCBiZWNhdXNlIHdlIGRpZG4ndCBrbm93IHRoZQphY3R1YWwgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIG91ciBkYXRhIGdlbmVyYXRpbmcgcHJvY2Vzcy4gV2UnZCBuZWVkIHRvIGtub3cKdGhpcyB2YWx1ZSBpZiB3ZSB3YW50ZWQgdG8gZXhhY3RseSBjYWxjdWxhdGUgdGhlICpzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlCm1lYW4qLgoKT3IgYXQgbGVhc3QsIHdlIG9yZGluYXJpbHkgZG9uJ3Qga25vdyB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIG91ciBkYXRhCmdlbmVyYXRpbmcgcHJvY2Vzcy4gSG93ZXZlciwgYmVjYXVzZSBJIHNldCBpdCB1cCwgSSBrbm93IGl0IGlzIDI1LCBiZWNhdXNlIHRoaXMKaXMgdGhlIHZhbHVlIEkgc2V0IGl0IHRvLiBUaGVyZWZvcmUsIG91ciBlc3RpbWF0ZSB3YXMgYW4gdW5kZXIgZXN0aW1hdGUuClR5cGljYWxseSwgd2UnbGwgdW5kZXJlc3RpbWF0ZSB0aGUgKnN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgcG9wdWxhdGlvbiouClRoZXNlIHVuZGVyLWVzdGltYXRlcyB3aWxsIGJlIHdvcnNlIHdoZW4gdGhlIHNhbXBsZSBzaXplIGlzIHNtYWxsLiBBcyBvdXIKc2FtcGxlIHNpemUgaW5jcmVhc2VzIHRoZW4gdGhlIHR3byB2YWx1ZXMgd2lsbCwgYnkgZGVmaW5pdGlvbiwgbWF0Y2guCgpUaGVyZSBhcmUgYSBmZXcgYXBwcm9hY2hlcyB0aGF0IHdlIGNhbiB0YWtlIHRvIGRlYWxpbmcgd2l0aCB0aGlzIGlzc3VlLiBGaXJzdCwKd2UgY2FuIGp1c3QgZG8gbm90aGluZy4gVGhpcyBpcyB0aGUgbW9zdCBzdHJhaWdodGZvcndhcmQgYXBwcm9hY2gsIGFuZCBpdCBpcwphbHNvIGEgdmVyeSBjb21tb24gYXBwcm9hY2guIFRoZSBzZWNvbmQgYXBwcm9hY2gsIGlzIHRvIGFwcGx5IGEgY29ycmVjdGlvbiBhcwpmb2xsb3dzOgoKJCRzX3tcYmFye3h9fSA9IFxmcmFje3N9e1xzcXJ0e259fSBcdGltZXMgXGxlZnQoMSArIFxmcmFjezIwfXtcbWF0aHJte2RmfV4yfVxyaWdodCksJCQKCndoZXJlICRcbWF0aHJte2RmfSQgYXJlIHRoZSBkZWdyZWVzIG9mIGZyZWVkb20gZm9yIHRoZSBjb3JyZXNwb25kaW5nICp0KiB0ZXN0LgpbRGllbmVzICgyMDE0LCBwIDExKV0oaHR0cDovL2R4LmRvaS5vcmcvMTAuMzM4OS9mcHN5Zy4yMDE0LjAwNzgxKSBwcm92aWRlcwptb3JlIGRldGFpbHMgb24gdGhpcyBhcHByb2FjaC4gRGllbmVzICgyMDE0KSBhbHNvIHByb3ZpZGVzIGdvb2QgZ3VpZGFuY2Ugb24KdXNpbmcgQmF5ZXMgZmFjdG9ycywgYW5kIEkgd291bGQgcmVjb21tZW5kIHJlYWRpbmcgaXQgZm9yIHRoZSBhc3Nlc3NtZW50LgoKRmluYWxseSwgdGhlIHRoaXJkIGFwcHJvYWNoLCBpcyB0byBlbXBsb3kgYSAqc2NhbGVkIGFuZCBzaGlmdGVkIHQgbGlrZWxpaG9vZCoKaW5zdGVhZCBvZiBhICpub3JtYWwgbGlrZWxpaG9vZCouIFRoZSAqc2NhbGVkIGFuZCBzaGlmdGVkIHQgbGlrZWxpaG9vZCogaGFzCmZhdHRlciB0YWlscyB0aGFuIHRoZSAqbm9ybWFsIGxpa2VsaWhvb2QqLCB3aGljaCBhY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBvdXIKKm5vcm1hbCBsaWtlbGlob29kKiB0ZW5kcyB0byBiZSBuYXJyb3dlciB0aGFuIGl0IG91Z2h0IHRvIGJlLgoKSW4gYGJheWVzcGxheWAgd2UgY2FuIHVzZSB0aGUgKnNjYWxlZCBhbmQgc2hpZnRlZCB0IGxpa2VsaWhvb2QqIGJ5IHNldHRpbmcgdGhlCmxpa2VsaWhvb2QgKipmYW1pbHkqKiB0byAqKnN0dWRlbnRfdCoqLiBXaGVuIHVzaW5nIHRoaXMgbGlrZWxpaG9vZCwgb25lCmFkZGl0aW9uYWwgdmFsdWUgd2lsbCBuZWVkIHRvIGJlIHNldC4gVGhpcyBpcyB0aGUgKipkZioqIHZhbHVlLCB3aGljaCBpcyB0aGUgCnNhbWUgYXMgdGhlICoqZGYqKiB2YWx1ZSB0aGF0IHdlIHdvdWxkIHVzZSBmb3IgdGhlIGNvcnJlY3Rpb24gYXBwcm9hY2ggYWJvdmUuCgpXZSdsbCByZWNvbXB1dGUgb3VyIHByZXZpb3VzIGV4YW1wbGUgdXNpbmcgdGhpcyBsaWtlbGlob29kIGZhbWlseS4KCmBgYHtyfQojfCBlY2hvID0gVFJVRSwgaW5jbHVkZSA9IFRSVUUKZGF0YV9tb2RlbCA8LSBsaWtlbGlob29kKAogIGZhbWlseSA9ICJzdHVkZW50X3QiLAogIG1lYW4gPSAyMS40NywKICBzZCA9IDcuNTQsCiAgZGYgPSA5CikKCnBsb3QoZGF0YV9tb2RlbCkgKwogIGxhYnModGl0bGUgPSAibGlrZWxpaG9vZCBmb3IgbWVhbiA9IDIxLjQ3IChzdHVkZW50IHQpIikgKwogIHhsaW0oLTEwLCA1MCkgKwogIHRoZW1lX21pbmltYWwoMTQpCmBgYAoKQXMgeW91IGNhbiBzZWUgdGhlIHR3byBsaWtlbGlob29kIGZ1bmN0aW9ucyBsb29rIHZlcnkgc2ltaWxhci4KCmBgYHtyfQpsaWtlbGlob29kX3JhdGlvX3QgPC0gZGF0YV9tb2RlbCRsaWtlbGlob29kX2Z1bmN0aW9uKDIxKSAvCiAgZGF0YV9tb2RlbCRsaWtlbGlob29kX2Z1bmN0aW9uKDMwKQoKZ2x1ZTo6Z2x1ZSgiVGhlIGRhdGEgd291bGQgYmUgcHJvZHVjZWQge3JvdW5kKGxpa2VsaWhvb2RfcmF0aW9fdCwgMil9IHRpbWVzIG1vcmUKb2Z0ZW4gaWYgdGhlIG1lYW4gb2YgdGhlIHBvcHVsYXRpb24gd2FzIDIxIHRoYW4gaXQgd291bGQgYmUgaWYgdGhlIG1lYW4gb2YgdGhlCnBvcHVsYXRpb24gd2FzIDMwLiIpICU+JQogIGRpc3BsYXlfbWFya2Rvd24oKQpgYGAKClRoaXMgbGlrZWxpaG9vZCByYXRpb3MgYXJlIGFsc28gdmVyeSBzaW1pbGFyLgoKYGBge3J9Cmxpa2VsaWhvb2RfcmF0aW9fZGlmZiA8LSBhYnMobGlrZWxpaG9vZF9yYXRpb190IC0gbGlrZWxpaG9vZF9yYXRpb19uKQoKZ2x1ZTo6Z2x1ZSgiVGhlIGRpZmZlcmVuY2UgaW4gdGhlIGxpa2VsaWhvb2QgcmF0aW8gYmV0d2VlbiB0aGUgKm5vcm1hbCoKbGlrZWxpaG9vZCBhbmQgdGhlICpzdHVkZW50X3QqIGxpa2VsaWhvb2QgaXMgYWJvdXQKe3JvdW5kKGxpa2VsaWhvb2RfcmF0aW9fZGlmZiwyKX0iKSAlPiUKICBkaXNwbGF5X21hcmtkb3duKCkKYGBgCgoKIyMgSW5mZXJlbmNlcyBhYm91dCBlZmZlY3Qgc2l6ZXMKCkEgdmVyeSBwb3B1bGFyIGFsdGVybmF0aXZlIGFwcHJvYWNoIHRvIG1vZGVsbGluZyBkYXRhIGluIHRlcm1zIG9mIHRoZSBvYnNlcnZlZAptZWFuIGlzIHRvIGluc3RlYWQgbW9kZWwgZGF0YSBpbiB0ZXJtcyBvZiBzdGFuZGFyZGl6ZWQgZWZmZWN0IHNpemVzIG9uIHRoZSByYXcKbWVhbnMgdGhlbXNlbHZlcy4gVGhpcyBnZXRzIGFyb3VuZCB0aGUgcHJvYmxlbSBvZiB0aGUgdW5rbm93biB2YXJpYW5jZTsKaG93ZXZlciwgaXQgaGFzIGFuIGFkZGVkIGJlbmVmaXQgaW4gdGhhdCBpdCBjYW4gcGxhY2UgcmVzdWx0cyBmcm9tIHZlcnkKZGlmZmVyZW50IGV4cGVyaW1lbnRzIG9uIGEgY29tbW9uIHNjYWxlLiBGb3IgZXhhbXBsZSwgcmVzdWx0cyBmcm9tIGEgc3R1ZHkgb2YKcmVhY3Rpb24gdGltZXMgbWlnaHQgaGF2ZSB2YWx1ZXMgYmV0d2VlbiA1MDAgYW5kIDIwMDAgbXMgYW5kIHJlc3VsdHMgZnJvbSBhCnN0dWR5IG9uIHRlc3Qgc2NvcmVzIG1pZ2h0IGhhdmUgdmFsdWVzIHRoYXQgcmFuZ2UgYmV0d2VlbiA0MCBhbmQgOTAuIEJ5CnJlLXNjYWxpbmcgbWVhbiB2YWx1ZXMgdG8gKnN0YW5kYXJkaXNlZCBtZWFucyotLS10aGF0IGlzLCB0byBlZmZlY3Qgc2l6ZXMtLS13ZQpjYW4gYmUgbW9yZSBjZXJ0YWluIHRoYXQgdmFsdWVzIHdpbGwgZmFsbCBzb21ld2hlcmUgYmV0d2VlbiAtMTAgLyAxMCwgYW5kIG1vcmUKdHlwaWNhbGx5IGJldHdlZW4gLTEvMS4gV2hlbiB3ZSB0YWxrIG1vcmUgYWJvdXQgcHJpb3JzLCB3ZSdsbCBzZWUgdGhhdCB0aGlzCnJlc2NhbGluZyB3aWxsIGhlbHAgdXMgdG8gY29tZSB1cCB3aXRoIHByaW9ycyB0aGF0IHdpbGwgd29yayBpbiBhIHdpZGUgcmFuZ2Ugb2YKc2V0dGluZ3MgYW5kIHdpdGggYSB3aWRlIHJhbmdlIG9mIGV4cGVyaW1lbnRzIGFuZCB0eXBlcyBvZiBkYXRhLiBIb3dldmVyLCB3ZSdsbAphbHNvIHNlZSB0aGF0IHdoZW4gd2Ugd2FudCB0byBjb21lIHVwIHdpdGggcHJpb3JzIGZvciBzcGVjaWZpYyBzaXR1YXRpb25zLAp0aGlua2luZyBpbiB0ZXJtcyBvZiAqKnN0YW5kYXJkaXNlZCBlZmZlY3RzKiogcmF0aGVyIHRoYW4gYWN0dWFsIGRpZmZlcmVuY2VzIGluCmRhdGEgY2FuIGdldCBjb25mdXNpbmcuCgpUbyBkZWZpbmUgYSBsaWtlbGlob29kIGJhc2VkIG9uIGVmZmVjdCBzaXplLCB3ZSBmaXJzdCBuZWVkIHRvIHdvcmsgb3V0IHRoZQplZmZlY3Qgc2l6ZS4gVGhlcmUgYXJlIHR3byBmb3JtdWxhcyBmb3IgZWZmZWN0IHNpemVzLCBkZXBlbmRpbmcgb24gd2hldGhlcgp3ZSBoYXZlIGRhdGEgZnJvbSBvbmUgZ3JvdXAgKG9yIGZyb20gcGFpcmVkIHNhbXBsZXMpIG9yIHdoZXRoZXIgd2UgaGF2ZSBkYXRhCmZyb20gdHdvIGdyb3Vwcy4KCklmIHdlIGhhdmUgZGF0YSBmcm9tIHBhaXJlZCBzYW1wbGVzLCB0aGVuIHdlIGZpcnN0IHdvcmsgb3V0IHRoZSBwYWlyLXdpc2UKZGlmZmVyZW5jZXMuIEZvbGxvd2luZyB0aGlzLCB3ZSBwcm9jZWVkIGFzIHdlIHdvdWxkIGZvciB0aGUgb25lLXNhbXBsZSBjYXNlLiBUbwp3b3JrIG91dCB0aGUgZWZmZWN0IHNpemUgZm9yIHRoZSBvbmUgc2FtcGxlIGNhc2UsIHdlIHVzZSB0aGUgZm9sbG93aW5nIGZvcm11bGE6CgokJGQgPSBcZnJhY3ttfXtzfSwkJAoKV2hlcmUgJG0kIGlzIHRoZSBtZWFuIG9mIHRoZSBzYW1wbGUsIGFuZCAkcyQgaXMgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUKc2FtcGxlLgoKSWYgd2UgaGF2ZSBkYXRhIGZyb20gdHdvIGdyb3VwcyB0aGVuIHRoZSBmb3JtdWxhIGlzIGEgbGl0dGxlIG1vcmUgY29tcGxleC4gRm9yCnRoZSB0d28gZ3JvdXAgY2FzZSwgdGhlIGZvcm11bGEgaXMgYXMgZm9sbG93czoKCiQkZCA9IFxmcmFje21fMSAtIG1fMn17c19cbWF0aHJte3Bvb2xlZH19LCQkCgogd2hlcmUgJHNfXG1hdGhybXtwb29sZWR9JCBpcyBnaXZlbiBhcyBmb2xsb3dzOgoKJCRzX1xtYXRocm17cG9vbGVkfSA9IFxzcXJ0e1xmcmFjeyhuXzEgLSAxKXNeMl8xICsgKG5fMiAtIDEpc14yXzJ9e25fMSArIG5fMiAtMn19LCQkCgphbmQgd2hlcmUgJG1fMSQvJG1fMiQsICRzXzEkLyRzXzIkLCBhbmQgJG5fMSQvJG5fMiQsIGFyZSB0aGUgbWVhbiwgc3RhbmRhcmQKZGV2aWF0aW9uLCBhbmQgc2FtcGxlIHNpemUgZm9yIGdyb3VwIDEgYW5kIGdyb3VwIDIuIEluIHRoZSB3b3JrZWQgZXhhbXBsZXMKYmVsb3cgd2UnbGwgc2VlIHRoYXQgd2UgY2FuIHVzZSB0aGUgYGVmZnNpemVgIHBhY2thZ2UgaW4gUiB0byB3b3JrIG91dCB0aGlzCmVmZmVjdCBzaXplLgoKT25jZSB3ZSBoYXZlIHRoZSBlZmZlY3Qgc2l6ZSwgdGhlbiB0aGUgb25seSBvdGhlciB2YWx1ZSB0aGF0IHdlIG5lZWQgaXMgdGhlCnNhbXBsZSBzaXplLiBXZSBoYXZlIG9uZSBzYW1wbGUgc2l6ZSBpbiB0aGUgb25lIGdyb3VwIGNhc2UgKHNhbXBsZSBzaXplIG9yCm51bWJlciBvZiBwYWlycyksIGFuZCBmb3IgdGhlIHR3byBncm91cCBjYXNlIHdlJ2xsIGhhdmUgdGhlIHNhbXBsZSBzaXplIG9mIGVhY2gKZ3JvdXAuIFdlJ2xsIHdhbGsgdGhyb3VnaCBhIGNvdXBsZSBvZiBleGFtcGxlcyB1c2luZyBzaW11bGF0ZWQgZGF0YS4KCkluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgd2UgaGF2ZSBkYXRhIGZyb20gYW4gZXhwZXJpbWVudCBsb29raW5nIGF0IG1lbW9yeSBmb3IKd29yZHMuIFRoZSB3b3JkcyB3ZXJlIHByZXNlbnRlZCB1bmRlciB0d28gY29uZGl0aW9uczogYW4gKmVtb3Rpb25hbCogY29uZGl0aW9uCmFuZCBhICpuZXV0cmFsKiBjb25kaXRpb24uIFdlJ3JlIGludGVyZXN0ZWQgaW4ga25vd2luZyB3aGV0aGVyIHRoZXJlIGlzIGEKZGlmZmVyZW5jZSBpbiByZWNvZ25pdGlvbiBhY2N1cmFjeSBiZXR3ZWVuIHRoZSB0d28gY29uZGl0aW9ucy4gVGhpcyBpcyB0aGUga2luZApvZiBkYXRhIHdlJ2Qgb3JkaW5hcmlseSBhbmFseXNlIHdpdGggYSAqdCogdGVzdC4KCldlJ2xsIGxvYWQgdGhlIGRhdGEsIHdvcmsgb3V0IHRoZSBlZmZlY3Qgc2l6ZSwgZGVmaW5lIHRoZSBsaWtlbGlob29kLCBhbmQgdGhlbgpwbG90IGl0LgoKYGBge3J9CiN8IGVjaG8gPSBUUlVFLCBpbmNsdWRlID0gVFJVRQoKIyBGaXJzdCBsb2FkIHRoZSBkYXRhCndvcmRfZGF0YSA8LSByZWFkcjo6cmVhZF9jc3YoCiAgImh0dHBzOi8vZmlsZXMubWluZHNjaS5uZXQvd29yZF9kYXRhLmNzdiIsCiAgc2hvd19jb2xfdHlwZXMgPSBGQUxTRQopCgojIE5vdyB3ZSdsbCB3b3JrIG91dCB0aGUgZWZmZWN0IHNpemUgYW5kIG4Kc3VtbWFyeV9kYXRhIDwtIHdvcmRfZGF0YSAlPiUKICBwaXZvdF93aWRlcigxOjMsCiAgICBuYW1lc19mcm9tID0gImNvbmRpdGlvbiIsCiAgICB2YWx1ZXNfZnJvbSA9ICJhY2N1cmFjeSIKICApICU+JQogIG11dGF0ZShkaWZmID0gZW1vdGlvbmFsIC0gbmV1dHJhbCkgJT4lCiAgc3VtbWFyaXNlKG0gPSBtZWFuKGRpZmYpLCBzID0gc2QoZGlmZiksIG4gPSBuKCkpICU+JQogIG11dGF0ZShkID0gbSAvIHMsIHQgPSBtIC8gKHMgLyBzcXJ0KG4pKSkKCgojIE5vdyBkZWZpbmUgdGhlIGxpa2VsaWhvb2QgYW5kIHBsb3QgaXQKZGF0YV9tb2RlbCA8LSBsaWtlbGlob29kKAogIGZhbWlseSA9ICJub25jZW50cmFsX2QiLAogIGQgPSBzdW1tYXJ5X2RhdGEkZCwKICBuID0gc3VtbWFyeV9kYXRhJG4KKQoKcGxvdChkYXRhX21vZGVsKSArCiAgbGFicygKICAgIHggPSAizrQiLCB5ID0gIlAoWXzOuCkiLAogICAgdGl0bGUgPSAiTGlrZWxpaG9vZCBmb3I6IiwKICAgIHN1YnRpdGxlID0gZ2x1ZTo6Z2x1ZSgKICAgICAgImQgPSB7cm91bmQoc3VtbWFyeV9kYXRhJGQsMil9LCIsCiAgICAgICIgbiA9IHtzdW1tYXJ5X2RhdGEkbn0iCiAgICApCiAgKSArCiAgdGhlbWVfbWluaW1hbCgxNCkgKwogIHNjYWxlX3hfY29udGludW91cyhsaW1pdHMgPSBjKC0xLCAxKSwgYnJlYWtzID0gc2VxKC0xLCAxLCAuNSkpCmBgYAoKSW4gdGhlIHNlY29uZCBleGFtcGxlLCB3ZSdsbCBsb29rIGF0IHRoZSB0d28gZ3JvdXAgY2FzZS4gRm9yIHRoaXMgZXhhbXBsZSB3ZSdsbAp1c2Ugc29tZSBzaW11bGF0ZWQgZGF0YSB0byBtYXRjaCBzb21lIGRhdGEgZnJvbSBhbiBleHBlcmltZW50IEkgY29uZHVjdGVkIG1hbnkKeWVhcnMgYWdvLiBJbiB0aGlzIHRhc2ssIHBlb3BsZSB3ZXJlIGFza2VkIHRvIHdhdGNoIGFuIGFuaW1hdGVkIGF2YXRhcgpwZXJmb3JtaW5nIGEgbW92ZW1lbnQsIHRoZXkgd2VyZSBhc2tlZCB0byBzeW5jaHJvbmlzZSBhIGJ1dHRvbiBwcmVzcyB3aXRoCmNyaXRpY2FsIHBvaW50cyBpbiB0aGUgbW92ZW1lbnQsIGFuZCB0aGUgdGltaW5nIGVycm9yIHdhcyBtZWFzdXJlZC4gVGhlCmFuaW1hdGVkIGF2YXRhciBtb3ZlZCBpbiB0d28gZGlmZmVyZW5jZSB3YXlzLiBJbiBvbmUgY29uZGl0aW9uIGl0IG1vdmVkIGxpa2UgYQpodW1hbi4gSW4gdGhlIG90aGVyIGNvbmRpdGlvbiwgdGhlIGR5bmFtaWNzIG9mIHRoZSBtb3ZlbWVudCB3ZXJlIGFsdGVyZWQgc28KdGhhdCBpdCBtb3ZlZCBsaWtlIGEgcm9ib3QuIEFsbCBwYXJ0aWNpcGFudHMgdmlld2VkIGJvdGgga2luZHMgb2YgbW92ZW1lbnRzLiBJbgphZGRpdGlvbiB0byB0aGlzIHdpdGhpbiBzdWJqZWN0cyBmYWN0b3IsIHRoZXJlIHdhcyBhbHNvIGEgYmV0d2VlbiBzdWJqZWN0cwpmYWN0b3IuIEJlZm9yZSB2aWV3aW5nIGFueSBvZiB0aGUgbW92ZW1lbnQsIHBhcnRpY2lwYW50cyB3ZXJlIHNwbGl0IGludG8gdHdvCmdyb3Vwcy4gT25lIGdyb3VwIHdhcyBnaXZlbiBleHBlcmllbmNlIGFjdHVhbGx5IHBlcmZvcm1pbmcgdGhlIG1vdmVtZW50IHRoZXkKd291bGQgbGF0ZXIgb2JzZXJ2ZSwgd2hpbGUgdGhlIG90aGVyIGdyb3VwIHdhcyBub3QuCgpUaGlzIGlzIHRoZSBraW5kIG9mIGRhdGEgdGhhdCB3b3VsZCBvcmRpbmFyaWx5IGJlIGFuYWx5c2VkIHVzaW5nIGEgMiDDlyAyIG1peGVkCkFOT1ZBLiBIb3dldmVyLCBJIHdhcyBwYXJ0aWN1bGFybHkgaW50ZXJlc3RlZCBpbiB0aGUgKippbnRlcmFjdGlvbioqLiBUaGUKKippbnRlcmFjdGlvbioqIGp1c3QgZXhhbWluZXMgd2hldGhlciB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuICoqY29uZGl0aW9uIDEqKgphbmQgKipjb25kaXRpb24gMioqIGlzIGRpZmZlcmVudCBiZXR3ZWVuICoqZ3JvdXAgMSoqIGFuZCAqKmdyb3VwIDIqKi4gIEluIHRoZQpleGFtcGxlIGJlbG93LCBJJ3ZlIGFscmVhZHkgd29ya2VkIG91dCB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgdGltaW5nIGVycm9yIGZvcgoqKmNvbmRpdGlvbiAxKiogYW5kICoqY29uZGl0aW9uIDIqKiwgYW5kIG5vdyB3ZSBqdXN0IGhhdmUgdG8gY29tcGFyZSB0aGlzCmRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGdyb3Vwcy4KCkFzIHdpdGggdGhlIGVhcmxpZXIgZXhhbXBsZSwgd2UnbGwgbG9hZCB0aGUgZGF0YSwgd29yayBvdXQgdGhlIGVmZmVjdCBzaXplLCAKZGVmaW5lIHRoZSBsaWtlbGlob29kLCBhbmQgdGhlbiBwbG90IGl0LgoKYGBge3J9CiN8IGVjaG8gPSBUUlVFLCBpbmNsdWRlID0gVFJVRQoKIyBGaXJzdCBsb2FkIHRoZSBkYXRhCm1vdG9yX2V4cCA8LSByZWFkcjo6cmVhZF9jc3YoCiAgImh0dHBzOi8vZmlsZXMubWluZHNjaS5uZXQvbW90b3JfZXhwLmNzdiIsCiAgc2hvd19jb2xfdHlwZXMgPSBGQUxTRQopCgoKIyBOb3cgd2UnbGwgd29yayBvdXQgdGhlIGVmZmVjdCBzaXplIGFuZCBuCnN1bW1hcnlfZGF0YSA8LSBtb3Rvcl9leHAgJT4lCiAgZHBseXI6Omdyb3VwX2J5KGdyb3VwKSAlPiUKICBkcGx5cjo6c3VtbWFyaXNlKG0gPSBtZWFuKHJfZGlmZiksIHMgPSBzZChyX2RpZmYpLCBuID0gbigpKSAlPiUKICB0aWR5cjo6cGl2b3Rfd2lkZXIoCiAgICBuYW1lc19mcm9tID0gImdyb3VwIiwKICAgIHZhbHVlc19mcm9tID0gYygibSIsICJzIiwgIm4iKQogICkKCm1kX2RpZmYgPC0gc3VtbWFyeV9kYXRhJG1fZXhwZXIgLSBzdW1tYXJ5X2RhdGEkbV9uYWl2ZQpzZF9wb29sZWQgPC0gc3FydCgoKChzdW1tYXJ5X2RhdGEkbl9leHBlciAtIDEpICoKICBzdW1tYXJ5X2RhdGEkc19leHBlcl4yKSArCiAgKChzdW1tYXJ5X2RhdGEkbl9uYWl2ZSAtIDEpICogc3VtbWFyeV9kYXRhJHNfbmFpdmVeMikpIC8KICAoc3VtbWFyeV9kYXRhJG5fZXhwZXIgKyBzdW1tYXJ5X2RhdGEkbl9uYWl2ZSAtIDIpKQpkIDwtIG1kX2RpZmYgLyBzZF9wb29sZWQKCiMgb3Igd2UgY2FuIHVzZSB0aGUgZWZmc2l6ZSBwYWNrYWdlCiMgeW91J2xsIGp1c3QgbmVlZCB0byBpbnN0YWxsIGl0IGJlZm9yZSB5b3UgdXNlIGl0CiMgeW91IGNhbiBpbnN0YWxsIGl0IHdpdGggdGhlIGZvbGxvd2luZyBjb21tYW5kCiMgaW5zdGFsbC5wYWNrYWdlKCJlZmZzaXplIikKIwojIGFuZCB0aGVuIHVzZSBpdCBhcyBmb2xsb3dzCiMgZCA8LSBlZmZzaXplOjpjb2hlbi5kKAojICAgbW90b3JfZXhwJHJfZGlmZiwKIyAgIG1vdG9yX2V4cCRncm91cAojICkkZXN0aW1hdGUKCiMgc2FtcGxlX3NpemUgPC0gbW90b3JfZXhwICU+JQojICAgZHBseXI6Omdyb3VwX2J5KGdyb3VwKSAlPiUKIyAgIGRwbHlyOjpzdW1tYXJpc2UobiA9IG4oKSkKCiMgTm93IGRlZmluZSB0aGUgbGlrZWxpaG9vZCBhbmQgcGxvdCBpdApkYXRhX21vZGVsIDwtIGxpa2VsaWhvb2QoCiAgZmFtaWx5ID0gIm5vbmNlbnRyYWxfZDIiLAogIGQgPSBkLAogIG4xID0gc3VtbWFyeV9kYXRhJG5fZXhwZXIsCiAgbjIgPSBzdW1tYXJ5X2RhdGEkbl9uYWl2ZQopCgpwbG90KGRhdGFfbW9kZWwpICsKICBsYWJzKAogICAgeCA9ICLOtCIsIHkgPSAiUChZfM64KSIsCiAgICB0aXRsZSA9ICJMaWtlbGlob29kIGZvcjoiLAogICAgc3VidGl0bGUgPSBnbHVlOjpnbHVlKAogICAgICAiZCA9IHtyb3VuZChkLDIpfSwiLAogICAgICAiIG4xID0ge3N1bW1hcnlfZGF0YSRuX2V4cGVyfSwiLAogICAgICAiIG4yID0ge3N1bW1hcnlfZGF0YSRuX25haXZlfSIKICAgICkKICApICsKICB0aGVtZV9taW5pbWFsKDE0KSArCiAgc2NhbGVfeF9jb250aW51b3VzKGxpbWl0cyA9IGMoLTEsIDMpLCBicmVha3MgPSBzZXEoLTEsIDMsIDEpKQpgYGAKCiMjIEluZmVyZW5jZXMgYWJvdXQgKnQqIHZhbHVlcwoKRmluYWxseSwgd2UnbGwgcmVwZWF0IHRoZSBsYXN0IGFuYWx5c2lzLCBidXQgaW4gdGhpcyBjYXNlIHdlJ2xsIG1vZGVsIHRoZSBkYXRhCmluIHRlcm1zIG9mICp0KiByYXRoZXIgdGhhbiAqZCouCgpgYGB7cn0KI3wgZWNobyA9IFRSVUUsIGluY2x1ZGUgPSBUUlVFCgojIExvYWQgdGhlIGRhdGEgYWdhaW4ganVzdCBpbiBjYXNlCm1vdG9yX2V4cCA8LSByZWFkcjo6cmVhZF9jc3YoCiAgImh0dHBzOi8vZmlsZXMubWluZHNjaS5uZXQvbW90b3JfZXhwLmNzdiIsCiAgc2hvd19jb2xfdHlwZXMgPSBGQUxTRQopCgojIFJ1biB0aGUgdCB0ZXN0IGFuZCBleHRyYWN0IHRoZSB0IHZhbHVlIGFuZCBkZgp0X3Rlc3RfcmVzIDwtIHQudGVzdChyX2RpZmYgfiBncm91cCwKICBtb3Rvcl9leHAsCiAgdmFyLmVxdWFsID0gVFJVRQopICU+JQogIGJyb29tOjp0aWR5KCkgJT4lCiAgZHBseXI6OnNlbGVjdChzdGF0aXN0aWMsIHBhcmFtZXRlcikKCiMgTm93IGRlZmluZSB0aGUgbGlrZWxpaG9vZAoKZGF0YV9tb2RlbCA8LSBsaWtlbGlob29kKAogIGZhbWlseSA9ICJub25jZW50cmFsX3QiLAogIHQgPSB0X3Rlc3RfcmVzJHN0YXRpc3RpYywKICBkZiA9IHRfdGVzdF9yZXMkcGFyYW1ldGVyCikKCiMgQW5kIHBsb3QgaXQKcGxvdChkYXRhX21vZGVsKSArCiAgbGFicygKICAgIHggPSAidCIsIHkgPSAiUChZfM64KSIsCiAgICB0aXRsZSA9ICJMaWtlbGlob29kIGZvcjoiLAogICAgc3VidGl0bGUgPSBnbHVlOjpnbHVlKAogICAgICAidCA9IHtyb3VuZCh0X3Rlc3RfcmVzJHN0YXRpc3RpYywyKX0sIiwKICAgICAgIiBkZiA9IHt0X3Rlc3RfcmVzJHBhcmFtZXRlcn0iCiAgICApCiAgKSArCiAgdGhlbWVfbWluaW1hbCgxNCkgKwogIHNjYWxlX3hfY29udGludW91cyhsaW1pdHMgPSBjKC0yLCA2KSwgYnJlYWtzID0gc2VxKC0yLCA2LCAyKSkKYGBgCgpVc2luZyB0aGUgKm5vbi1jZW50cmFsIHQqIGxpa2VsaWhvb2QgbWlnaHQgc2VlbSBhIGxpdHRsZSBlYXNpZXIgdG8gdXNlLCBiZWNhdXNlCml0IHJlcXVpcmVzIGxlc3Mgd29yayB1cGZyb250IGJlY2F1c2Ugd2UgY2FuIGp1c3QgdXNlIHRoZSBgdC50ZXN0YCBmdW5jdGlvbiB0bwp3b3JrIG91dCB0aGUgKnQqIHN0YXRpc3RpYyBpbnN0ZWFkIG9mIGhhdmluZyB0byB3b3JrIG91dCB0aGUgKmQqIHZhbHVlLgpIb3dldmVyLCBhcyB3ZSdsbCBzZWUgaW4gdGhlIHNlY3Rpb24gb24gKipwcmlvcnMqKiwgdGhlcmUgYXMgYWR2YW50YWdlcyB0byB1c2luZwp0aGUgKm5vbi1jZW50cmFsIHQqIGxpa2VsaWhvb2QuIFRoaXMgZGlzYWR2YW50YWdlIGlzIHByaW1hcmlseSB0byBkbyB3aXRoIHRoZQpmYWN0IHRoYXQgdGhlICp0KiB2YWx1ZSBjYW4gY2hhbmdlIGRyYW1hdGljYWxseSB3aXRoIHNhbXBsZSBzaXplLS0tdGhhdCBpcywgCnZlcnkgbGFyZ2Ugc2FtcGxlIHNpemVzIGNhbiByZXN1bHQgaW4gdmVyeSBsYXJnZSAqdCogdmFsdWVzIGV2ZW4gaWYgdGhlIG1lYW4gCmRpZmZlcmVuY2UgYmV0d2VlbiBjb25kaXRpb25zIG9yIGdyb3VwcyBzdGF5cyBjb25zdGFudC4gRm9yIHRoZSAqbm9uLWNlbnRyYWwgZCogCmFuZCAqbm9uLWNlbnRyYWwgZDIqIGxpa2VsaWhvb2RzIHRoaXMgaXNuJ3QgYW4gaXNzdWUuIFRoZSAqZCogdmFsdWUgd2lsbCBzdGF5CnRoZSBzYW1lIGV2ZW4gaWYgdGhlIHNhbXBsZSBzaXplIGluY3JlYXNlcyBhbmQgaW5zdGVhZCwgdGhlIGxpa2VsaWhvb2Qgd2lsbCAKanVzdCBnZXQgbmFycm93ZXIuCgpJJ3ZlIGNvdmVyZWQgdGhlICpub24tY2VudHJhbCB0KiBsaWtlbGlob29kIGZvciBjb21wbGV0ZW5lc3MsIGJ1dCBpdCdzIGFsbW9zdApuZXZlciBvZiBhbnkgcmVhbCB1c2UuCgo" download="05-more-likelihoods.Rmd"><img src="https://img.shields.io/badge/.Rmd-Download-blue"></a>
[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/ljcolling/bayes2022/blob/main/_notebooks/05-more-likelihoods.ipynb)

In the previous section (see [An alternative to *p*
values](an-alternative-to-p-values.html), and [The Bayes
factor](the-bayes-factor.html)), we were introduced to the concept of the
**likelihood**. In these sections, we specifically covered the **binomial**
likelihood, which can be used for working out Bayes factors for samples of
Bernoulli trials---that is, trials with two discrete outcomes like heads and
tails or successes and failures. We used this specifically for computing our
Bayes factors for hypotheses about coin flips. Although these Bayes factors
could be used anywhere where we might ordinarily use a frequentist **binomial
test** it is still rather limited in scope. Therefore, in this section, we'll
cover Bayes factors that can be used in other situations. Specifically, we'll
focus primarily on situations where we're interested in **differences between
means**---that is, situations where we might otherwise use a *t*-test or ANOVA.

## Choosing a likelihood

In our initial example on hunting treasure (see [Null hypothesis significance
testing](null-hypothesis-significance-testing.html)) our treasure hunting
device worked by, on average, pointing at 0 when there was no treasure
around and, on average, pointing at some other value when there was treasure
around.

To work out whether our device was, on average, pointing at a particular value
we collected a sample of a fixed size (10 in our first example) and then worked
out the average of these values. For example, we might've collected a sample of
10 values as follows:

```{r}
set.seed(123)

sample_size <- 10
sample_mean <- 0
sample_sd <- 25
sample_data <- rnorm(n = sample_size, m = sample_mean, sd = sample_sd)

paste0("**Sample data**: ", paste(round(sample_data, 1), collapse = ", "), "

**Sample mean**: ", round(mean(sample_data), 2)) %>%
  display_markdown()
```

After collecting a large number of samples, we could plot our averages as
follows:

```{r}

generate_data <- function(size, mean, sd, samples) {
  purrr::map_df(1:samples, function(x) {
    data <- rnorm(size, mean, sd)
    tibble::tibble(
      mean = mean(data),
      t = mean / (sd(data) / sqrt(size)),
      d = mean / sd(data)
    )
  })
}


sample_means_data <- generate_data(10, 0, 25, 10000)
sample_means_data_nonzero <- generate_data(10, 19.6, 25, 10000)


generate_plot <- function(data) {
  density_plot_means <- tibble(x = seq(min(data$mean),
    max(data$mean),
    length.out = 10000
  )) %>%
    mutate(y = polspline::dlogspline(
      x,
      polspline::logspline(data$mean)
    ))

  density_plot_ts <- tibble(x = seq(min(data$t),
    max(data$t),
    length.out = 10000
  )) %>%
    mutate(y = polspline::dlogspline(
      x,
      polspline::logspline(data$t)
    ))

  density_plot_ds <- tibble(x = seq(min(data$d),
    max(data$d),
    length.out = 10000
  )) %>%
    mutate(y = polspline::dlogspline(
      x,
      polspline::logspline(data$d)
    ))



  mean_plot <- ggplot() +
    geom_histogram(
      data = data,
      aes(x = mean, y = ..density..), bins = 30, na.rm = TRUE
    ) +
    geom_line(
      data = density_plot_means, aes(x = x, y = y), size = 1,
      na.rm = TRUE
    ) +
    theme_minimal(14) +
    labs(x = "μ", y = "Density") +
    NULL

  t_plot <- ggplot() +
    geom_histogram(
      data = data,
      aes(x = t, y = ..density..), bins = 30, na.rm = TRUE,
    ) +
    geom_line(
      data = density_plot_ts, aes(x = x, y = y), size = 1,
      na.rm = TRUE
    ) +
    theme_minimal(14) +
    labs(x = "t", y = "Density") +
    NULL


  d_plot <- ggplot() +
    geom_histogram(
      data = data,
      aes(x = d, y = ..density..), bins = 30, na.rm = TRUE,
    ) +
    geom_line(
      data = density_plot_ds, aes(x = x, y = y), size = 1,
      na.rm = TRUE
    ) +
    theme_minimal(14) +
    labs(x = "δ", y = "Density") +
    NULL

  list(mean_plot = mean_plot, t_plot = t_plot, d_plot = d_plot)
}
```

```{r}
list(
  plot = generate_plot(sample_means_data),
  limits = list(c(-30, 30), c(-4, 4), c(-2, 2))
) %>%
  pmap(function(plot, limits) plot + xlim(limits)) %>%
  wrap_plots(ncol = 3) + plot_annotation(tag_level = "A")
```

In the above examples, we've set the *parameter* of interest (the mean) to 0.
The above plots are just examples of the sampling distribution when the
parameter is 0. Panel **A** shows the sampling distribution of the *raw means*.
Panel **B** shows the sampling distribution of the raw means re-scaled to *t*
values. Finally, panel **C** shows the sampling distribution of the raw means
re-scaled to *Cohen's d* values (where $\delta = \frac{\mu}{\sigma}$). All
these plots approximately follow the shape of a *normal distribution* or a
*t distribution*. We could use these plots to work out *p* values, just
as we previously did.

But, as we did with the coin flip examples, when working with *likelihoods*,
we're interested in the probability of obtaining our data under different
values of the parameter. That is, we must consider the probability of obtaining
our current data not just in the case where the parameter of interest is 0, but
also where the parameter of interest is some other value. For example, the
plots below have been generated by setting the parameter value--that is, the
value to which the device, on average points---to a raw mean of approximately
19.6. We've also set the average spread of the values---that is, the standard
deviation--to 25. Consequently, when rescaled to a *t* value, this would result
in an average *t* of $\frac{19.6}{\frac{25}{\sqrt{10}}}$. And when rescaled to
a *d* value, this would result in an average *d* value of $\frac{19.6}{25}$.

```{r}
list(
  plot = generate_plot(sample_means_data_nonzero),
  limits = list(c(-10, 50), c(-2, 8), c(-1, 5))
) %>%
  pmap(function(plot, limits) plot + xlim(limits)) %>%
  wrap_plots(ncol = 3) + plot_annotation(tag_level = "A")
```

For these plots, panel **A** again shows the *raw means*, with panel **B**
showing the *t* values, and panel **C** showing the Cohen's *d* values. The
distribution in Panel **A** now approximately follows the shape of a *normal
distribution* or a *scaled and shifted t distribution*. Panel **B** and **C**
now follow the shape of slightly differently scaled versions of the
*non-central t distribution*.

In the section that follows, we'll discover and learn how to use these
likelihoods: The *normal* likelihood, the *scaled and shifted t* likelihood,
and three versions of the *non-central t* likelihood (which `bayesplay` calls
the *non-central t*, *non-central d*, and *non-central d2* likelihoods).

### The variance of likelihoods

When we were examining coin flips, we saw that the sampling distribution (in
the flip until **n** flips case) followed the *binomial distribution*. And when
we wanted to make inferences about parameter values (the coin bias) we used the
*binomial* likelihood. Our data, which we used to make our inference consisted
of, first, the number of heads and, second, the number of flips.

These two values controlled different aspects of the shape of the likelihood
function. First, the number of heads that we observed more-or-less controlled
where the peak of the likelihood function was located. Second, the number of
flips, or the sample size, controlled how spread out the likelihood function
was. In the plots below we can see three cases of observing $\frac{n}{2}$ heads
in 2, 20, and 100 flips. In all three plots, the likelihood function is peaked
at 0.5 and drops off as we move away from 0.5. The rate of this drop off,
however, is steeper as the sample size increases.

```{r}
likelihoods <- c(
  likelihood("binomial", 2 / 2, 2),
  likelihood("binomial", 20 / 2, 20),
  likelihood("binomial", 100 / 2, 100)
)

(map(likelihoods, function(x) {
  plot(x) +
    theme_minimal(14) +
    geom_vline(xintercept = 0.8, linetype = 2) +
    scale_x_continuous(
      breaks = c(0, 0.2, .5, 0.8, 1),
      limits = c(0, 1)
    ) +
    labs(subtitle = glue::glue(
      "{x$parameters[[1]]} heads in {x$parameters[[2]]}"
    ))
}) %>%
  wrap_plots(ncol = 3) + plot_annotation(tag_level = "A")) %>% show()
```

What is the important intuition here? To get a handle on the intuition we can
think of the extreme cases. When the coin is very biased---for example, it
shows heads 0.8 of the time---then it will still sometimes show tails. It might
even sometimes show tails on the first flip. In fact, it'll show tails on the
first flip 0.2 of the time. Therefore, we wouldn't be that surprised if after
two flips we have one head and one tail, because it won't be such an uncommon
occurrence. But in the situation where we're making 100 flips, it now becomes
more and more unlikely that we'd see equal numbers of heads and tails if the
coin bias really was 0.8. We can put numbers to it by calculating the
likelihood ratio between 0.5 and 0.8 for each of the three sample sizes.

```{r}

map_df(likelihoods, function(x) {
  tibble(
    lr = x$likelihood_function(0.5) / x$likelihood_function(0.8),
    trials = x$parameters$trials
  )
}) %>%
  glue::glue_data("When there are {trials} trials, the likelihood ratio
between θ = 0.5 and θ = 0.8 is {round(lr,2)}.\n\n\n") %>%
  paste0(., collapse = "\n") %>%
  display_markdown()
```

For all the likelihoods that we'll examine in this section, when defining the
likelihoods we'll have one value that represents our observation: the mean we
observe, the *t* value we observe, or the *d* value we observe. This will be
analogous to the number of heads we observe in the coin flip example. And we'll
have a value (or values) that defines how peaked or spread out the likelihood
will be: this could be the sample size, the degrees of freedom and/or standard
deviation. 

In more technical terms, all the likelihoods that we'll examine will have one
parameter that we're making inferences about: the *mean*, the *t* value, or the
*d* value. But this parameter will also have a *variance* associated with it.
And as we'll see in the examples below, depending on whether we're interested
in *raw means*,*t* values, or *d* values, the sampling distributions are
slightly different shapes. Therefore, the *likelihoods* that we use in each
case will be slightly different. We'll look at each of these in turn.

## Inferences about raw means

When we're interested in making inferences about the *raw means* we have two
choices available to us. The most straightforward choice is to choose the
*normal* likelihood. The shape of the *normal* likelihood is controlled by
**two** values. The first value is our **observed mean**. This value controls
the location of the peak of the likelihood function. The second value is the
**standard deviation of the mean**.  The **standard deviation of the mean** is
more commonly known as the **standard error of the mean**. We can work out the
*standard error* using the following formula:

$$\sigma_{\bar{x}} = \frac{\sigma}{\sqrt{n}},$$

where $\sigma$ is the standard deviation of the population. Usually, we don't
know the value of $\sigma$, so we estimate it using $s$, or the standard
deviation of our sample.

To see how defining a *normal* likelihood works in practice, we'll generate our
data. From this, we'll work out the mean of our sample, and we'll estimate the
standard error (the standard deviation of the mean).

To generate our data, we'll set up a data generating process (you can think of
this as **the population**) and we'll draw a sample of 10 values from this. Our
data generating process will have a $\mu$ (mean of the population) of 19.6, and
a $\sigma$ (standard deviation of the population) of 25.


```{r}

set.seed(123)
sample_data <- rnorm(n = 10, mean = 19.6, sd = 25)

glue::glue("**Sample data**: {paste(round(sample_data, 2), collapse = ', ')}

**Mean of sample**: {round(mean(sample_data), 2)}


**Standard deviation of sample**: {round(sd(sample_data), 2)}


**Size of sample**: {round(length(sample_data), 2)}

**Standard deviation of sampling distribution (standard error)**: {round(sd(sample_data)/sqrt(length(sample_data)) ,2)}
") %>%
  display_markdown()
```

Note that the two values that we want are the *mean of the sample* and the
*standard deviation of the mean*. A common confusion is that you want the
*standard deviation of the sample*. This is not the value that we want, and we
only calculate it because we can use it to estimate the *standard deviation of
the population* and, from this, the *standard deviation of the mean*.

Now we can define the likelihood, and we can plot it.

```{r}
#| echo = TRUE, include = TRUE
data_model <- likelihood(
  family = "normal",
  mean = 21.47,
  sd = 7.54
)

plot(data_model) +
  labs(title = "likelihood for mean = 21.47 (normal)") +
  xlim(-10, 50) +
  theme_minimal(14)
```

From our likelihood plot we can see that our data would be generated more often
if the mean of the data generating process was 21 and less often if the mean of
the data generating process was 30.

In fact, we can put a number to it and say that:

```{r}

likelihood_ratio_n <- data_model$likelihood_function(21) /
  data_model$likelihood_function(30)

glue::glue("The data would be produced {round(likelihood_ratio_n, 2)} times more
often if the mean of the population was 21 than it would be if the mean of the
population was 30.") %>%
  display_markdown()
```

The likelihood function will get wider or narrower when the *standard deviation
of the mean* changes. The two factors that control the *standard deviation of
the mean* are the sample size and the standard deviation of the population. In
the example below we'll keep our estimate of the *standard deviation of the
population* the same but we'll increase the sample size. Consequently, the
*standard deviation of the mean* will decrease and our likelihood function will
become narrower.

```{r}
#| echo = TRUE, include = TRUE

data_model <- likelihood(
  family = "normal",
  mean = 21.47,
  sd = 2.384
)

plot(data_model) +
  labs(title = "likelihood for mean = 21.47") +
  xlim(-10, 50) +
  theme_minimal(14)
```

And this would also make a change to any likelihood ratio we could calculate.
For example, calculating the new likelihood ratio comparing $\mu = 30$ and $\mu
= 21$ would give the following result:

```{r}
likelihood_ratio <- data_model$likelihood_function(21) /
  data_model$likelihood_function(30)

glue::glue("The data would be produced {round(likelihood_ratio, 2)} times more
often if the mean of the population was 21 than it would be if the mean of the
population was 30.") %>%
  display_markdown()
```

In the preceding examples, we were modelling our data with a *normal*
likelihood. And we were estimating the *standard deviation of the mean* using
the *standard deviation of our sample*. We did this, because we didn't know the
actual standard deviation of our data generating process. We'd need to know
this value if we wanted to exactly calculate the *standard deviation of the
mean*.

Or at least, we ordinarily don't know the standard deviation of our data
generating process. However, because I set it up, I know it is 25, because this
is the value I set it to. Therefore, our estimate was an under estimate.
Typically, we'll underestimate the *standard deviation of the population*.
These under-estimates will be worse when the sample size is small. As our
sample size increases then the two values will, by definition, match.

There are a few approaches that we can take to dealing with this issue. First,
we can just do nothing. This is the most straightforward approach, and it is
also a very common approach. The second approach, is to apply a correction as
follows:

$$s_{\bar{x}} = \frac{s}{\sqrt{n}} \times \left(1 + \frac{20}{\mathrm{df}^2}\right),$$

where $\mathrm{df}$ are the degrees of freedom for the corresponding *t* test.
[Dienes (2014, p 11)](http://dx.doi.org/10.3389/fpsyg.2014.00781) provides
more details on this approach. Dienes (2014) also provides good guidance on
using Bayes factors, and I would recommend reading it for the assessment.

Finally, the third approach, is to employ a *scaled and shifted t likelihood*
instead of a *normal likelihood*. The *scaled and shifted t likelihood* has
fatter tails than the *normal likelihood*, which accounts for the fact that our
*normal likelihood* tends to be narrower than it ought to be.

In `bayesplay` we can use the *scaled and shifted t likelihood* by setting the
likelihood **family** to **student_t**. When using this likelihood, one
additional value will need to be set. This is the **df** value, which is the 
same as the **df** value that we would use for the correction approach above.

We'll recompute our previous example using this likelihood family.

```{r}
#| echo = TRUE, include = TRUE
data_model <- likelihood(
  family = "student_t",
  mean = 21.47,
  sd = 7.54,
  df = 9
)

plot(data_model) +
  labs(title = "likelihood for mean = 21.47 (student t)") +
  xlim(-10, 50) +
  theme_minimal(14)
```

As you can see the two likelihood functions look very similar.

```{r}
likelihood_ratio_t <- data_model$likelihood_function(21) /
  data_model$likelihood_function(30)

glue::glue("The data would be produced {round(likelihood_ratio_t, 2)} times more
often if the mean of the population was 21 than it would be if the mean of the
population was 30.") %>%
  display_markdown()
```

This likelihood ratios are also very similar.

```{r}
likelihood_ratio_diff <- abs(likelihood_ratio_t - likelihood_ratio_n)

glue::glue("The difference in the likelihood ratio between the *normal*
likelihood and the *student_t* likelihood is about
{round(likelihood_ratio_diff,2)}") %>%
  display_markdown()
```


## Inferences about effect sizes

A very popular alternative approach to modelling data in terms of the observed
mean is to instead model data in terms of standardized effect sizes on the raw
means themselves. This gets around the problem of the unknown variance;
however, it has an added benefit in that it can place results from very
different experiments on a common scale. For example, results from a study of
reaction times might have values between 500 and 2000 ms and results from a
study on test scores might have values that range between 40 and 90. By
re-scaling mean values to *standardised means*---that is, to effect sizes---we
can be more certain that values will fall somewhere between -10 / 10, and more
typically between -1/1. When we talk more about priors, we'll see that this
rescaling will help us to come up with priors that will work in a wide range of
settings and with a wide range of experiments and types of data. However, we'll
also see that when we want to come up with priors for specific situations,
thinking in terms of **standardised effects** rather than actual differences in
data can get confusing.

To define a likelihood based on effect size, we first need to work out the
effect size. There are two formulas for effect sizes, depending on whether
we have data from one group (or from paired samples) or whether we have data
from two groups.

If we have data from paired samples, then we first work out the pair-wise
differences. Following this, we proceed as we would for the one-sample case. To
work out the effect size for the one sample case, we use the following formula:

$$d = \frac{m}{s},$$

Where $m$ is the mean of the sample, and $s$ is the standard deviation of the
sample.

If we have data from two groups then the formula is a little more complex. For
the two group case, the formula is as follows:

$$d = \frac{m_1 - m_2}{s_\mathrm{pooled}},$$

 where $s_\mathrm{pooled}$ is given as follows:

$$s_\mathrm{pooled} = \sqrt{\frac{(n_1 - 1)s^2_1 + (n_2 - 1)s^2_2}{n_1 + n_2 -2}},$$

and where $m_1$/$m_2$, $s_1$/$s_2$, and $n_1$/$n_2$, are the mean, standard
deviation, and sample size for group 1 and group 2. In the worked examples
below we'll see that we can use the `effsize` package in R to work out this
effect size.

Once we have the effect size, then the only other value that we need is the
sample size. We have one sample size in the one group case (sample size or
number of pairs), and for the two group case we'll have the sample size of each
group. We'll walk through a couple of examples using simulated data.

In the following example, we have data from an experiment looking at memory for
words. The words were presented under two conditions: an *emotional* condition
and a *neutral* condition. We're interested in knowing whether there is a
difference in recognition accuracy between the two conditions. This is the kind
of data we'd ordinarily analyse with a *t* test.

We'll load the data, work out the effect size, define the likelihood, and then
plot it.

```{r}
#| echo = TRUE, include = TRUE

# First load the data
word_data <- readr::read_csv(
  "https://files.mindsci.net/word_data.csv",
  show_col_types = FALSE
)

# Now we'll work out the effect size and n
summary_data <- word_data %>%
  pivot_wider(1:3,
    names_from = "condition",
    values_from = "accuracy"
  ) %>%
  mutate(diff = emotional - neutral) %>%
  summarise(m = mean(diff), s = sd(diff), n = n()) %>%
  mutate(d = m / s, t = m / (s / sqrt(n)))


# Now define the likelihood and plot it
data_model <- likelihood(
  family = "noncentral_d",
  d = summary_data$d,
  n = summary_data$n
)

plot(data_model) +
  labs(
    x = "δ", y = "P(Y|θ)",
    title = "Likelihood for:",
    subtitle = glue::glue(
      "d = {round(summary_data$d,2)},",
      " n = {summary_data$n}"
    )
  ) +
  theme_minimal(14) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, .5))
```

In the second example, we'll look at the two group case. For this example we'll
use some simulated data to match some data from an experiment I conducted many
years ago. In this task, people were asked to watch an animated avatar
performing a movement, they were asked to synchronise a button press with
critical points in the movement, and the timing error was measured. The
animated avatar moved in two difference ways. In one condition it moved like a
human. In the other condition, the dynamics of the movement were altered so
that it moved like a robot. All participants viewed both kinds of movements. In
addition to this within subjects factor, there was also a between subjects
factor. Before viewing any of the movement, participants were split into two
groups. One group was given experience actually performing the movement they
would later observe, while the other group was not.

This is the kind of data that would ordinarily be analysed using a 2 × 2 mixed
ANOVA. However, I was particularly interested in the **interaction**. The
**interaction** just examines whether the difference between **condition 1**
and **condition 2** is different between **group 1** and **group 2**.  In the
example below, I've already worked out the difference in the timing error for
**condition 1** and **condition 2**, and now we just have to compare this
difference between the two groups.

As with the earlier example, we'll load the data, work out the effect size, 
define the likelihood, and then plot it.

```{r}
#| echo = TRUE, include = TRUE

# First load the data
motor_exp <- readr::read_csv(
  "https://files.mindsci.net/motor_exp.csv",
  show_col_types = FALSE
)


# Now we'll work out the effect size and n
summary_data <- motor_exp %>%
  dplyr::group_by(group) %>%
  dplyr::summarise(m = mean(r_diff), s = sd(r_diff), n = n()) %>%
  tidyr::pivot_wider(
    names_from = "group",
    values_from = c("m", "s", "n")
  )

md_diff <- summary_data$m_exper - summary_data$m_naive
sd_pooled <- sqrt((((summary_data$n_exper - 1) *
  summary_data$s_exper^2) +
  ((summary_data$n_naive - 1) * summary_data$s_naive^2)) /
  (summary_data$n_exper + summary_data$n_naive - 2))
d <- md_diff / sd_pooled

# or we can use the effsize package
# you'll just need to install it before you use it
# you can install it with the following command
# install.package("effsize")
#
# and then use it as follows
# d <- effsize::cohen.d(
#   motor_exp$r_diff,
#   motor_exp$group
# )$estimate

# sample_size <- motor_exp %>%
#   dplyr::group_by(group) %>%
#   dplyr::summarise(n = n())

# Now define the likelihood and plot it
data_model <- likelihood(
  family = "noncentral_d2",
  d = d,
  n1 = summary_data$n_exper,
  n2 = summary_data$n_naive
)

plot(data_model) +
  labs(
    x = "δ", y = "P(Y|θ)",
    title = "Likelihood for:",
    subtitle = glue::glue(
      "d = {round(d,2)},",
      " n1 = {summary_data$n_exper},",
      " n2 = {summary_data$n_naive}"
    )
  ) +
  theme_minimal(14) +
  scale_x_continuous(limits = c(-1, 3), breaks = seq(-1, 3, 1))
```

## Inferences about *t* values

Finally, we'll repeat the last analysis, but in this case we'll model the data
in terms of *t* rather than *d*.

```{r}
#| echo = TRUE, include = TRUE

# Load the data again just in case
motor_exp <- readr::read_csv(
  "https://files.mindsci.net/motor_exp.csv",
  show_col_types = FALSE
)

# Run the t test and extract the t value and df
t_test_res <- t.test(r_diff ~ group,
  motor_exp,
  var.equal = TRUE
) %>%
  broom::tidy() %>%
  dplyr::select(statistic, parameter)

# Now define the likelihood

data_model <- likelihood(
  family = "noncentral_t",
  t = t_test_res$statistic,
  df = t_test_res$parameter
)

# And plot it
plot(data_model) +
  labs(
    x = "t", y = "P(Y|θ)",
    title = "Likelihood for:",
    subtitle = glue::glue(
      "t = {round(t_test_res$statistic,2)},",
      " df = {t_test_res$parameter}"
    )
  ) +
  theme_minimal(14) +
  scale_x_continuous(limits = c(-2, 6), breaks = seq(-2, 6, 2))
```

Using the *non-central t* likelihood might seem a little easier to use, because
it requires less work upfront because we can just use the `t.test` function to
work out the *t* statistic instead of having to work out the *d* value.
However, as we'll see in the section on **priors**, there as advantages to using
the *non-central t* likelihood. This disadvantage is primarily to do with the
fact that the *t* value can change dramatically with sample size---that is, 
very large sample sizes can result in very large *t* values even if the mean 
difference between conditions or groups stays constant. For the *non-central d* 
and *non-central d2* likelihoods this isn't an issue. The *d* value will stay
the same even if the sample size increases and instead, the likelihood will 
just get narrower.

I've covered the *non-central t* likelihood for completeness, but it's almost
never of any real use.

