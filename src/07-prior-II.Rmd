---
output: pdf_document
---
```{r setup, echo=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
suppressMessages(expr = {
  if ("xfun" %in% row.names(installed.packages()) == FALSE) {
    install.packages("xfun")
  }

  display_markdown <<- knitr::asis_output
  display_html <<- knitr::asis_output

  xfun::pkg_attach(
    c(
      "tidyverse",
      "polspline",
      "patchwork",
      "magrittr",
      "bayesplay",
      "knitr",
      "broom",
      "bayesplay"
    ),
    install = TRUE
  )
})

table_format <- "html"
```
# Choosing priors: Part II
<a href="data:text/x-markdown;base64,LS0tCnRpdGxlOiAiUHJpb3JzOiBQYXJ0IDIiCm91dHB1dDogaHRtbF9kb2N1bWVudAotLS0KCmBgYHtyIHNldHVwLCBlY2hvPUZBTFNFLCBtZXNzYWdlID0gRkFMU0UsIHdhcm5pbmcgPSBGQUxTRX0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KGVjaG8gPSBGQUxTRSwgbWVzc2FnZSA9IEZBTFNFLCB3YXJuaW5nID0gRkFMU0UpCnN1cHByZXNzTWVzc2FnZXMoZXhwciA9IHsKICBpZiAoInhmdW4iICVpbiUgcm93Lm5hbWVzKGluc3RhbGxlZC5wYWNrYWdlcygpKSA9PSBGQUxTRSkgewogICAgaW5zdGFsbC5wYWNrYWdlcygieGZ1biIpCiAgfQoKICBkaXNwbGF5X21hcmtkb3duIDw8LSBrbml0cjo6YXNpc19vdXRwdXQKICBkaXNwbGF5X2h0bWwgPDwtIGtuaXRyOjphc2lzX291dHB1dAoKICB4ZnVuOjpwa2dfYXR0YWNoKAogICAgYygKICAgICAgInRpZHl2ZXJzZSIsCiAgICAgICJwb2xzcGxpbmUiLAogICAgICAicGF0Y2h3b3JrIiwKICAgICAgIm1hZ3JpdHRyIiwKICAgICAgImJheWVzcGxheSIsCiAgICAgICJrbml0ciIsCiAgICAgICJicm9vbSIsCiAgICAgICJiYXllc3BsYXkiCiAgICApLAogICAgaW5zdGFsbCA9IFRSVUUKICApCn0pCgp0YWJsZV9mb3JtYXQgPC0gImh0bWwiCmBgYAojIENob29zaW5nIHByaW9yczogUGFydCBJSQoKQWx0aG91Z2ggdGhlIG1ldGhvZCBvZiB1c2luZyBkZWZhdWx0IHByaW9ycyBpcyBlYXN5IHRvIHVzZSBzb21lIGhhdmUKcXVlc3Rpb25lZCB3aGV0aGVyIGl0IHJlYWxseSBtYWtlcyBzZW5zZSB0byB0YWxrIG9mICoqZGVmYXVsdCoqCmh5cG90aGVzZXMuIFRoZSByZWFsIHBvd2VyIG9mIEJheWVzIGZhY3RvcnMgY29tZXMgZnJvbSAqZGlyZWN0bHkgdGVzdGluZwp0aGVvcmllcyosIGFuZCBhcyBbRGllbmVzCigyMDE5KV0oaHR0cHM6Ly9kb2kub3JnLzEwLjExNzcvMjUxNTI0NTkxOTg3Njk2MCkgcG9pbnRzIG91dCwgInRoZXJlIGlzIG5vCnN1Y2ggdGhpbmcgYXMgYSBkZWZhdWx0IHRoZW9yeSwgc28gdGhlcmUgY2Fubm90IGJlIGEgZGVmYXVsdCIgYWx0ZXJuYXRpdmUKaHlwb3RoZXNpcy4gRGllbmVzIGluc3RlYWQgcmVjb21tZW5kcyBmb3JtdWxhdGluZyBwcmlvcnMgZm9yIG91ciBzcGVjaWZpYwpzaXR1YXRpb24gYXQgaGFuZC4gVGhhdCBpcywgZm9ybXVsYXRpbmcgcHJpb3JzIHRoYXQgYWN0dWFsbHkgbWF0Y2ggb3VyCnNjaWVudGlmaWMgdGhlb3JpZXMgYWJvdXQgaG93IHRoZSB3b3JsZCB3b3Jrcy4KClRoZSBzZWNvbmQgc2V0IG9mIHByaW9ycyB0aGF0IHdlIGRldmVsb3BlZCBmb3IgdGhlIGNvaW4gZmxpcCBleGFtcGxlcwpyZXByZXNlbnRzIGEgY2FzZSBvZiBkb2luZyB0aGlzLiBJbnN0ZWFkIG9mIHNheWluZyB0aGF0IG91ciBhbHRlcm5hdGl2ZQpoeXBvdGhlc2lzIHNob3VsZCByZXByZXNlbnQgZWFjaCBvdXRjb21lIGFzIGJlaW5nIGVxdWFsbHkgbGlrZWx5IHdlIGluc3RlYWQKY2FtZSB1cCB3aXRoIGEgdGhlb3J5IG9mIGhvdyBiaWFzZWQgY29pbnMgYXJlIGxpa2VseSB0byBiZWhhdmUuIEluIGZhY3QsIHdlCmNhbWUgdXAgd2l0aCBhIGZldyB0aGVvcmllcy4gT25lIHRoZW9yeSwgZm9yIGV4YW1wbGUsIHNhaWQgdGhhdCBiaWFzZWQgY29pbnMKd291bGQgc2hvdyBoZWFkcyBtb3JlIG9mdGVuLiBBbmQgYW5vdGhlciB0aGVvcnkgc2FpZCB0aGF0IGJpYXNlZCBjb2lucyB3b3VsZApiZWhhdmUgc2ltaWxhcmx5IHRvIGZhaXIgY29pbnM7IGhvd2V2ZXIsIHRoZXkgd291bGQgc2hvdyBoZWFkcyBvciB0YWlscwpzbGlnaHRseSBsZXNzIG9mdGVuIHRoYW4gd291bGQgYmUgZXhwZWN0ZWQgZnJvbSBhIGZhaXIgY29pbi4gV2Ugd2VyZSBhYmxlIHRvCmNvbWUgdXAgd2l0aCBwcmlvcnMgdGhhdCBkaXJlY3RseSByZXByZXNlbnRlZCB0aGVzZSB0aGVvcmllcyBhbmQgd2Ugd2VyZSBhYmxlCnRvIGNvbXB1dGUgQmF5ZXMgZmFjdG9ycyBjb21wYXJpbmcgdGhlc2UgdGhlb3JpZXMgd2l0aCBvdXIgZmFpciBjb2luIHRoZW9yeQoodGhhdCB0aGUgYmlhcyBpcyBleGFjdGx5IDAuNSkuCgpPZiBjb3Vyc2UgdXNpbmcgdGhlc2Uga2luZHMgb2YgcHJpb3JzIGlzIGZhciBtb3JlIGRpZmZpY3VsdCB0aGFuIHVzaW5nCmRlZmF1bHQgcHJpb3JzIGJlY2F1c2UgaXQgZm9yY2VzIHVzIHRvIHRoaW5rIGFib3V0IHdoYXQgb3VyIHNjaWVudGlmaWMKdGhlb3JpZXMgcHJlZGljdC4gSG93ZXZlciwgYXMgc2NpZW50aXN0cywgd2UgcHJvYmFibHkgc2hvdWxkIGJlIHRoaW5raW5nCmFib3V0IHdoYXQgb3VyIHRoZW9yaWVzIHByZWRpY3QhIEJ1dCBrbm93aW5nIHdoYXQgb3VyIHNjaWVudGlmaWMgdGhlb3JpZXMKcHJlZGljdCBpcyBhIHZlcnkgZGlmZmljdWx0IHRhc2sgYW5kLCBhcyBwc3ljaG9sb2d5IHJlc2VhcmNoZXJzIHdlIGFyZSBub3QKd2VsbCB0cmFpbmVkIHRvIHRoaW5rIGluIHRlcm1zIG9mIHF1YW50aXRhdGl2ZSBwcmVkaWN0aW9ucy4gVGhpcyBpcwpsaWtlbHkgYW4gYXJ0ZWZhY3Qgb2YgdGhlIGRvbWluYW5jZSBvZiAqbnVsbC1oeXBvdGhlc2lzIHNpZ25pZmljYW5jZQp0ZXN0aW5nKiBpbiBwc3ljaG9sb2d5LCBiZWNhdXNlIHRoZXNlIGtpbmRzIG9mIHN0YXRpc3RpY2FsIHByb2NlZHVyZXMKZW5jb3VyYWdlIHRoaW5raW5nIGluIHRlcm1zIG9mICpkZWZhdWx0KiBoeXBvdGhlc2VzIChzZWUgW0NvbGxpbmcgJiBTesWxY3MsCjIwMjBdKGh0dHBzOi8vbGluay5zcHJpbmdlci5jb20vY29udGVudC9wZGYvMTAuMTAwNy9zMTMxNjQtMDE4LTA0MjEtNC5wZGYpKS4KVGhlcmVmb3JlLCBhZG9wdGluZyBCYXllc2lhbiBtZXRob2RzIGNhbiByZXF1aXJlIGEgYmlnIGNoYW5nZSBpbiBob3cgd2UKdGhpbmsgYWJvdXQgKip0aGVvcnkqKiBpbiBwc3ljaG9sb2d5LiAKClRoZSBhaW0gb2YgdGhpcyBzZWN0aW9uIGlzIG5vdCB0byB0ZWFjaCB5b3UgaG93IHRvIGRvIGdvb2QgKip0aGVvcnkqKi4gSW5zdGVhZCwKdGhlIGFpbSBpcyB0byBnaXZlIHlvdSB0aGUgdG9vbHMgdG8gdGVzdCB0aGVvcmllcyBvbmNlIHlvdSd2ZSBjb21lIHVwIHdpdGgKdGhlbS4gVGhlIGhvcGUgaXMgdGhhdCBvbmNlIHlvdSBoYXZlIHRoZSB0b29scywgdGhlbiBjb21lIHVwIHdpdGggdGhlb3JpZXMgdGhhdAphcmUgdGVzdGFibGUgd2l0aCB0aG9zZSB0b29scy4gVG8gZG8gdGhpcywgd2UnbGwgbG9vayBhdCBzb21lIGV4YW1wbGVzIG9mIGhvdwp0byByZXByZXNlbnQgYW5kIHRoZW4gdGVzdCB0aGVvcmllcyB3aXRoIEJheWVzIGZhY3RvcnMuIEZvbGxvd2luZyB0aGlzLCB3ZSdsbApjb3ZlciBzb21lIGhldXJpc3RpY3MgZm9yIGNvbWluZyB1cCB3aXRoIHByZWRpY3Rpb25zIGlmIHdlJ3JlIHVuc3VyZSB3aGF0Cm91ciB0aGVvcmllcyBwcmVkaWN0LgoKIyMgRXhhbXBsZXMgb2YgcmVwcmVzZW50aW5nIHByZWRpY3Rpb25zCgojIyMgUmVwcmVzZW50aW5nIHByZWRpY3Rpb25zIHdpdGggYSB1bmlmb3JtIHByaW9yCgpUaGUgbW9zdCBzdHJhaWdodGZvcndhcmQgd2F5IHRvIHJlcHJlc2VudCB0aGUgcHJlZGljdGlvbnMgb2YgYSB0aGVvcnkgaXMKd2l0aCBhIHVuaWZvcm0gcHJpb3IuIEEgdW5pZm9ybSBwcmlvciBlc3NlbnRpYWxseSByZXByZXNlbnRzIHRoZSBpZGVhCnRoYXQsIGlmIHRoZXJlIGlzIGFuIGVmZmVjdCwgdGhlbiBpdCB3aWxsIGJlIHNvbWUgdmFsdWUgYmV0d2VlbiBhIGRlZmluZWQKbWluaW11bSBhbmQgYSBkZWZpbmVkIG1heGltdW0sIHdpdGggYWxsIGVmZmVjdHMgYmVpbmcgZXF1YWxseSBwcm9iYWJsZS4KCkhlcmUgaXMgYW4gZXhhbXBsZSB0YWtlbiBmcm9tIFtEaWVuZXMKKDIwMTQpXShodHRwczovL3d3dy5mcm9udGllcnNpbi5vcmcvYXJ0aWNsZXMvMTAuMzM4OS9mcHN5Zy4yMDE0LjAwNzgxL2Z1bGwpLgpJbiB0aGlzIGV4YW1wbGUgZXhwZXJpbWVudCwgbmVnYXRpdmUgbW9vZCB3YXMgKnByZWRpY3RlZCB0byByZWR1Y2UKbGVhcm5pbmcgb24gYSB0YXNrKi4gTGVhcm5pbmcgd2FzIG1lYXN1cmVkIHVzaW5nIGEgdHdvLWFsdGVybmF0aXZlIGZvcmNlZApjaG9pY2UgbWVhc3VyZSAoY2hhbmNlIHBlcmZvcm1hbmNlIHdvdWxkIGJlIDUwJSkuIEl0IHdhcyBmb3VuZCB0aGF0LCBpbgp0aGUgKm5ldXRyYWwgbW9vZCBjb25kaXRpb24qIHBlcmZvcm1hbmNlIG9uIHRoZSB0YXNrIHdhcyBhdCA3MCUuIElmCipuZWdhdGl2ZSBtb29kKiByZWR1Y2VkIGxlYXJuaW5nLCB0aGUgcG9wdWxhdGlvbiBtZWFuIG9mIHRoaXMgY29uZGl0aW9uCndvdWxkIGhhdmUgdG8gbGllIHNvbWV3aGVyZSBiZXR3ZWVuIGNoYW5jZSBwZXJmb3JtYW5jZSAoNTAlKSBhbmQKcGVyZm9ybWFuY2Ugb24gdGhlIG5ldXRyYWwgY29uZGl0aW9uICg3MCUpLiBUaGVyZWZvcmUsIHRoZSBkaWZmZXJlbmNlCmJldHdlZW4gY29uZGl0aW9ucyB3b3VsZCBoYXZlIHRvIGJlIGJldHdlZW4gMCUgYW5kIDIwJS4gCgpXZSBjb3VsZCByZXByZXNlbnQgdGhpcyBhcyBhIHVuaWZvcm0gcHJpb3Igd2l0aCBhIG1pbmltdW0gb2YgMCBhbmQKYSBtYXhpbXVtIG9mIDIwLiBUaGUgY29kZSBiZWxvdyBkb2VzIGp1c3QgdGhhdC4KCmBgYHtyfQojfCBlY2hvID0gVFJVRSwgaW5jbHVkZSA9IFRSVUUKCm1vb2RfdGhlb3J5IDwtIHByaW9yKGZhbWlseSA9ICJ1bmlmb3JtIiwgbWluID0gMCwgbWF4ID0gMjApCgpwbG90KG1vb2RfdGhlb3J5KSArCiAgdGhlbWVfbWluaW1hbCgxNCkgKwogIGxhYnMoeCA9ICJtZWFuIGRpZmZlcmVuY2UiLCB5ID0gInByb2JhYmlsaXR5IikKYGBgCgpOb3cgd2hhdCBkbyB0aGUgZGF0YSBzYXk/IFRoZSByZXN1bHRzIHJlcG9ydCBhIG1lYW4gb2YgNjUlIGluIHRoZSBuZWdhdGl2ZQptb29kIGNvbmRpdGlvbiAobWVhbiBkaWZmZXJlbmNlIG9mIDUlKSB3aXRoIGEgc3RhbmRhcmQgZXJyb3IgKHN0YW5kYXJkCmRldmlhdGlvbiBvZiB0aGUgbWVhbiBkaWZmZXJlbmNlKSBvZiAxMC4gV2UgY2FuIHJlcHJlc2VudCB0aGlzIGRhdGEgd2l0aAp0aGUgY29kZSBiZWxvdy4gRm9sbG93aW5nIERpZW5lcyAoMjAxNCksIHdlJ2xsIHVzZSBhICpub3JtYWwqIGxpa2VsaWhvb2QuIAoKYGBge3J9CiN8IGVjaG8gPSBUUlVFLCBpbmNsdWRlID0gVFJVRQoKZGF0YV9tb2RlbCA8LSBsaWtlbGlob29kKGZhbWlseSA9ICJub3JtYWwiLCBtZWFuID0gNSwgc2QgPSAxMCkKCnBsb3QoZGF0YV9tb2RlbCkgKwogIHRoZW1lX21pbmltYWwoMTQpICsKICBsYWJzKHggPSAibWVhbiBkaWZmZXJlbmNlIiwgeSA9ICJsaWtlbGlob29kIikKYGBgCgpGaW5hbGx5LCB3ZSdsbCB1c2UgYSBudWxsIHByaW9yIG9mIGEgcG9pbnQgYXQgMCB0byByZXByZXNlbnQgb3VyICpubyBlZmZlY3QqCmh5cG90aGVzaXMuIAoKYGBge3J9CiN8IGVjaG8gPSBUUlVFLCBpbmNsdWRlID0gVFJVRQoKbnVsbF90aGVvcnkgPC0gcHJpb3IoZmFtaWx5ID0gInBvaW50IiwgcG9pbnQgPSAwKQoKcGxvdChudWxsX3RoZW9yeSkgKwogIHRoZW1lX21pbmltYWwoMTQpICsKICBsYWJzKHggPSAibWVhbiBkaWZmZXJlbmNlIiwgeSA9ICJwcm9iYWJpbGl0eSIpCmBgYAoKCldpdGggYWxsIHRoZSBwYXJ0cyBpbiBwbGFjZSwgd2UgY2FuIG5vdyBjb21wdXRlIHRoZSBCYXllcyBmYWN0b3IuCgpgYGB7cn0KI3wgZWNobyA9IFRSVUUsIGluY2x1ZGUgPSBUUlVFCgptb29kX2V2aWRlbmNlIDwtIGludGVncmFsKGRhdGFfbW9kZWwgKiBtb29kX3RoZW9yeSkKbnVsbF9ldmlkZW5jZSA8LSBpbnRlZ3JhbChkYXRhX21vZGVsICogbnVsbF90aGVvcnkpCgpiZiA8LSBtb29kX2V2aWRlbmNlIC8gbnVsbF9ldmlkZW5jZQpgYGAKClRoZSByZXN1bHRpbmcgQmF5ZXMgZmFjdG9yIGlzIGJhcmVseSBkaWZmZXJlbnQgdG8gMS4gVGhlcmVmb3JlLCB0aGUKcmVzdWx0cyBkb24ndCByZWFsbHkgZ2l2ZSB1cyBhIHN0cm9uZyByZWFzb24gZm9yIGZhdm91cmluZyBvbmUgdGhlb3J5IG92ZXIKdGhlIG90aGVyLiAKClNvbWV0aW1lcyBpdCBpcyB1c2VmdWwgdG8gaGF2ZSB2ZXJiYWwgbGFiZWxzIGZvciB0aGUgc3RyZW5ndGggb2YgZXZpZGVuY2UuCldhZ2VubWFrZXJzIGV0IGFsICgyMDE3KSBzdWdnZXN0cyBzb21lIHZlcmJhbCBsYWJlbHMgZm9yIHN0cmVuZ3RoIG9mCmV2aWRlbmNlLCBhbmQgd2UgY2FuIGdldCB0aGUgdmVyYmFsIGxhYmVsIGZvciB0aGUgY29tcHV0ZWQgQmF5ZXMgZmFjdG9yIGJ5CnVzaW5nIHRoZSBgc3VtbWFyeWAgZnVuY3Rpb24sIGFzIHNob3duIGJlbG93LgoKYGBge3J9CiN8IGVjaG8gPSBUUlVFLCBpbmNsdWRlID0gVFJVRQoKc3VtbWFyeShiZikKYGBgCgojIyMgUmVwcmVzZW50aW5nIHByZWRpY3Rpb25zIHdpdGggYSBoYWxmLW5vcm1hbCBwcmlvcgoKQSBoYWxmIG5vcm1hbCBkaXN0cmlidXRpb24gaXMgYW5vdGhlciB1c2VmdWwgd2F5IHRvIHJlcHJlc2VudCBwcmVkaWN0aW9ucyBmb3IKdGhlb3JpZXMuIFRvIGNvbWUgdXAgd2l0aCBwcmVkaWN0aW9ucyBmb3IgdGhlIHRoZW9yeSwgd2UnbGwgdXNlIHRoZSByZXN1bHRzCmZyb20gYW4gZWFybGllciBleHBlcmltZW50IHRvIHJlcHJlc2VudCB0aGUgcHJlZGljdGlvbnMgb2YgdGhlIGN1cnJlbnQKZXhwZXJpbWVudC4KCkhlcmUgaXMgYW4gZXhhbXBsZSB0YWtlbiBmcm9tIFtEaWVuZXMgYW5kIE1jbGF0Y2hpZQooMjAxOCldKGh0dHBzOi8vbGluay5zcHJpbmdlci5jb20vYXJ0aWNsZS8xMC4zNzU4L3MxMzQyMy0wMTctMTI2Ni16KS4gSW4gYQpzdHVkeSBieSBXaWxsaWFtcyBhbmQgQmFyZ2ggKDIwMDgpLCBwZW9wbGUgd2VyZSBhc2sgdG8gZmVlbCBhIGhvdCBvciBjb2xkCnRoZXJhcGV1dGljIHBhY2sgYW5kIHRoZW4gY2hvb3NlIGEgdHJlYXQgZm9yIHRoZW1zZWx2ZXMgb3IgZm9yIGEgZnJpZW5kLiBPZgp0aG9zZSBwYXJ0aWNpcGFudHMgZXhwb3NlZCB0byBhIGNvbGQgcGFjaywgNzUlIGNob3NlIGEgdHJlYXQgZm9yIHRoZW1zZWx2ZXMKd2hlcmUgb25seSA0NSUgY2hvc2UgdGhlIHRyZWF0IGZvciB0aGVpciBmcmllbmQuIFdlIGNhbiBleHByZXNzIHRoaXMgZGlmZmVyZW5jZQphcyBhbiBPZGRzIFJhdGlvIChPUikuIFRoaXMgZ2l2ZXMgYW4gT1Igb2YgMy41Miwgd2hpY2ggY29udmVydGVkIGludG8gTG9nIE9kZHMKKExvZyBPUikgaXMgYXBwcm94aW1hdGVseSAxLjI2LiBXZSB0YWtlIHRoZSBuYXR1cmFsIGxvZyBvZiB0aGUgb2RkcyByYXRpbywKYmVjYXVzZSB0aGUgbmF0dXJhbCBsb2cgb2YgdGhlIG9kZHMgcmF0aW8gaXMgYXBwcm94aW1hdGVseSBub3JtYWxseQpkaXN0cmlidXRlZCwgd2hpY2ggbWVhbnMgdGhhdCB3ZSBjYW4gbW9kZWwgaXQgd2l0aCBhICpub3JtYWwqIGxpa2VsaWhvb2QuCgpBZnRlciB0aGUgb3JpZ2luYWwgc3R1ZHksIEx5bm90dCBldCBhbCAoMjAxNCkgYXR0ZW1wdGVkIGEgcmVwbGljYXRpb24uIEJlZm9yZQp3ZSBnZXQgdG8gdGhlIGRhdGEgdGhhdCBMeW5vdHQgZXQgYWwgKDIwMTQpIG9idGFpbmVkLCBsZXQncyB0aGluayBhYm91dCBhIHBvc3NpYmxlCnByZWRpY3Rpb24uIAoKSWYgdGhlIG9yaWdpbmFsIHN0dWR5IHJlcG9ydGVkIGEgdHJ1ZSBlZmZlY3QsIHRoZW4gdGhlIHJlcGxpY2F0aW9uIHN0dWR5CnNob3VsZCBmaW5kIGFuIGVmZmVjdCBvZiByb3VnaGx5IHRoZSBzYW1lIG9yZGVyIG9mIG1hZ25pdHVkZS4gTWF5YmUKc21hbGxlciwgbWF5YmUgbGFyZ2VyLCBidXQgbm90IHJhZGljYWxseSBkaWZmZXJlbnQuCgpGdXJ0aGVybW9yZSwgaXQncyBhbHNvIGZhaXIgdG8gYXNzdW1lIHRoYXQgcmVwb3J0ZWQgZWZmZWN0cyBhcmUgdXN1YWxseSBsYXJnZXIKdGhhbiB0aGUgdHJ1ZSBlZmZlY3QsIGJlY2F1c2UgbGFyZ2VyIGVmZmVjdHMgYXJlIG1vcmUgbGlrZWx5IHRvIGdldCBwdWJsaXNoZWQuClNvIHRoZSB0cnVlIGVmZmVjdCBpcyBtb3JlIGxpa2VseSB0byBiZSBzbWFsbGVyIHRoZW4gdGhlIHJlcG9ydGVkIGVmZmVjdCwgYW5kCmxlc3MgbGlrZWx5IHRvIGJlIGxhcmdlci4gSG93IG1pZ2h0IHdlIHJlcHJlc2VudCB0aGlzIGlkZWE/IE9uZSB3YXkgaXMgd2l0aCBhCmhhbGYgbm9ybWFsIGRpc3RyaWJ1dGlvbiBzY2FsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcmlnaW5hbCBmaW5kaW5nLiBUaGF0IGlzLAp3aXRoIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbiBjZW50cmVkIGF0IDAsIGFuZCB3aXRoIGEgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIDEuMjYKKHRoYXQgaXMsIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG9yaWdpbmFsIGVmZmVjdCkuIEZ1cnRoZXJtb3JlLCB3ZSdsbCBsaW1pdCB0aGUKZGlzdHJpYnV0aW9uIHRvIGJlIGJldHdlZW4gdGhlIHZhbHVlcyBvZiAkMCQgYW5kICQrXGluZmluJCAoYmVjYXVzZSB3ZSBoYXZlIGEKZGlyZWN0aW9uYWwgaHlwb3RoZXNpcykuCgpgYGB7cn0KI3wgZWNobyA9IFRSVUUsIGluY2x1ZGUgPSBUUlVFCgp0aGVvcnlfbW9kZWwgPC0gcHJpb3IoCiAgZmFtaWx5ID0gIm5vcm1hbCIsCiAgbWVhbiA9IDAsCiAgc2QgPSAxLjI2LAogIHJhbmdlID0gYygwLCBJbmYpCikKCnBsb3QodGhlb3J5X21vZGVsKSArCiAgdGhlbWVfbWluaW1hbCgxNCkKYGBgCgpCeSBkZWZpbmluZyB0aGUgcHJpb3IgaW4gdGhpcyB3YXksIHdlJ3JlIHNheWluZyB0aGF0IH42OCUgb2YgdGhlIHBsYXVzaWJsZQplZmZlY3RzIGxpZSBiZXR3ZWVuIDAgYW5kIDEuMjYuIEFuZCB+OTUlIG9mIHBsYXVzaWJsZSB0aGUgZWZmZWN0cyBsaWUgc29tZXdoZXJlCmJldHdlZW4gMCBhbmQgdHdpY2UgdGhlIHJlcG9ydGVkIG9yaWdpbmFsIGVmZmVjdCAob2YgMS4yNikuIFRoYXQgaXMsIHdlIHByZWRpY3QKdGhlIGVmZmVjdCB0byBiZSBzb21ld2hlcmUgaW4gdGhlIHNhbWUgcmFuZ2UgYXMgdGhlIG9yaWdpbmFsIHN0dWR5LCBidXQgbW9yZQpwcm9iYWJseSBzbWFsbGVyIHRoYW4gdGhlIGVmZmVjdCBvcmlnaW5hbGx5IHJlcG9ydGVkLgoKTm93IHRoYXQgd2UgaGF2ZSBvdXIgcHJlZGljdGlvbnMsIHdlIGNhbiBsb29rIGF0IHRoZSByZXN1bHRzIG9mIEx5bm90dCBldCBhbCdzCnJlcGxpY2F0aW9uIGF0dGVtcHQuIFRoZWlyIHJlc3VsdHMgc2hvd2VkIGEgTG9nIE9SIG9mIC0wLjI2LCB3aXRoIGEgc3RhbmRhcmQKZXJyb3Igb2YgMC4xNC4gKE5vdGUsIHRoYXQgdHlwaWNhbGx5LCBzdHVkaWVzIGRvbid0IHJlcG9ydCB0aGUgc3RhbmRhcmQgZXJyb3IKb2YgdGhlIExvZyBPUiwgYnV0IHJhdGhlciByZXBvcnQgdGhlIDk1JSBjb25maWRlbmNlIGludGVydmFsIG9mIHRoZSBPUi4KSG93ZXZlciwgaXQncyBwb3NzaWJsZSB0byBjb21wdXRlIHRoZSBzdGFuZGFyZCBlcnJvciBvZiB0aGUgTG9nIE9SIGZyb20gdGhlIDk1JQpjb25maWRlbmNlIGludGVydmFsLCBhcyBzaG93biBiZWxvdykuIEFzIG1lbnRpb25lZCBhYm92ZSwgYmVjYXVzZSBMb2cgT1IKYXBwcm94aW1hdGVseSBmb2xsb3dzIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbiwgd2UgY2FuIG1vZGVsIGl0IHVzaW5nIHRoZSAqbm9ybWFsKgpsaWtlbGlob29kLCBhcyBzaG93biBiZWxvdy4gCgpgYGB7cn0KI3wgZWNobyA9IFRSVUUsIGluY2x1ZGUgPSBUUlVFCgojIEZvciBjb21wbGV0ZW5lc3MsIHdlJ2xsIHdvcmsgb3V0IHRoZSBsbiBPUiBhbmQKIyB0aGUgc3RhbmRhcmQgZXJyb3IgZnJvbSB0aGUgcmVwb3J0ZWQgY29uZmlkZW5jZQojIGludGVydmFsCgpyZXBvcnRlZF9vcl9jaSA8LSBjKDAuNTgsIDEuMDIpCgpsb2dfb3JfY2kgPC0gbG9nKHJlcG9ydGVkX29yX2NpKQpsb2dfb3IgPC0gbWVhbihsb2dfb3JfY2kpCmxvZ19vcl9jaV93aWR0aCA8LSBhYnMobG9nX29yX2NpWzFdIC0gbG9nX29yKQpsb2dfb3Jfc2UgPC0gbG9nX29yX2NpX3dpZHRoIC8gMS45NgoKZGF0YV9tb2RlbCA8LSBsaWtlbGlob29kKAogIGZhbWlseSA9ICJub3JtYWwiLAogIG1lYW4gPSBsb2dfb3IsCiAgc2QgPSBsb2dfb3Jfc2UKKQoKcGxvdChkYXRhX21vZGVsKSArCiAgdGhlbWVfbWluaW1hbCgxNCkKYGBgCgpGaW5hbGx5LCBmb3Igb3VyIG51bGwgaHlwb3RoZXNpcywgd2UnbGwganVzdCB1c2UgYSBwb2ludCBhdCAwLiBXaXRoIGFsbCB0aGUKYml0J3MgaW4gcGxhY2UsIHdlIGNhbiBjb21wdXRlIHRoZSBCYXllcyBmYWN0b3IuIFRoZSBjb2RlIGJlbG93IGlzIGdlbmVyYXRlZAp1c2luZyB0aGUgd2ViLWFwcC4gSG93ZXZlciwgSSd2ZSBqdXN0IHJlbW92ZWQgdGhlIGZpbmFsIGxpbmVzIHRoYXQgZ2VuZXJhdGUgdGhlCnBsb3RzLiBZb3UgY2FuIGFjY2VzcyB0aGUgd2ViLWFwcCdzIGFkdmFuY2VkIG91dHB1dCBhdCB0aGUgW2ZvbGxvd2luZwpsaW5rXShodHRwczovL2JheWVzcGxheS5jb2xsaW5nLm5ldC5uei9hZHZhbmNlZD9tb2RlbD0lN0IlMjJsaWtlbGlob29kRGVmJTIyJTNBJTdCJTIyZGlzdHJpYnV0aW9uJTIyJTNBJTIybm9ybWFsJTIyJTJDJTIycGFyYW1ldGVycyUyMiUzQSU3QiUyMm1lYW4lMjIlM0EtMC4yNjI0NjIzJTJDJTIyc2QlMjIlM0EwLjE0NDAxMjclN0QlN0QlMkMlMjJhbHRwcmlvckRlZiUyMiUzQSU3QiUyMmRpc3RyaWJ1dGlvbiUyMiUzQSUyMm5vcm1hbCUyMiUyQyUyMnBhcmFtZXRlcnMlMjIlM0ElN0IlMjJtZWFuJTIyJTNBMCUyQyUyMnNkJTIyJTNBMS4yNiUyQyUyMm1pbiUyMiUzQTAlMkMlMjJtYXglMjIlM0FudWxsJTdEJTdEJTJDJTIybnVsbHByaW9yRGVmJTIyJTNBJTdCJTIyZGlzdHJpYnV0aW9uJTIyJTNBJTIycG9pbnQlMjIlMkMlMjJwYXJhbWV0ZXJzJTIyJTNBJTdCJTIycG9pbnQlMjIlM0EwJTdEJTdEJTdEKS4KCmBgYHtyfQojfCBlY2hvID0gVFJVRSwgaW5jbHVkZSA9IFRSVUUKCiMgZGVmaW5lIGxpa2VsaWhvb2QKZGF0YV9tb2RlbCA8LSBsaWtlbGlob29kKGZhbWlseSA9ICJub3JtYWwiLCBtZWFuID0gLTAuMjYyNDYyMywgc2QgPSAwLjE0NDAxMjcpCgojIGRlZmluZSBhbHRlcm5hdGl2ZSBwcmlvcgphbHRfcHJpb3IgPC0gcHJpb3IoZmFtaWx5ID0gIm5vcm1hbCIsIG1lYW4gPSAwLCBzZCA9IDEuMjYsIHJhbmdlID0gYygwLCBJbmYpKQoKIyBkZWZpbmUgbnVsbCBwcmlvcgpudWxsX3ByaW9yIDwtIHByaW9yKGZhbWlseSA9ICJwb2ludCIsIHBvaW50ID0gMCkKCiMgd2VpZ2h0IGxpa2VsaWhvb2QgYnkgcHJpb3IKbTEgPC0gZGF0YV9tb2RlbCAqIGFsdF9wcmlvcgptMCA8LSBkYXRhX21vZGVsICogbnVsbF9wcmlvcgoKIyB0YWtlIHRoZSBpbnRlcmdhbCBvZiBlYWNoIHdlaWdodGVkIGxpa2VsaWhvb2QKIyBhbmQgZGl2aWRlIHRoZW0KYmYgPC0gaW50ZWdyYWwobTEpIC8gaW50ZWdyYWwobTApCgojIGdldCBhIHZlcmJhbCBkZXNjcmlwdGlvbiBvZiB0aGUgQmF5ZXMgZmFjdG9yCnN1bW1hcnkoYmYpCgpgYGAKClRoZSByZXN1bHRzIHNob3csIHN0cm9uZyBldmlkZW5jZSBmb3IgdGhlIG51bGwgaHlwb3RoZXNpcyBvdmVyIHRoZQphbHRlcm5hdGl2ZSBoeXBvdGhlc2lzLiBUaGUgcmVzdWx0cyBhcmUgJFxmcmFjezF9ezAuMDQxMX1cYXBwcm94MjQkIHRpbWVzCm1vcmUgbGlrZWx5IHVuZGVyIG91ciBudWxsIGh5cG90aGVzaXMgdGhhbiBvdXIgYWx0ZXJuYXRpdmUgaHlwb3RoZXNpcy4KCiMjIyBSZXByZXNlbnRpbmcgcHJlZGljdGlvbnMgd2l0aCB0aGUgbm9ybWFsIHByaW9yCgpJbiB0aGUgcHJlY2VkaW5nIHR3byBleGFtcGxlcywgd2UgaGFkIGRpcmVjdGlvbmFsIGh5cG90aGVzZXMuIFRoaXMgbWVhbnQKdGhhdCBhbGwgb3VyIHByaW9ycyB3ZXJlIHRydW5jYXRlZCBhdCBvbmUgZW5kIGF0IDAuIEJ1dCBzb21ldGltZXMgd2UgZG9uJ3QKaGF2ZSBkaXJlY3Rpb25hbCBoeXBvdGhlc2VzLiBJbnN0ZWFkLCB3ZSBtaWdodCBoYXZlIG5vbi1kaXJlY3Rpb25hbApoeXBvdGhlc2VzLiBJZiB3ZSBoYXZlIG5vbi1kaXJlY3Rpb25hbCBoeXBvdGhlc2VzIHRoZW4gd2UgY2FuIHVzZSBhICpmdWxsKgpub3JtYWwgZGlzdHJpYnV0aW9uLCByYXRoZXIgdGhhbiBvbmUgdGhhdCdzIGJlZW4gbGltaXRlZCB0byBiZSBiZXR3ZWVuICQwJAphbmQgJCtcaW5maW4kLiAKCkZ1cnRoZXJtb3JlLCBpdCBpcyBhbHNvIG5vdCBuZWNlc3NhcnkgdG8gaGF2ZSBub3JtYWwgZGlzdHJpYnV0aW9ucyBjZW50cmVkCmF0IDAuIFdlIG1pZ2h0IHVzZSBhIG5vcm1hbCBkaXN0cmlidXRpb24gY2VudHJlZCBhdCBzb21lIG90aGVyIHZhbHVlIHRvCnJlcHJlc2VudCB0aGUgaWRlYSB0aGF0IHRoZSBlZmZlY3QgaXMgcm91Z2hseSB3aXRoIGluIGEgY2VydGFpbiByYW5nZSBidXQgd2l0aApzbWFsbGVyIGVmZmVjdHMgYmVpbmcgbW9yZSBwcm9iYWJsZSB0aGFuIGxhcmdlciBlZmZlY3RzLiBUbyBzZWUgaG93IHRoaXMgd29ya3MsCndlJ2xsIGdvIHRocm91Z2ggYW4gZXhhbXBsZSBpbiBbRGllbmVzCigyMDE5KV0oaHR0cHM6Ly9kb2kub3JnLzEwLjExNzcvMjUxNTI0NTkxOTg3Njk2MCkuCgpGdSBldCBhbCAoMjAxMykgd2VyZSBpbnRlcmVzdGVkIGluIHdoZXRoZXIgdGhlcmUgYXJlIGRpZmZlcmVuY2VzIGluIGxlYXJuaW5nCmdsb2JhbCBhbmQgbG9jYWwgc3RydWN0dXJlIGJldHdlZW4gcGVvcGxlIGluIENoaW5hIGFuZCB0aGUgVUssIGFuZCBhIHJlYWN0aW9uCnRpbWUgdGFzayB3YXMgdXNlZCB0byBhc3Nlc3MgdGhpcy4gVGhlIHJlc3VsdHMgc2hvd2VkIHRoYXQgd2hlbiBpdCBjYW1lIHRvCipnbG9iYWwgc3RydWN0dXJlKiwgcGVvcGxlIGluIENoaW5hIGhhZCBzdXBlcmlvciBwZXJmb3JtYW5jZSByZWxhdGl2ZSB0byBwZW9wbGUKaW4gdGhlIFVLLiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gZ3JvdXBzIHdhcyA1MCBtcyAod2l0aCBhIHN0YW5kYXJkCmVycm9yIG9mIDE0IG1zKS4gSG93ZXZlciwgZm9yICpsb2NhbCBzdHJ1Y3R1cmUqIGxlYXJuaW5nLCB0aGUgZGlmZmVyZW5jZSB3YXMKb25seSAxNSBtcyAoc3RhbmRhcmQgZXJyb3Igb2YgMTMgbXMpLiAKCkZ1IGV0IGFsICgyMDEzKSB3YW50ZWQgdG8gdGVzdCB0aGUgdGhlb3J5IHRoYXQgcGVvcGxlIGluIENoaW5hIHNpbXBseSBzY29yZWQKaGlnaGVyIG9uIHRoZSBsZWFybmluZyB0YXNrIChpcnJlc3BlY3RpdmUgb2YgZ2xvYmFsIG9yIGxvY2FsIGZlYXR1cmVzKQpiZWNhdXNlIG9mIGhpZ2hlciBtb3RpdmF0aW9uIGxldmVscy4gSWYgbW90aXZhdGlvbiBsZXZlbHMgd2VyZSB0aGUgb25seQpjYXVzZSBvZiB0aGUgZGlmZmVyZW5jZXMgdGhlbiB0aGUgZ3JvdXAgZGlmZmVyZW5jZSBpbiB0aGUgZ2xvYmFsIHRhc2sgYW5kIHRoZQpncm91cCBkaWZmZXJlbmNlIGluIHRoZSBsb2NhbCB0YXNrIHNob3VsZCBiZSB0aGUgc2FtZS4KCkFzIGEgcmVzdWx0LCB3ZSBjb3VsZCB1c2UgdGhlIHJlc3VsdHMgZnJvbSB0aGUgZ2xvYmFsIHRhc2sgKG1lYW4gZGlmZmVyZW5jZSBvZgo1MCB3aXRoIGFuIHN0YW5kYXJkIGVycm9yIG9mIDE0KSB0byByZXByZXNlbnQgb3VyIHByZWRpY3Rpb25zIGFib3V0IHRoZSBsb2NhbAp0YXNrLiBUaGF0IGlzLCB3ZSBjYW4gdXNlIGEgbm9ybWFsIHByaW9yIHdpdGggYSBtZWFuIG9mIDUwIGFuZCBhIHN0YW5kYXJkCmRldmlhdGlvbiBvZiAxNCwgYXMgc2hvd24gYmVsb3cuCgpgYGB7cn0KI3wgZWNobyA9IFRSVUUsIGluY2x1ZGUgPSBUUlVFCgptb3RpdmF0aW9uX3RoZW9yeSA8LSBwcmlvcigKICBmYW1pbHkgPSAibm9ybWFsIiwKICBtZWFuID0gNTAsCiAgc2QgPSAxNAopCgpwbG90KG1vdGl2YXRpb25fdGhlb3J5KSArCiAgdGhlbWVfbWluaW1hbCgxNCkKCmBgYAoKQW5kIHdlIGNhbiB1c2UgYSBub3JtYWwgbGlrZWxpaG9vZCB0byByZXByZXNlbnQgdGhlIGRhdGEgZnJvbSB0aGUgbG9jYWwKdGFzay4KCmBgYHtyfQojfCBlY2hvID0gVFJVRSwgaW5jbHVkZSA9IFRSVUUKCmRhdGFfbW9kZWwgPC0gbGlrZWxpaG9vZCgKICBmYW1pbHkgPSAibm9ybWFsIiwKICBtZWFuID0gMTUsCiAgc2QgPSAxMwopCmBgYAoKT25jZSBhZ2Fpbiwgd2UgY2FuIHVzZSBhIG51bGwgbW9kZWwgd2l0aCBhIHBvaW50IGF0IDAuCgpCZWZvcmUgd2UgY29tcHV0ZSB0aGUgQmF5ZXMgZmFjdG9yLCBsZXQncyBmaXJzdCB0aGluayBhYm91dCB3aGF0IHdlJ3JlCmNvbXBhcmluZy4gV2UgaGF2ZSBvbmUgdGhlb3J5IHRoYXQgc2F5czogIlBlb3BsZSBpbiBDaGluYSBzY29yZSBiZXR0ZXIgb24KYSBsZWFybmluZyB0YXNrIG9mIGxvY2FsIGZlYXR1cmVzIGJ5IGFib3V0IHRoZSBzYW1lIGFtb3VudCBhcyB0aGV5Cm91dHBlcmZvcm0gcGVvcGxlIGluIHRoZSBVSyBvbiBhIGxlYXJuaW5nIHRhc2sgb2YgZ2xvYmFsIGZlYXR1cmVzIi4gQW5kCmFub3RoZXIgdGhlb3J5IHRoYXQgc2F5czogIlBlb3BsZSBpbiBDaGluYSBhbmQgcGVvcGxlIGluIHRoZSBVSyBzY29yZSB0aGUKc2FtZSBvbiBhIGxlYXJuaW5nIHRhc2sgb2YgbG9jYWwgZmVhdHVyZXMuIiBUaGUgQmF5ZXMgZmFjdG9yIHRoYXQgd2UKY29tcHV0ZSBpcyBnb2luZyB0byB0ZWxsIHVzIHdoaWNoIG9mICoqdGhlc2Ugc3BlY2lmaWMgdHdvKiogaHlwb3RoZXNlcyBpcwpiZXR0ZXIgc3VwcG9ydGVkIGJ5IHRoZSBkYXRhLgoKYGBge3J9CiN8IGVjaG8gPSBUUlVFLCBpbmNsdWRlID0gVFJVRQoKbW90aXZhdGlvbl9tb2RlbCA8LSBkYXRhX21vZGVsICogbW90aXZhdGlvbl90aGVvcnkKbnVsbF9tb2RlbCA8LSBkYXRhX21vZGVsICogcHJpb3IoZmFtaWx5ID0gInBvaW50IiwgMCkKCm1vdGl2YXRpb25fZXZpZGVuY2UgPC0gaW50ZWdyYWwobW90aXZhdGlvbl9tb2RlbCkKbnVsbF9ldmlkZW5jZSA8LSBpbnRlZ3JhbChudWxsX21vZGVsKQoKYmYgPC0gbW90aXZhdGlvbl9ldmlkZW5jZSAvIG51bGxfZXZpZGVuY2UKCnN1bW1hcnkoYmYpCmBgYAoKVGhlIHJlc3VsdHMgc2hvdyBtb2RlcmF0ZSBldmlkZW5jZSBpbiBmYXZvdXIgb2YgdGhlIG51bGwgdGhlb3J5LiBUaGF0IGlzLApyZWxhdGl2ZSB0byBvdXIgc3BlY2lmaWMgbW90aXZhdGlvbiB0aGVvcnksIHRoZSBudWxsIHRoZW9yeSBpcyBiZXR0ZXIKc3VwcG9ydGVkIGJ5IHRoZSBkYXRhLiBUaGUgQmF5ZXMgZmFjdG9ycyBhcmUgYWx3YXlzIHNwZWNpZmljIHRvIHRoZSBleGFjdAp0d28gaHlwb3RoZXNlcyB0aGF0IHdlJ3JlIGNvbXBhcmluZy4gCgpJZiB3ZSB3ZXJlIHRvIGNvbXBhcmUgZGlmZmVyZW50IGh5cG90aGVzZXMgdGhlbiB0aGUgQmF5ZXMgZmFjdG9yIHdvdWxkIGJlCmRpZmZlcmVudC4gU29tZSBwZW9wbGUgZmluZCB0aGlzIHdvcnJ5aW5nLCBidXQgb2YgY291cnNlIGl0IGhhcyB0byBiZSB0aGUKY2FzZSEgQ29tcGFyaW5nIGRpZmZlcmVudCBoeXBvdGhlc2VzIG1lYW5zIGFza2luZyBkaWZmZXJlbnQgcXVlc3Rpb25zIGFuZAp0aGVyZWZvcmUgd2Ugc2hvdWxkbid0IGJlIHN1cnByaXNlZCBpZiB3ZSBnZXQgZGlmZmVyZW50IGFuc3dlcnMuCgojIyBIb3cgZG8gSSBrbm93IHdoYXQgbXkgdGhlb3J5IHByZWRpY3RzCgpBZ2Fpbiwga25vd2luZyB3aGF0IG91ciB0aGVvcmllcyBwcmVkaWN0IGNhbiBiZSBhIGRpZmZpY3VsdCB0YXNrLiBUaGVyZWZvcmUsCltEaWVuZXMgKDIwMTkpXShodHRwczovL2RvaS5vcmcvMTAuMTE3Ny8yNTE1MjQ1OTE5ODc2OTYwKSBoYXMgY29tZSB1cCB3aXRoIHNvbWUKaGV1cmlzdGljcyBmb3IgdGhpbmtpbmcgYWJvdXQgd2hhdCBvdXIgdGhlb3JpZXMgcHJlZGljdC4gVGhpcyBwYXBlciBjYW4gYmUgYQp1c2VmdWwgcmVzb3VyY2UgZm9yIHlvdSB0byB0dXJuIGJhY2sgdG8gYXMgeW91IGNvbWUgdXAgd2l0aCB5b3VyIG93biBzdHVkaWVzLAphbmQgZGV2ZWxvcCBhbmQgdGVzdCB5b3VyIG93biB0aGVvcmllcy4KCkEga2V5IGFzcGVjdCBvZiB0aGUgaGV1cmlzdGljcyB0aGF0IERpZW5lcyAoMjAxOSkgb3V0bGluZXMgaXMgdGhpbmtpbmcgYWJvdXQKdGhlICoqbWF4aW11bSBwb3NzaWJsZSBlZmZlY3QqKiB0aGF0IGNhbiBiZSBmb3VuZCBiZXR3ZWVuIGNvbmRpdGlvbnMgb3IgZ3JvdXBzLgpPbmNlIHdlIGtub3cgdGhpcyBtYXhpbXVtIHBvc3NpYmxlIGVmZmVjdCB3ZSBjYW4gdXNlIGEgKmhhbGYtbm9ybWFsKiBwcmlvcgpzY2FsZWQgYWNjb3JkaW5nIHRvIHRoaXMgbWF4aW11bS4gU3BlY2lmaWNhbGx5LCB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZQpwcmlvciBpcyBzZXQgdG8gaGFsZiB0aGUgbWF4aW11bS4gVGhpcyBtZWFucyB0aGF0IH45OCUgb2YgdGhlIHBsYXVzaWJsZSBlZmZlY3RzCndpbGwgbGllIGJldHdlZW4gMCBhbmQgdGhlIG1heGltdW0gcG9zc2libGUgZWZmZWN0LiAKCldlIGNhbiBnbyB0aHJvdWdoIGFuIGV4YW1wbGUgb2YgdGhpcyBoZXVyaXN0aWMgZnJvbSBEaWVuZXMgKDIwMTkpLiBJbiB0aGUKZXhhbXBsZSBzdHVkeSwgYnkgQmFsemFyaW5pLCBEaGFybWEsIE11aXNlLCBhbmQgS29odXQgKDIwMTkpLCByZWxhdGlvbnNoaXAKcXVhbGl0eSBmb3IgcG9seWFtb3JvdXMgYW5kIG1vbm9nYW1vdXMgcmVsYXRpb25zaGlwcyB3YXMgbWVhc3VyZWQgb24gYQpudXJ0dXJhbmNlIHNjYWxlIHdpdGggcmF0aW5nIGZyb20gMSB0byA3LiBJdCB3YXMgcHJlZGljdGVkIHRoZSBpbiAKcG9seWFtb3JvdXMgcmVsYXRpb25zaGlwcywgbnVydHVyYW5jZSBzY29yZXMgd291bGQgYmUgaGlnaGVyLgoKVGhlIG1vbm9nYW1vdXMgcGFydGljaXBhbnRzIHJhdGVkIHRoZWlyIHBhcnRuZXIncyBudXJ0dXJhbmNlIGFzIDUuODUuICBXaGlsZSAKdGhlIHBvbHlhbW9yb3VzIHBhcnRpY2lwYW50cyByYXRlZCB0aGVpciBwYXJ0bmVyJ3MgbnVydHVyYW5jZSBhcyA1LjgwLiBUaGlzCmdhdmUgYSBtZWFuIGRpZmZlcmVuY2Ugb2YgLTAuMDUsIGFuZCBhIHN0YW5kYXJkIGVycm9yIG9mIDAuMTEuCgpXaGF0IGlzIHRoZSBtYXhpbXVtIHBvc3NpYmxlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGdyb3Vwcz8gVGhlIHNjYWxlIHJ1bnMKZnJvbSAxIHRvIDcsIHNvIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHNjb3JlIHRoZSBwb2x5YW1vcm91cyBncm91cCB3b3VsZCBiZSA3LgpJZiB0aGlzIGdyb3VwIGhhZCBhIG1lYW4gb2YgNywgdGhlbiB0aGUgZ3JvdXAgZGlmZmVyZW5jZSB3b3VsZCBiZSAxLjE1LiBVc2luZwp0aGUgaGV1cmlzdGljLCB3ZSBjYW4gdXNlIGEgaGFsZi1ub3JtYWwgcHJpb3Igd2l0aCBhIG1lYW4gb2YgMCBhbmQgYSAKc3RhbmRhcmQgZGV2aWF0aW9uIG9mICRcZnJhY3sxLjE1fXsyfSQuIFB1dHRpbmcgdGhpcyB0b2dldGhlciB3aXRoIGEgbnVsbApoeXBvdGhlc2VzIG9mIGEgcG9pbnQgYSAwLCBhbmQgb3VyIGRhdGEgbW9kZWwgd2l0aCBhIG5vcm1hbCBsaWtlbGlob29kIG9mIGEgCm1lYW4gb2YgLTAuMDUgKHdpdGggYSBzdGFuZGFyZCBlcnJvciBvZiAwLjExKSwgd2UgZ2V0IHRoZSBmb2xsb3dpbmcgcmVzdWx0LgoKYGBge3J9CiN8IGVjaG8gPSBUUlVFLCBpbmNsdWRlID0gVFJVRQoKIyBkZWZpbmUgbGlrZWxpaG9vZApkYXRhX21vZGVsIDwtIGxpa2VsaWhvb2QoCiAgZmFtaWx5ID0gIm5vcm1hbCIsCiAgbWVhbiA9IC0wLjA1LAogIHNkID0gMC4xMQopCgojIGRlZmluZSBhbHRlcm5hdGl2ZSBwcmlvcgphbHRfcHJpb3IgPC0gcHJpb3IoCiAgZmFtaWx5ID0gIm5vcm1hbCIsCiAgbWVhbiA9IDAsCiAgc2QgPSAwLjU4LCByYW5nZSA9IGMoMCwgSW5mKQopCgojIGRlZmluZSBudWxsIHByaW9yCm51bGxfcHJpb3IgPC0gcHJpb3IoZmFtaWx5ID0gInBvaW50IiwgcG9pbnQgPSAwKQoKIyB3ZWlnaHQgbGlrZWxpaG9vZCBieSBwcmlvcgptMSA8LSBkYXRhX21vZGVsICogYWx0X3ByaW9yCm0wIDwtIGRhdGFfbW9kZWwgKiBudWxsX3ByaW9yCgojIHRha2UgdGhlIGludGVyZ2FsIG9mIGVhY2ggd2VpZ2h0ZWQgbGlrZWxpaG9vZAojIGFuZCBkaXZpZGUgdGhlbQpiZiA8LSBpbnRlZ3JhbChtMSkgLyBpbnRlZ3JhbChtMCkKCiMgZ2V0IGEgdmVyYmFsIGRlc2NyaXB0aW9uIG9mIHRoZSBCYXllcyBmYWN0b3IKc3VtbWFyeShiZikKYGBgCgoKCgoK" download="07-prior-II.Rmd"><img src="https://img.shields.io/badge/.Rmd-Download-blue"></a>
[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/ljcolling/bayes2022/blob/main/_notebooks/07-prior-II.ipynb)

Although the method of using default priors is easy to use some have
questioned whether it really makes sense to talk of **default**
hypotheses. The real power of Bayes factors comes from *directly testing
theories*, and as [Dienes
(2019)](https://doi.org/10.1177/2515245919876960) points out, "there is no
such thing as a default theory, so there cannot be a default" alternative
hypothesis. Dienes instead recommends formulating priors for our specific
situation at hand. That is, formulating priors that actually match our
scientific theories about how the world works.

The second set of priors that we developed for the coin flip examples
represents a case of doing this. Instead of saying that our alternative
hypothesis should represent each outcome as being equally likely we instead
came up with a theory of how biased coins are likely to behave. In fact, we
came up with a few theories. One theory, for example, said that biased coins
would show heads more often. And another theory said that biased coins would
behave similarly to fair coins; however, they would show heads or tails
slightly less often than would be expected from a fair coin. We were able to
come up with priors that directly represented these theories and we were able
to compute Bayes factors comparing these theories with our fair coin theory
(that the bias is exactly 0.5).

Of course using these kinds of priors is far more difficult than using
default priors because it forces us to think about what our scientific
theories predict. However, as scientists, we probably should be thinking
about what our theories predict! But knowing what our scientific theories
predict is a very difficult task and, as psychology researchers we are not
well trained to think in terms of quantitative predictions. This is
likely an artefact of the dominance of *null-hypothesis significance
testing* in psychology, because these kinds of statistical procedures
encourage thinking in terms of *default* hypotheses (see [Colling & Sz≈±cs,
2020](https://link.springer.com/content/pdf/10.1007/s13164-018-0421-4.pdf)).
Therefore, adopting Bayesian methods can require a big change in how we
think about **theory** in psychology. 

The aim of this section is not to teach you how to do good **theory**. Instead,
the aim is to give you the tools to test theories once you've come up with
them. The hope is that once you have the tools, then come up with theories that
are testable with those tools. To do this, we'll look at some examples of how
to represent and then test theories with Bayes factors. Following this, we'll
cover some heuristics for coming up with predictions if we're unsure what
our theories predict.

## Examples of representing predictions

### Representing predictions with a uniform prior

The most straightforward way to represent the predictions of a theory is
with a uniform prior. A uniform prior essentially represents the idea
that, if there is an effect, then it will be some value between a defined
minimum and a defined maximum, with all effects being equally probable.

Here is an example taken from [Dienes
(2014)](https://www.frontiersin.org/articles/10.3389/fpsyg.2014.00781/full).
In this example experiment, negative mood was *predicted to reduce
learning on a task*. Learning was measured using a two-alternative forced
choice measure (chance performance would be 50%). It was found that, in
the *neutral mood condition* performance on the task was at 70%. If
*negative mood* reduced learning, the population mean of this condition
would have to lie somewhere between chance performance (50%) and
performance on the neutral condition (70%). Therefore, the difference
between conditions would have to be between 0% and 20%. 

We could represent this as a uniform prior with a minimum of 0 and
a maximum of 20. The code below does just that.

```{r}
#| echo = TRUE, include = TRUE

mood_theory <- prior(family = "uniform", min = 0, max = 20)

plot(mood_theory) +
  theme_minimal(14) +
  labs(x = "mean difference", y = "probability")
```

Now what do the data say? The results report a mean of 65% in the negative
mood condition (mean difference of 5%) with a standard error (standard
deviation of the mean difference) of 10. We can represent this data with
the code below. Following Dienes (2014), we'll use a *normal* likelihood. 

```{r}
#| echo = TRUE, include = TRUE

data_model <- likelihood(family = "normal", mean = 5, sd = 10)

plot(data_model) +
  theme_minimal(14) +
  labs(x = "mean difference", y = "likelihood")
```

Finally, we'll use a null prior of a point at 0 to represent our *no effect*
hypothesis. 

```{r}
#| echo = TRUE, include = TRUE

null_theory <- prior(family = "point", point = 0)

plot(null_theory) +
  theme_minimal(14) +
  labs(x = "mean difference", y = "probability")
```


With all the parts in place, we can now compute the Bayes factor.

```{r}
#| echo = TRUE, include = TRUE

mood_evidence <- integral(data_model * mood_theory)
null_evidence <- integral(data_model * null_theory)

bf <- mood_evidence / null_evidence
```

The resulting Bayes factor is barely different to 1. Therefore, the
results don't really give us a strong reason for favouring one theory over
the other. 

Sometimes it is useful to have verbal labels for the strength of evidence.
Wagenmakers et al (2017) suggests some verbal labels for strength of
evidence, and we can get the verbal label for the computed Bayes factor by
using the `summary` function, as shown below.

```{r}
#| echo = TRUE, include = TRUE

summary(bf)
```

### Representing predictions with a half-normal prior

A half normal distribution is another useful way to represent predictions for
theories. To come up with predictions for the theory, we'll use the results
from an earlier experiment to represent the predictions of the current
experiment.

Here is an example taken from [Dienes and Mclatchie
(2018)](https://link.springer.com/article/10.3758/s13423-017-1266-z). In a
study by Williams and Bargh (2008), people were ask to feel a hot or cold
therapeutic pack and then choose a treat for themselves or for a friend. Of
those participants exposed to a cold pack, 75% chose a treat for themselves
where only 45% chose the treat for their friend. We can express this difference
as an Odds Ratio (OR). This gives an OR of 3.52, which converted into Log Odds
(Log OR) is approximately 1.26. We take the natural log of the odds ratio,
because the natural log of the odds ratio is approximately normally
distributed, which means that we can model it with a *normal* likelihood.

After the original study, Lynott et al (2014) attempted a replication. Before
we get to the data that Lynott et al (2014) obtained, let's think about a possible
prediction. 

If the original study reported a true effect, then the replication study
should find an effect of roughly the same order of magnitude. Maybe
smaller, maybe larger, but not radically different.

Furthermore, it's also fair to assume that reported effects are usually larger
than the true effect, because larger effects are more likely to get published.
So the true effect is more likely to be smaller then the reported effect, and
less likely to be larger. How might we represent this idea? One way is with a
half normal distribution scaled according to the original finding. That is,
with a normal distribution centred at 0, and with a standard deviation of 1.26
(that is, the magnitude of the original effect). Furthermore, we'll limit the
distribution to be between the values of $0$ and $+\infin$ (because we have a
directional hypothesis).

```{r}
#| echo = TRUE, include = TRUE

theory_model <- prior(
  family = "normal",
  mean = 0,
  sd = 1.26,
  range = c(0, Inf)
)

plot(theory_model) +
  theme_minimal(14)
```

By defining the prior in this way, we're saying that ~68% of the plausible
effects lie between 0 and 1.26. And ~95% of plausible the effects lie somewhere
between 0 and twice the reported original effect (of 1.26). That is, we predict
the effect to be somewhere in the same range as the original study, but more
probably smaller than the effect originally reported.

Now that we have our predictions, we can look at the results of Lynott et al's
replication attempt. Their results showed a Log OR of -0.26, with a standard
error of 0.14. (Note, that typically, studies don't report the standard error
of the Log OR, but rather report the 95% confidence interval of the OR.
However, it's possible to compute the standard error of the Log OR from the 95%
confidence interval, as shown below). As mentioned above, because Log OR
approximately follows a normal distribution, we can model it using the *normal*
likelihood, as shown below. 

```{r}
#| echo = TRUE, include = TRUE

# For completeness, we'll work out the ln OR and
# the standard error from the reported confidence
# interval

reported_or_ci <- c(0.58, 1.02)

log_or_ci <- log(reported_or_ci)
log_or <- mean(log_or_ci)
log_or_ci_width <- abs(log_or_ci[1] - log_or)
log_or_se <- log_or_ci_width / 1.96

data_model <- likelihood(
  family = "normal",
  mean = log_or,
  sd = log_or_se
)

plot(data_model) +
  theme_minimal(14)
```

Finally, for our null hypothesis, we'll just use a point at 0. With all the
bit's in place, we can compute the Bayes factor. The code below is generated
using the web-app. However, I've just removed the final lines that generate the
plots. You can access the web-app's advanced output at the [following
link](https://bayesplay.colling.net.nz/advanced?model=%7B%22likelihoodDef%22%3A%7B%22distribution%22%3A%22normal%22%2C%22parameters%22%3A%7B%22mean%22%3A-0.2624623%2C%22sd%22%3A0.1440127%7D%7D%2C%22altpriorDef%22%3A%7B%22distribution%22%3A%22normal%22%2C%22parameters%22%3A%7B%22mean%22%3A0%2C%22sd%22%3A1.26%2C%22min%22%3A0%2C%22max%22%3Anull%7D%7D%2C%22nullpriorDef%22%3A%7B%22distribution%22%3A%22point%22%2C%22parameters%22%3A%7B%22point%22%3A0%7D%7D%7D).

```{r}
#| echo = TRUE, include = TRUE

# define likelihood
data_model <- likelihood(family = "normal", mean = -0.2624623, sd = 0.1440127)

# define alternative prior
alt_prior <- prior(family = "normal", mean = 0, sd = 1.26, range = c(0, Inf))

# define null prior
null_prior <- prior(family = "point", point = 0)

# weight likelihood by prior
m1 <- data_model * alt_prior
m0 <- data_model * null_prior

# take the intergal of each weighted likelihood
# and divide them
bf <- integral(m1) / integral(m0)

# get a verbal description of the Bayes factor
summary(bf)

```

The results show, strong evidence for the null hypothesis over the
alternative hypothesis. The results are $\frac{1}{0.0411}\approx24$ times
more likely under our null hypothesis than our alternative hypothesis.

### Representing predictions with the normal prior

In the preceding two examples, we had directional hypotheses. This meant
that all our priors were truncated at one end at 0. But sometimes we don't
have directional hypotheses. Instead, we might have non-directional
hypotheses. If we have non-directional hypotheses then we can use a *full*
normal distribution, rather than one that's been limited to be between $0$
and $+\infin$. 

Furthermore, it is also not necessary to have normal distributions centred
at 0. We might use a normal distribution centred at some other value to
represent the idea that the effect is roughly with in a certain range but with
smaller effects being more probable than larger effects. To see how this works,
we'll go through an example in [Dienes
(2019)](https://doi.org/10.1177/2515245919876960).

Fu et al (2013) were interested in whether there are differences in learning
global and local structure between people in China and the UK, and a reaction
time task was used to assess this. The results showed that when it came to
*global structure*, people in China had superior performance relative to people
in the UK. The difference between the two groups was 50 ms (with a standard
error of 14 ms). However, for *local structure* learning, the difference was
only 15 ms (standard error of 13 ms). 

Fu et al (2013) wanted to test the theory that people in China simply scored
higher on the learning task (irrespective of global or local features)
because of higher motivation levels. If motivation levels were the only
cause of the differences then the group difference in the global task and the
group difference in the local task should be the same.

As a result, we could use the results from the global task (mean difference of
50 with an standard error of 14) to represent our predictions about the local
task. That is, we can use a normal prior with a mean of 50 and a standard
deviation of 14, as shown below.

```{r}
#| echo = TRUE, include = TRUE

motivation_theory <- prior(
  family = "normal",
  mean = 50,
  sd = 14
)

plot(motivation_theory) +
  theme_minimal(14)

```

And we can use a normal likelihood to represent the data from the local
task.

```{r}
#| echo = TRUE, include = TRUE

data_model <- likelihood(
  family = "normal",
  mean = 15,
  sd = 13
)
```

Once again, we can use a null model with a point at 0.

Before we compute the Bayes factor, let's first think about what we're
comparing. We have one theory that says: "People in China score better on
a learning task of local features by about the same amount as they
outperform people in the UK on a learning task of global features". And
another theory that says: "People in China and people in the UK score the
same on a learning task of local features." The Bayes factor that we
compute is going to tell us which of **these specific two** hypotheses is
better supported by the data.

```{r}
#| echo = TRUE, include = TRUE

motivation_model <- data_model * motivation_theory
null_model <- data_model * prior(family = "point", 0)

motivation_evidence <- integral(motivation_model)
null_evidence <- integral(null_model)

bf <- motivation_evidence / null_evidence

summary(bf)
```

The results show moderate evidence in favour of the null theory. That is,
relative to our specific motivation theory, the null theory is better
supported by the data. The Bayes factors are always specific to the exact
two hypotheses that we're comparing. 

If we were to compare different hypotheses then the Bayes factor would be
different. Some people find this worrying, but of course it has to be the
case! Comparing different hypotheses means asking different questions and
therefore we shouldn't be surprised if we get different answers.

## How do I know what my theory predicts

Again, knowing what our theories predict can be a difficult task. Therefore,
[Dienes (2019)](https://doi.org/10.1177/2515245919876960) has come up with some
heuristics for thinking about what our theories predict. This paper can be a
useful resource for you to turn back to as you come up with your own studies,
and develop and test your own theories.

A key aspect of the heuristics that Dienes (2019) outlines is thinking about
the **maximum possible effect** that can be found between conditions or groups.
Once we know this maximum possible effect we can use a *half-normal* prior
scaled according to this maximum. Specifically, the standard deviation of the
prior is set to half the maximum. This means that ~98% of the plausible effects
will lie between 0 and the maximum possible effect. 

We can go through an example of this heuristic from Dienes (2019). In the
example study, by Balzarini, Dharma, Muise, and Kohut (2019), relationship
quality for polyamorous and monogamous relationships was measured on a
nurturance scale with rating from 1 to 7. It was predicted the in 
polyamorous relationships, nurturance scores would be higher.

The monogamous participants rated their partner's nurturance as 5.85.  While 
the polyamorous participants rated their partner's nurturance as 5.80. This
gave a mean difference of -0.05, and a standard error of 0.11.

What is the maximum possible difference between the two groups? The scale runs
from 1 to 7, so the maximum possible score the polyamorous group would be 7.
If this group had a mean of 7, then the group difference would be 1.15. Using
the heuristic, we can use a half-normal prior with a mean of 0 and a 
standard deviation of $\frac{1.15}{2}$. Putting this together with a null
hypotheses of a point a 0, and our data model with a normal likelihood of a 
mean of -0.05 (with a standard error of 0.11), we get the following result.

```{r}
#| echo = TRUE, include = TRUE

# define likelihood
data_model <- likelihood(
  family = "normal",
  mean = -0.05,
  sd = 0.11
)

# define alternative prior
alt_prior <- prior(
  family = "normal",
  mean = 0,
  sd = 0.58, range = c(0, Inf)
)

# define null prior
null_prior <- prior(family = "point", point = 0)

# weight likelihood by prior
m1 <- data_model * alt_prior
m0 <- data_model * null_prior

# take the intergal of each weighted likelihood
# and divide them
bf <- integral(m1) / integral(m0)

# get a verbal description of the Bayes factor
summary(bf)
```





